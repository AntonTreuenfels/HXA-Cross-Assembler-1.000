# Address Mode Test Generator for HXA65

# by Anton Treuenfels
# for Python 3.11.4

# first created: 10/05/24
# last revision: 11/29/24

# --------------------------

# the genesis of this program was the realization that doing this by hand
# was not only tedious but also prone to overlooking all kinds of legal
# and illegal combinations

# what this program does:

# imports the cpu handler to get access to the cpus and opcodes it knows
# and how to handle them

# generates several tests to check how legal, illegal and forced mode
# instruction are reacted to, alone and in address mode groups
# (because the latter are shorter and easier to understand)

# writes the expected pass and error counts of all tests at each test end
# - errors need to be manually copied to the "Error(s):" line near the start
# of each file, where the automated check program expects to find them.

# an alternatiave would be to keep the entire output file in memory
# and insert the counts before writing it

# an earlier program, MODE65.AWK, was a less ambitious version of this

# --------------------------

import os
import re
import sys
from time import asctime
# other HXA modules
import hxa # mainly to make sure all the other HXA modules are initialized
import cpu_hxa65 as CPU

def error(text0, text1):
	print( f"Error: {text0}: {text1}\n" )

# --------------------------

class OSvariables(object):

	def __init__(self):

		self.testdir = 'test65'			# test directory

		self.currfile = None			# current file being processed

		self.outobj = None				# output file object

		self.cpu = None					# cpu name

		self.allmnemonics = []			# all mnemonics of cpu
		self.modes = {}					# adress modes associated with individual mnemonics
		self.allmodes = []				# all address modes of cpu

		self.grouprep = {}				# "representative" (first) mnemonic of each group
		self.groupmem = {}				# mnemonics sharing this address mode

		self.passnum = 1				# pass number

		self.accept1 = {}				# accepted on first pass
		self.accept2 = {}				# accepted on second pass

		self.goodcount = 0				# number of instructions that pass (some by accident)
		self.badcount = 0				# number of instruction that fail (on purpose)

# instantiate
_OS = OSvariables()

cpu65C02plus	= [ "65C02", "R65C02", "HUC6280", "W65C02S", "W65C816S" ]
cpuR65C02plus	= [ "R65C02", "HUC6280", "W65C02S" ]

# -----------------------------

def _open(fname, mode):
	'''open a file for writing'''
	# fname is assumed to be a full pathname starting from device root
	try:
		# use OS default encoding
		fobj = open( fname, "wt" )
	except Exception:
		error( 'File not open', fname )
	else:
		_OS.currfile = fname
		return fobj

	# no file opened
	return None

def _normalizef(name):
	'''normalize file name'''
	# make sure file is in test directory
	fname = f'{_OS.testdir}\\test{name}.a'
	# normalize case, slashes and path 
	return os.path.normpath( os.path.normcase(fname) ).upper()

# -----------------------------

def closeout():
	'''close output file'''
	if _OS.outobj is not None:
		_OS.outobj.close()
		_OS.outobj = None

def openout(name):
	'''try to open a file for writing'''
	# since we only need one output file at at time,
	# an open file here is a mistake (we silently fix it)
	closeout()

	# open ?
	_OS.outobj = _open( _normalizef(name), "wt" )

	return True if _OS.outobj is not None else False

# -------------------------------

def write(this):
	'''write a line to text output file'''
	_OS.outobj.write( f'{this}\n' )

def writetab(this):
	'''write a tabbed line'''
	write( f"\t\t{this}" )

def writecomment(this):
	'''write a comment line'''
	write( f"; {this}" )

def writenl():
	'''write a newline'''
	write( '' )

def writesepnl(this, tabbed=False):
	'''write comment separated by newlines'''
	writenl()
	if tabbed:
		writetab( f"; {this}" )
	else:
		writecomment( this )
	writenl()

def write_div():
	'''write a divider line'''
	writesepnl( "-------------------------------" )

def write_gen():
	'''write test generator name'''
	writesepnl( f"generated by MODE65.PY - {asctime()}" )

def cant_happen(method, ins, mode):
	'''bailed out of match'''
	write( f"Can't happen (in {method}: {ins} {mode})" )

# -------------------------------

def write_commonheader(cpu):
	'''write header part common to both ok and error files'''
	write_div()
	writetab( ".listfile" )
	writetab( ".errfile" )
	writenl()
	writetab( ".maxerr\t10000\t\t; increase default count" )
	write_div()
	writetab( f".cpu\t{cpu}" )
	writetab( ".org\t$1000" )
	write_div()
	writecomment( "backward reference" )
	writenl()
	write( "bak08\t.equ\t$12" )
	write( "bak16\t.equ\t$1234" )
	write( "bak24\t.equ\t$456789" )
	write( "bak32\t.equ\t$89ABCDEF" )

	#initialize some variables

	_OS.passnum = 1
	_OS.accept1 = {}
	_OS.accept2 = {}
	_OS.goodcount = _OS.badcount = 0

def write_ok_header(cpu, testid, desc):
	'''write okay testfile header'''
	writecomment( f"Hobby Cross-Assembler {CPU.name()} Test {cpu}{testid.lower()}" )
	writecomment( f"{cpu}\\Instruction Set" )
	writecomment( f"ok: {desc}" )
	write_gen()
	writecomment( "no errors to detect" )
	write_commonheader(cpu )

def write_fail_header(cpu, testid, desc):
	'''write fail testfile header'''
	writecomment( f"Hobby Cross-Assembler {CPU.name()} Error Test {cpu}{testid.lower()}" )
	writecomment( f"{cpu}\\Instruction Set" )
	writecomment( f"error: {desc}" )
	write_gen()
	writenl()
	writecomment( "warning(s):\n" )
	writecomment( "errors(s):\n" )
	writecomment( "fatal:" )
	write_commonheader( cpu )
 
def write_trailer():
	'''write test file trailer'''
	write_div()
	writecomment( "forward reference" )
	writenl()
	write( "fwd32\t.equ\t$89ABCDEF" )
	write( "fwd24\t.equ\t$456789" )
	write( "fwd16\t.equ\t$1234" )
	write( "fwd08\t.equ\t$12" )
	write_div()
	writetab( ".end" )
	write_div()
	writecomment( f"{_OS.goodcount} pass" )
	writecomment( f"{_OS.badcount} fail" )

# -------------------------------

def write_members(mnemonic):
	'''write mnemonics which share addr mode of 'mnemonic'''
	writetab( f"; check {mnemonic}" )
	writetab( f"; {len(_OS.groupmem[mnemonic])+1} mnemonics with modes {_OS.modes[mnemonic]}" )
	for m in _OS.groupmem[mnemonic]:
		writetab( f"; {m}" )
	writenl()

# -------------------------------

def writeins(ins, expr=None, tag=None):
	while len(ins) % 4:
		ins += " "

	if expr is None:
			writetab( f"{ins}" )
	elif tag is None:
			writetab( f"{ins}\t{expr}" )
	else:
		while len(expr) % 8:
			expr += " "
		writetab( f"{ins}\t{expr}\t; {tag}" )

# -------------------------------

def good(count):
	_OS.goodcount += count

def bad(count):
	_OS.badcount += count

# -------------------------------

def passtest(mnemonic, mode, force=None):
	'''PASS test message'''
	if force is None:
		return f"**PASS  {mnemonic.upper()}  {mode}\n"
	else:
		return f"**PASS  {mnemonic.upper()}  {mode} as {force}\n"

def passalt(mnemonic, mode, alt=None):
	'''PASS-as-altmode message'''
	if alt is None:
		return f"**PASS  {mnemonic.upper()}  {mode}\n"
	else:
		return f"**PASS  {mnemonic.upper()}  {mode}  (as {alt})\n"

def failtest(mnemonic, mode, force=None):
	'''FAIL test message'''
	if force is None:
		return f"**FAIL  {mnemonic.upper()}  {mode}\n"
	else:
		return f"**FAIL  {mnemonic.upper()}  {mode} as {force}\n"

# -------------------------------

def accept_alt1(mode, allowed, get=False):
	'''can a mode be mistaken for another during first pass ?'''

	# ADC-group 7 mnemonics with modes ['ab', 'abx', 'aby', 'imm', 'lab', 'labx', 'lzpi', 'lzpiy', 'sr', 'sriy', 'zp', 'zpi', 'zpiy', 'zpx', 'zpxi']
	# ASL-group 6 mnemonics with modes ['ab', 'abx', 'acc', 'imp', 'zp', 'zpx']
	# BIT-group 2 mnemonics with modes ['ab', 'abx', 'imm', 'zp', 'zpx']
	# BRK-group 2 mnemonics with modes ['imm', 'imp', 'zp']
	# BRL-group 2 mnemonics with modes ['lpcr']
	# CLC-group 50 mnemonics with modes ['imp']
	# COP-group 1 mnemonics with modes ['imm', 'zp']
	# CPX-group 2 mnemonics with modes ['ab', 'imm', 'zp']
	# JML-group 1 mnemonics with modes ['abi', 'lab', 'labi']
	# JMP-group 1 mnemonics with modes ['ab', 'abi', 'abxi', 'lab', 'labi']
	# JSL-group 1 mnemonics with modes ['lab']
	# JSR-group 1 mnemonics with modes ['ab', 'abxi', 'lab']
	# LSX-group 1 mnemonics with modes ['ab', 'aby', 'imm', 'zp', 'zpy']
	# MVN-group 2 mnemonics with modes ['bmv']
	# PEA-group 1 mnemonics with modes ['ab', 'imm']
	# PER-group 1 mnemonics with modes ['zp', 'zpi']
	# RED-group 2 mnemonics with modes ['imm']
	# STA-group 1 mnemonics with modes ['ab', 'abx', 'aby', 'lab', 'labx', 'lzpi', 'lzpiy', 'sr', 'sriy', 'zp', 'zpi', 'zpiy', 'zpx', 'zpxi']
	# STX-group 1 mnemonics with modes ['ab', 'zp', 'zpy']
	# STY-group 1 mnemonics with modes ['ab', 'zp', 'zpx']
	# STZ-group 1 mnemonics with modes ['ab', 'abx', 'zp', 'zpx']
	# TRB-group 2 mnemonics with modes ['ab', 'zp']

	def any_alt(modes):
		for alt in modes:
			if alt in allowed:
				return True
		return False

	def get_alt(modes):
		for alt in modes:
			if alt in allowed:
				return alt
		return "@"	# shouldn't happen

	_accept = get_alt if get else any_alt 

	# we know that 'mode' does not exist in 'allowed'
	# - but it may get through this pass if any alternate exists

	match mode:

		case "ab":	# expr - ab, zp, lab, pcr, lpcr
			return _accept( ["zp", "lab", "pcr", "lpcr"] )

		case "abi": # (expr) - abi, zpi
			return _accept( ["zpi"] ) 

		case "abx": # expr,x - abx, zpx, labx
			return _accept( ["zpx", "labx"] ) 

		case "abxi": # (expr,x) - abxi, zpxi
			return _accept( ["zpxi"] )

		case "aby": # expr,y - aby, zpy
			return _accept( ["zpy"] )

		case "lab": # expr - ab, zp, lab, pcr, lpcr
			return _accept( ["ab", "zp", "pcr", "lpcr"] )

		case "labi": # [expr] - labi, lzpi
			return _accept( ["lzpi"] )

		case "labx": # expr,x - abx, zpx, labx 
			return _accept( ["abx", "zpx"] ) 

		case "lpcr": # expr - ab, zp, lab, pcr, lpcr
			return _accept( ["ab", "zp", "lab", "pcr"] )

		case "lzpi": # [expr] - labi, lzpi
			return _accept( ["labi"] )

		case "pcr": # expr - ab, zp, lab, pcr, lpcr
			return _accept( ["ab", "zp", "lab", "lpcr"] )

		case "zp": # expr - ab, zp, lab, pcr, lpcr
			return _accept( ["ab", "lab", "pcr", "lpcr"] ) 

		case "zpi": # (expr) - abi, zpi
			return _accept( ["abi"] ) 

		case "zpx": # expr,x - abx, zpx, labx
			return _accept( ["abx", "labx"] ) 

		case "zpxi": # (expr,x) - abxi, zpxi
			return _accept( ["abxi"] ) 

		case "zpy": # expr,y - aby, zpy
			return _accept( ["aby"] )

		case _:
			return "@" if get else False

def accept_alt2(mode, allowed, get=False):
	'''can a mode be mistaken for another during second pass ?'''

	def any_alt(modes):
		for alt in modes:
			if alt in allowed:
				return True
		return False

	def get_alt(modes):
		for alt in modes:
			if alt in allowed:
				return alt
		return "@"	# shouldn't happen

	_accept = get_alt if get else any_alt 

	# we know that 'mode' does not exist in 'allowed',
	# but test made it through the first pass because
	# its actual operand value could possibly be acceptable
	# -most often HXA is now looking for an unsigned 16-bit value,
	# but sometimes a 24-bit value is acceptable
	# we are relying heavily here on knowing what modes
	# are acceptable in what combinations
	# tests are set up to generate out-of-range values if they fail
	# - in the wild, they may still work if values are in range

	match mode:

		# tests generate 16-bit values

		case "ab":	# expr - ab, zp(8), lab(24), pcr(8), lpcr(16)
			return _accept( ["lab", "lpcr"] )

		case "abi": # (expr) - abi, zpi(8)
			return False

		case "abx": # expr,x - abx, zpx(8), labx(24)
			return False

		case "abxi": # (expr,x) - abxi, zpxi(8)
			return False

		case "aby": # expr,y - aby, zpy(8)+
			return False

		# tests generate 24-bit values
		# -none of which can get through the second pass

		case "lab": # expr - ab, zp, lab, pcr, lpcr
			return False

		case "labi": # [expr] - labi, lzpi
			return False

		case "labx": # expr,x - abx, zpx, labx 
			return False

		# tests generate 16-bit values

		case "lpcr": # expr - ab, zp, lab, pcr, lpcr
			return _accept( ["ab", "pcr", "lab"] )

		# tests generate 8-bit values

		case "lzpi": # [expr] - labi(24), lzpi
			return _accept( ["labi"] )

		case "pcr": # expr - ab(16), zp(8), lab(24), pcr, lpcr(16)
			return _accept( ["ab", "lab", "lpcr"] )

		case "zp": # expr - ab(16), zp, lab(24), pcr(8), lpcr(16)
			return _accept( ["ab", "lab", "lpcr"] )

		case "zpi": # (expr) - abi(16), zpi
			return _accept( ["abi"] )

		case "zpx": # expr,x - abx(16), zpx, labx(24)
			return False 

		case "zpxi": # (expr,x) - abxi(16), zpxi
			return _accept( ["abxi"] ) 

		case "zpy": # expr,y - aby(16), zpy
			return _accept( ["aby"] )

		case _:
			return False

# -------------------------------

def write_ins(mnemonic, mode, addrmodes, doecho=False):

	# more verbose than necessary
	# - but should be fairly easy to follow

	# check if we should specially note HXA assumes absolute mode
	def checkab(mnemonic, mode, expr):
		if mode in addrmodes and not asalt:
			writeins( mnemonic.capitalize(), expr, "(absolute)" )
		else:
			writeins( mnemonic, expr )

	# write message to error file as well as source file ?
	leader = ".echo" if doecho else ";"

	# a legal mode for this mnemonic ?
	if mode in addrmodes:
		writetab( f"{leader} {passtest(mnemonic, mode)}" )
		mnemonic = mnemonic.upper()
		goodins = True
		asalt = False
	# illegal mode makes it past first pass ?
	elif _OS.passnum == 1 and accept_alt1(mode, addrmodes):
		altmode = accept_alt1( mode, addrmodes, True )
		writetab( f"{leader} {passalt(mnemonic, mode, altmode)}" )
		if mnemonic in _OS.accept1:
			_OS.accept1[ mnemonic ].append( mode )
		else:
			_OS.accept1[ mnemonic ] = [ mode ]
		mnemonic = mnemonic.capitalize()
		goodins = asalt = True
	# illegal mode makes it past second pass ?
	elif _OS.passnum == 2 and accept_alt2(mode, addrmodes):
		altmode = accept_alt2( mode, addrmodes, True )
		writetab( f"{leader} {passalt(mnemonic, mode, altmode)}" )
		if mnemonic in _OS.accept2:
			_OS.accept2[ mnemonic ].append( mode )
		else:
			_OS.accept2[ mnemonic ] = [ mode ]
		mnemonic = mnemonic.capitalize()
		goodins = asalt = True
	# how did illegal mode make it past second pass ?
	elif _OS.passnum == 3:
		altmode = accept_alt2( mode, addrmodes, True )
		writetab( f"{leader} {passalt(mnemonic, mode, altmode)}" )
		mnemonic = mnemonic.capitalize()
		goodins = asalt = True
	# not a legal mode
	else:
		writetab( f"{leader} {failtest(mnemonic, mode)}" )
		mnemonic = mnemonic.lower()
		goodins = asalt = False

	match mode:

		# absolute
		case "ab":
			writeins( mnemonic, "$1234")
			writeins( mnemonic, "bak16" )
			writeins( mnemonic, "fwd16" )
			inscnt = 3

		# absolute indirect
		case "abi":
			writeins( mnemonic, "($1234)" )
			writeins( mnemonic, "(bak16)" )
			writeins( mnemonic, "(fwd16)" )
			inscnt = 3

		# absolute immediate
		case "abimm" if _OS.cpu == "HUC6280":
			writeins( mnemonic, "#12, $1234" )
			writeins( mnemonic, "#bak08, bak16" )
			writeins( mnemonic, "#$82, fwd16" )
			inscnt = 3

		# absolute immediate x-indexed
		case "abimx" if _OS.cpu == "HUC6280":
			writeins( mnemonic, "#12, $1234,x" )
			writeins( mnemonic, "#bak08, bak16,X" )
			writeins( mnemonic, "#$82, fwd16,x" )
			inscnt = 3

		# absolute x-indexed
		case "abx":
			writeins( mnemonic, "$1234,X" )
			writeins( mnemonic, "bak16,x" )
			writeins( mnemonic, "fwd16,X" )
			inscnt = 3

		# absolute transfer
		case "abxfr" if _OS.cpu == "HUC6280":
			writeins( mnemonic, "$32, $1234, $5678" )
			writeins( mnemonic, "$1234, bak08, fwd08" )
			writeins( mnemonic, "fwd08, bak16, fwd16" )
			inscnt = 3

		# absolute x-indexed indirect
		case "abxi" if _OS.cpu in cpu65C02plus:
			writeins( mnemonic, "($1234,X)" )
			writeins( mnemonic, "(bak16,x)" )
			writeins( mnemonic, "(fwd16,X)" )
			inscnt = 3

		# absolute y-indexed
		case "aby":
			writeins( mnemonic, "$1234,Y" )
			writeins( mnemonic, "bak16,y" )
			writeins( mnemonic, "fwd16,Y" )
			inscnt = 3

		# accumulator
		case "acc":
			writeins( mnemonic, "A" )
			writeins( mnemonic, "a" )
			inscnt = 2

		# block move
		case "bmv" if _OS.cpu == "W65C816S":
			writeins( mnemonic, "#$12, #$34" )
			writeins( mnemonic, "#bak08, #fwd08" )
			writeins( mnemonic, "$123456, $789ABC" )
			writeins( mnemonic, "bak24, fwd24" )
			inscnt = 4

		# immediate
		case "imm":
			writeins( mnemonic, "#$12" )
			writeins( mnemonic, "#bak08" )
			writeins( mnemonic, "#fwd08" )
			inscnt = 3

		# implied
		case "imp":
			writeins( mnemonic, None )
			inscnt = 1

		# long absolute
		case "lab" if _OS.cpu == "W65C816S":
			writeins( mnemonic, "$123456" )
			writeins( mnemonic, "bak24" )
			writeins( mnemonic, "fwd24" )
			inscnt = 3

		# long absolute indirect
		case "labi" if _OS.cpu == "W65C816S":
			writeins( mnemonic, "[$123456]" )
			writeins( mnemonic, "[bak24]" )
			writeins( mnemonic, "[fwd24]" )
			inscnt = 3

		# long absolute x-indexed
		case "labx" if _OS.cpu == "W65C816S":
			writeins( mnemonic, "$123456,X" )
			writeins( mnemonic, "bak24,x" )
			writeins( mnemonic, "fwd24,X" )
			inscnt = 3

		# long program counter relative
		case "lpcr" if _OS.cpu == "W65C816S":
			writeins( mnemonic, ":+" )
			writeins( mnemonic, "-" )
			writeins( mnemonic, "+" )
			writeins( mnemonic, ":-" )
			inscnt = 4

		# long direct page indirect
		case "lzpi" if _OS.cpu == "W65C816S":
			writeins( mnemonic, "[$12]" )
			writeins( mnemonic, "[bak08]" )
			writeins( mnemonic, "[fwd08]" )
			inscnt = 3

		# long direct page indirect y-indexed
		case "lzpiy" if _OS.cpu == "W65C816S":
			writeins( mnemonic, "[$12],Y" )
			writeins( mnemonic, "[bak08],y" )
			writeins( mnemonic, "[fwd08],Y" )
			inscnt = 3

		# program counter relative
		case "pcr":
			writeins( mnemonic, ":+" )
			writeins( mnemonic, "-" )
			writeins( mnemonic, "+" )
			writeins( mnemonic, ":-" )
			inscnt = 4

		# stack relative
		case "sr" if _OS.cpu == "W65C816S":
			writeins( mnemonic, "$12,S" )
			writeins( mnemonic, "bak08,s" )
			writeins( mnemonic, "fwd08,S" )
			inscnt = 3

		# stack relative indirect y-indexed
		case "sriy" if _OS.cpu == "W65C816S":
			writeins( mnemonic, "($12,s),Y" )
			writeins( mnemonic, "(bak08,S),y" )
			writeins( mnemonic, "(fwd08,s),Y" )
			inscnt = 3

		# zero page
		case "zp":
			writeins( mnemonic, "$12" )
			writeins( mnemonic, "bak08" )
			checkab( mnemonic, "ab", "fwd08" )
			inscnt = 3

		# zero page indirect
		case "zpi" if _OS.cpu in cpu65C02plus:
			writeins( mnemonic, "($12)" )
			writeins( mnemonic, "(bak08)" )
			checkab( mnemonic, "abi", "(fwd08)" )
			inscnt = 3

		# zero page immediate
		case "zpimm" if _OS.cpu == "HUC6280":
			writeins( mnemonic, "#12, $34" )
			writeins( mnemonic, "#bak08, bak08" )
			writeins( mnemonic, "#$82, fwd08" )
			inscnt = 3

		# zero page immediate x-indexed
		case "zpimx" if _OS.cpu == "HUC6280":
			writeins( mnemonic, "#12, $34,X" )
			writeins( mnemonic, "#bak08, bak08,x" )
			writeins( mnemonic, "#$82, fwd08,X" )
			inscnt = 3

		# zero page indirect y-indexed
		case "zpiy":
			writeins( mnemonic, "($12),Y" )
			writeins( mnemonic, "(bak08),y" )
			writeins( mnemonic, "(fwd08),Y" )
			inscnt = 3

		# zero page test relative
		case "zptr" if _OS.cpu in cpuR65C02plus:
			writeins( mnemonic, "$12, :+" )
			writeins( mnemonic, "bak08, -" )
			writeins( mnemonic, "fwd08, +" )
			inscnt = 3

		# zero page x-indexed indirect
		case "zpx":		# direct page x-indexed
			writeins( mnemonic, "$12,X", )
			writeins( mnemonic, "bak08,x" )
			checkab( mnemonic, "abx", "fwd08,X" )
			inscnt = 3

		# zero page x-indexed indirect
		case "zpxi":
			writeins( mnemonic, "($12,X)" )
			writeins( mnemonic, "(bak08,x)" )
			checkab( mnemonic, "abzi", "(fwd08,X)" )
			inscnt = 3

		# zero page y-indexed
		case "zpy":
			writeins( mnemonic, "$12,Y" )
			writeins( mnemonic, "bak08,y" )
			checkab( mnemonic, "aby", "fwd08,Y" )
			inscnt = 3

		case _:
			cant_happen( f"write_ins f{CPU.name}", mnemonic, mode )
			inscnt = 0

	good( inscnt ) if goodins else bad( inscnt )

	writenl()

# -------------------------------

def get_force(mode, forceto):
	'''force an address mode (known to be possible)'''
	ndx = { 'absolute':0, 'zeropage':1, 'long':2 }[ forceto ]
	return CPU._forcible[ mode ][ ndx ]

def accept_force(mnemonic, mode, forceto):
	'''check if an address mode can be forced to another'''

	# is the mode even forcible ?
	if not mode in CPU._forcible:
		return False

	# a mode can always be forced to itself
	match forceto:
		case 'absolute' if mode.startswith('ab'):
			return True
		case 'zeropage' if mode.startswith('zp'):
			return True
		case 'long' if mode.startswith(('lab', 'lzp')):
			return True

	# in theory relative address modes can't be forced to anything else
	# - but the CPU handler cannot tell the difference between relative and
	# absolute expressions during the first pass
	# these modes will be passed along as absolute (and so make it through the first pass)
	if mode in ["pcr", "lpcr"]:
		mode = "ab"

	# forcing results in a legal mode ?
	return get_force(mode, forceto) in _OS.modes[ mnemonic ]

def write_forced(mnemonic, startmode, forceto, doecho=False):
	'''write forced mode instruction'''

	def writeforced(mnemonic, expr=None):
		writetab( f".assume addr:{forceto}" )
		writeins( mnemonic, expr )

	def write_bit08(mnemonic, pfx, sfx):
		'''write 8-bit addresses'''
		writeforced( mnemonic, f"{pfx}$32{sfx}" )
		writeforced( mnemonic, f"{pfx}bak08{sfx}" )
		writeforced( mnemonic, f"{pfx}fwd08{sfx}" )
		return 3

	def write_bit16(mnemonic, pfx, sfx):
		'''write 16-bit addresses'''
		writeforced( mnemonic, f"{pfx}$4365{sfx}" )
		writeforced( mnemonic, f"{pfx}fwd16{sfx}" )
		writeforced( mnemonic, f"{pfx}bak16{sfx}" )
		return 3

	def write_bit24(mnemonic, pfx, sfx):
		'''write 24-bit addresses'''
		writeforced( mnemonic, f"{pfx}$547698{sfx}" )
		writeforced( mnemonic, f"{pfx}bak24{sfx}" )
		writeforced( mnemonic, f"{pfx}fwd24{sfx}" )
		return 3

	def write_accaddr(mnemonic):
		# accumulator addresses
		writeforced( mnemonic, "A" )
		writeforced( mnemonic, "a" )
		return 2

	def write_impaddr(mnemonic):
		# implied address
		writeforced( mnemonic, None )
		return 1

	def write_pcraddr(mnemonic):
		writeforced( mnemonic, ":+" )
		writeforced( mnemonic, "-" )
		writeforced( mnemonic, "+" )
		writeforced( mnemonic, ":-" )
		return 4

	def write_abxfr(mnemonic):
		writeforced( mnemonic, "bak08, bak16, $1234" )
		writeforced( mnemonic, "bak08, $5678, fwd08" )
		writeforced( mnemonic, "$9ABC, bak16, fwd16" )
		return 3

	def write_blockmove(mnemonic):
		writeforced( mnemonic, "#bak08, #fwd08" )
		writeforced( mnemonic, "bak24, fwd24" )
		writeforced( mnemonic, "#bak08, fwd24" )
		return 3

	# write message to error file as well as source file ?
	leader = ".echo" if doecho else ";"

	# can this mode be forced ?
	if accept_force(mnemonic, startmode, forceto):
		endmode = get_force( startmode, forceto )
		writetab( f"{leader} {passtest(mnemonic, startmode, endmode)}" )
		canforce = True
		mnemonic = mnemonic.upper()
	# nope, for sure can't be forced
	else:
		writetab( f"{leader} {failtest(mnemonic, startmode, forceto)}" )
		canforce = False
		mnemonic = mnemonic.lower()

	match startmode:

		case "ab":
			inscnt = write_bit16( mnemonic, "", "" )

		case "abi":
			inscnt = write_bit16( mnemonic, "(", ")" )

		case "abimm":
			inscnt = write_bit16( mnemonic, "#$12, ", "" )

		case "abimx":
			inscnt = write_bit16( mnemonic, "#bak08, ", ",X" )

		case "abx":
			inscnt = write_bit16( mnemonic, "", ",X" )

		case "abxfr":
			inscnt = write_abxfr( mnemonic )

		case "abxi":
			inscnt = write_bit16( mnemonic, "(", ",X)" )

		case "aby":
			inscnt = write_bit16( mnemonic, "", ",Y" )

		case "acc":
			inscnt = write_accaddr( mnemonic )

		case "bmv":
			inscnt = write_blockmove( mnemonic )

		case "imm":
			inscnt = write_bit08( mnemonic, "#", "" )

		case "imp":
			inscnt = write_impaddr( mnemonic )

		case "lab":
			inscnt = write_bit24( mnemonic, "", "" )

		case "labi":
			inscnt = write_bit16( mnemonic, "[", "]" )

		case "labx":
			inscnt = write_bit24( mnemonic, "", ",x" )

		case "lpcr":
			inscnt = write_pcraddr( mnemonic )

		case "lzpi":
			inscnt = write_bit08( mnemonic, "[", "]" )

		case "lzpiy":
			inscnt = write_bit08( mnemonic, "[", "],Y" )

		case "pcr":
			inscnt = write_pcraddr( mnemonic )

		case "sr":
			inscnt = write_bit08( mnemonic, "", ",S" )

		case "sriy":
			inscnt = write_bit08( mnemonic, "(", ",S),Y" )

		case "zp":
			inscnt = write_bit08( mnemonic, "", "" )

		case "zpi":
			inscnt = write_bit08( mnemonic, "(", ")" )

		case "zpimm":
			inscnt = write_bit08( mnemonic, "#$82, ", "" )

		case "zpimx":
			inscnt = write_bit08( mnemonic, "#fwd08, ", ",X" )

		case "zpiy":
			inscnt = write_bit08( mnemonic, "(", "),y" )

		case "zptr":
			inscnt = write_bit08( mnemonic, "", ", :+" )

		case "zpx":
			inscnt = write_bit08( mnemonic, "", ",x" )

		case "zpxi":
			inscnt = write_bit08( mnemonic, "(", ",x)" )

		case "zpy":
			inscnt = write_bit08( mnemonic, "", ",y" )

		case _:
			cant_happen( "write_forced", mnemonic, startmode )
			inscnt = 0

	good( inscnt ) if canforce else bad( inscnt )

	writenl()

# -------------------------------
# tests should pass without error
# -------------------------------

def write_testa(cpu):
	'''write test of all legal instructions with all legal modes'''
	if openout( f"{cpu}" ):
		write_ok_header( cpu, '', f'{cpu} Instruction Set' )

		for mnemonic in _OS.allmnemonics:
			write_div()
			legalmodes = _OS.modes[ mnemonic ]
			write( f":\t; backward ref for {mnemonic}\n" )
			for addrmode in legalmodes:
				write_ins( mnemonic, addrmode, legalmodes )
			write( f"\n:\t; forward ref for {mnemonic}" )

		write_trailer()
		closeout()

def write_testb(cpu):
	'''write test of all group rep instructions with all legal modes'''
	if openout( f"{cpu}b" ):
		write_ok_header( cpu, "b", f"{cpu} Group Rep Instructions" )

		for mnemonic in _OS.grouprep:
			write_div()
			write_members( mnemonic )
			legalmodes = _OS.modes[ mnemonic ]
			write( f":\t; backward ref for {mnemonic}\n" )
			for addrmode in legalmodes:
				write_ins( mnemonic, addrmode, legalmodes )
			write( f"\n:\t; forward ref for {mnemonic}" )

		write_trailer()
		closeout()

def write_testd(cpu):
	'''write test of all legal forced address modes'''
	# - forcing removes all operand size restrictions
	if openout( f"{cpu}d" ):
		write_ok_header( cpu, "d", f"{cpu} Forced Address Modes" )

		for mnemonic in _OS.grouprep:
			write_div()
			write_members( mnemonic )
			legalmodes = _OS.modes[ mnemonic ]
			write( f":\t; backward ref for {mnemonic}\n" )
			for mode in legalmodes:
				canforce = False
				if accept_force(mnemonic, mode, "absolute"):
					write_forced( mnemonic, mode, "absolute", False )
					canforce = True
				if accept_force(mnemonic, mode, "zeropage"):
					write_forced( mnemonic, mode, "zeropage", False )
					canforce = True
				if accept_force(mnemonic, mode, "long"):
					write_forced( mnemonic, mode, "long", False )
					canforce = True
				if not canforce:
					writecomment( f"'{mode}' cannot be forced\n" )
			write( f"\n:\t; forward ref for {mnemonic}" )

		write_trailer()
		closeout()

# -------------------------------
# tests should somehow fail
# -------------------------------

def write_teste(cpu):
	'''write test of all instructions with all modes'''
	if openout( f"{cpu}e" ):
		write_fail_header( cpu, "e", f"{cpu} All Instructions, All Address Modes" )

		for mnemonic in _OS.allmnemonics:
			write_div()
			write( f":\t; backward ref for {mnemonic}\n" )
			legalmodes = _OS.modes[ mnemonic ]
			for addrmode in _OS.allmodes:
				write_ins( mnemonic, addrmode, legalmodes, True )
			write( f"\n:\t; forward ref for {mnemonic}" )

		write_trailer()
		closeout()

def write_testf(cpu):
	'''write test of all group rep instructions with all modes'''
	if openout( f"{cpu}f" ):
		write_fail_header( cpu, "f", f"{cpu} Group Rep Instructions, Caught First Pass" )

		for mnemonic in _OS.grouprep:
			write_div()
			write( f":\t; backward ref for {mnemonic}\n" )
			write_members( mnemonic )
			legalmodes = _OS.modes[ mnemonic ]
			for addrmode in _OS.allmodes:
				write_ins( mnemonic, addrmode, legalmodes, True )
			write( f"\n:\t; forward ref for {mnemonic}" )

		write_trailer()
		closeout()

def write_testg(cpu):
	'''write test of group rep instructions that get through first pass'''
	# we know expressions have no idea how they are going to be used
	# - so whether an expression is relative or absolute depends on the mnemonic
	# - the best we could do while evaluating is tell whether an anonymous label is used
	# - which would suggest relative, but even then we could not be certain of that
	accepted = _OS.accept1.copy()

	if openout( f"{cpu}g" ):
		write_fail_header( cpu, "g", f"{cpu} Group Rep Instructions, Caught Second Pass" )

		_OS.passnum = 2
		for mnemonic in accepted:
			write_div()
			write( f":\t; backward ref for {mnemonic}\n" )
			write_members( mnemonic )
			legalmodes = _OS.modes[ mnemonic ]
			# passed the first pass as another mode ?
			for addrmode in accepted[mnemonic]:
				write_ins( mnemonic, addrmode, legalmodes, True )
			write( f"\n:\t; forward ref for {mnemonic}" )

		write_trailer()
		closeout()

def write_testc(cpu):
	'''write test of group rep instructions that get through second pass'''
	# we want to know HOW these expressions got through
	# - especially whether they always get through or just happen to because operands are ok
	accepted = _OS.accept2.copy()

	if openout( f"{cpu}c" ):
		write_fail_header( cpu, "c", f"{cpu} Group Rep Instructions, Not Caught Second Pass" )

		_OS.passnum = 3
		for mnemonic in accepted:
			write_div()
			write( f":\t; backward ref for {mnemonic}\n" )
			write_members( mnemonic )
			legalmodes = _OS.modes[ mnemonic ]
			# passed the second pass as another mode ?
			for addrmode in accepted[mnemonic]:
				write_ins( mnemonic, addrmode, legalmodes, False )
			write( f"\n:\t; forward ref for {mnemonic}" )

		write_trailer()
		closeout()

def write_testh(cpu):
	'''write test of group rep instructions in illegal forced modes'''
	
	def showforce(mode, forcetype):
		if mode in CPU._forcible:
			return f"{mode} cannot be forced to {get_force(mode, forcetype)}"
		else:
			return f"{forcetype} is not forcible"

	if openout( f"{cpu}h" ):
		write_fail_header( cpu, "h", f"{cpu} Group Rep Instructions, Illegal Forced Modes" )

		for mnemonic in _OS.grouprep:
			write_div()
			write_members( mnemonic )
			for mode in _OS.allmodes:
				writecomment( f"checking {mnemonic} {mode}\n")
				if not accept_force(mnemonic, mode, "absolute"):
					writecomment( f"{showforce(mode, 'absolute')}\n")
					write_forced( mnemonic, mode, "absolute", True )
				if not accept_force(mnemonic, mode, "zeropage" ):
					writecomment( f"{showforce(mode, 'zeropage')}\n")
					write_forced( mnemonic, mode, "zeropage", True )
				if not accept_force(mnemonic, mode, "long" ):
					writecomment( f"{showforce(mode, 'long')}\n")
					write_forced( mnemonic, mode, "long", True )
					
			write_div()

		write_trailer()
		closeout()

# -------------------------------

def find_group_reps():
	'''determine which mnemonics have the same address modes'''
	seen_key = {}
	for mnemonic in _OS.allmnemonics:
		# use the addr modes of each entry as a key
		key = str( _OS.modes[mnemonic] )
		# is this mnemonic a member of any addr group we know ?
		if key in seen_key:
			_OS.groupmem[ seen_key[key] ].append( mnemonic )
		# we haven't seen this key, so the mnemonic becomes the rep
		else:
			seen_key[ key ] = mnemonic
			_OS.grouprep[ mnemonic ] = True
			_OS.groupmem[ mnemonic ] = []

def setcputest(this):
	''' setup specific cpu for testing '''

	def addins(this):
		'''add opcodes to current instruction set'''
		for mnemonic, addrmodes in this.items():
			if mnemonic not in _OS.modes:
				# address modes of each mnemonic
				_OS.modes[ mnemonic ] = []
				_OS.allmnemonics.append( mnemonic )
			for addrmode, opcode in addrmodes:
				# for testing legal address modes
				_OS.modes[ mnemonic ].append( addrmode )
				# for testing illegal address modes
				if not addrmode in _OS.allmodes:
					_OS.allmodes.append( addrmode )

	# all processors get the base instruction set
	addins( CPU._ins6502 )
	# other processors add instructions
	match this:
		case '65C02':
			addins( CPU._ins65C02 )
		case 'R65C02':
			addins( CPU._ins65C02 )
			addins( CPU._insR65C02 )
		case 'W65C02S':
			addins( CPU._ins65C02 )
			addins( CPU._insR65C02 )
			addins( CPU._insW65C02S )
		case 'W65C816S':
			CPU.cpu16bit = True
			addins( CPU._ins65C02 )
			addins( CPU._insW65C02S )
			addins( CPU._insW65C816S )
		case 'HUC6280':
			addins( CPU._ins65C02 )
			addins( CPU._insR65C02 )
			addins( CPU._insHUC6280 )

	# put these in alphabetic order
	_OS.allmnemonics.sort()
	_OS.allmodes.sort()
	for mnemonic in _OS.allmnemonics:
		_OS.modes[mnemonic].sort()

	return True

def gentest(name):
	'''generate address mode test programs'''

	# a processor we know ?
	if not CPU.iscpu(name):
		error( "Unknown cpu", name )
		return

	_OS.cpu = CPU._normalize( name )

	# setup processor
	CPU.setcpu( _OS.cpu )
	setcputest( _OS.cpu )

	find_group_reps()

	# write all legal mnemonics in all legal modes test
	write_testa( _OS.cpu )

	# write all group reps in all legal modes test
	write_testb( _OS.cpu )

	# write legal forced mode test
	write_testd( _OS.cpu )

	# write all legal mnemonics in all modes test
	write_teste( _OS.cpu )

	# write group rep mnemonics in all modes test
	write_testf( _OS.cpu )

	# write group rep mnemonics that get through first pass
	write_testg( _OS.cpu )

	# write group rep menmonics that get through second pass
	write_testc( _OS.cpu )

	# write illegal forced address modes
	write_testh( _OS.cpu )

	closeout()

if __name__ == '__main__':
	sys.exit( gentest(sys.argv[1]) )
