# Address Mode Test Generator for HXA68

# by Anton Treuenfels
# for Python 3.11.4

# first created: 03/09/24
# last revision: 06/15/24

# --------------------------

# the genesis of this program was the realization that doing this by hand
# was not only tedious but also prone to overlooking all kinds of legal
# and illegal combinations

# what this program does:

# imports the cpu handler to get access to the cpus and opcodes it knows
# and how to handle them

# generates several tests to check how legal, illegal and forced mode
# instruction are reacted to, alone and in address mode groups
# (because the latter are shorter and easier to understand)


# writes the expected pass and error counts of all tests at each test end
# - errors need to be manually copied to the "Error(s):" line near the start
# of each file, where the automated check program expects to find them.

# an earlier program, FORCE.AWK, was a less ambitious version of this

# --------------------------

import os
import re
import sys
from time import asctime
# other HXA modules
import hxa # mainly to make sure all the other HXA modules are initialized
import cpu_hxa68 as CPU

def error(text0, text1):
	print( f"Error: {text0}: {text1}\n" )

# --------------------------

class OSvariables(object):

	def __init__(self):

		self.testdir = 'test68'			# test directory

		self.currfile = None			# current file being processed

		self.outobj = None				# output file object

		self.inrel = False				# a relative instruction (usually one of several in a row)

		self.allmnemonics = []			# all mnemonics of spu
		self.modes = {}					# adress modes associated with individual mnemonics
		self.allmodes = []				# all address modes of cpu

		self.grouprep = {}				# "representative" (first) mnemonic of each group
		self.groupmem = {}				# mnemonics sharing this address mode

		self.goodcount = 0				# number of instructions that pass (some by accident)
		self.badcount = 0				# number of instruction that fail (on purpose)

# instantiate
_OS = OSvariables()

# -----------------------------

def _open(fname, mode):
	'''open a file for writing'''
	# fname is assumed to be a full pathname starting from device root
	try:
		# use OS default encoding
		fobj = open( fname, "wt" )
	except Exception:
		error( 'File not open', fname )
	else:
		_OS.currfile = fname
		return fobj

	# no file opened
	return None

def _normalizef(name):
	'''normalize file name'''
	# make sure file is in test directory
	fname = f'{_OS.testdir}\\test{name}.a'
	# normalize case, slashes and path 
	return os.path.normpath( os.path.normcase(fname) ).upper()

# -----------------------------

def closeout():
	'''close output file'''
	if _OS.outobj is not None:
		_OS.outobj.close()
		_OS.outobj = None

def openout(name):
	'''try to open a file for writing'''
	# since we only need one output file at at time,
	# an open file here is a mistake (we silently fix it)
	closeout()

	# open ?
	_OS.outobj = _open( _normalizef(name), "wt" )

	return True if _OS.outobj is not None else False

# -------------------------------

def write(this):
	'''write a line to text output file'''
	_OS.outobj.write( f'{this}\n' )

def writetab(this):
	'''write a tabbed line'''
	write( f"\t\t{this}" )

def writecomment(this):
	'''write a comment line'''
	write( f"; {this}" )

def writenl():
	'''write a newline'''
	write( '' )

def writesepnl(this, tabbed=False):
	'''write comment separated by newlines'''
	writenl()
	if tabbed:
		writetab( f"; {this}" )
	else:
		writecomment( this )
	writenl()

def write_div():
	'''write a divider line'''
	writesepnl( "-------------------------------" )

def write_gen():
	'''write test generator name'''
	writesepnl( f"generated by MODE68.PY - {asctime()}" )

# -------------------------------

def write_commonheader(cpu):
	'''write header part common to both ok and error files'''
	write_div()
	writetab( ".listfile" )
	writetab( ".errfile" )
	writenl()
	writetab( ".maxerr\t10000\t\t; increase default count" )
	write_div()
	writetab( f".cpu\t{cpu}" )
	writetab( ".org\t$1000" )
	write_div()
	writecomment( "backward reference" )
	writenl()
	write( "bak08\t.equ\t$12" )
	write( "bak16\t.equ\t$1234" )
	write( "bak24\t.equ\t$456789" )
	write( "bak32\t.equ\t$89ABCDEF" )

	_OS.goodcount = _OS.badcount = 0

def write_ok_header(cpu, testid, desc):
	'''write okay testfile header'''
	writecomment( f"Hobby Cross-Assembler {CPU.name()} Test {cpu}{testid.lower()}" )
	writecomment( f"{cpu}\\Instruction Set" )
	writecomment( f"ok: {desc}" )
	write_gen()
	writecomment( "no errors to detect" )
	write_commonheader(cpu )

def write_fail_header(cpu, testid, desc):
	'''write fail testfile header'''
	writecomment( f"Hobby Cross-Assembler {CPU.name()} Error Test {cpu}{testid.lower()}" )
	writecomment( f"{cpu}\\Instruction Set" )
	writecomment( f"error: {desc}" )
	write_gen()
	writenl()
	writecomment( "warning(s):\n" )
	writecomment( "errors(s):\n" )
	writecomment( "fatal:" )
	write_commonheader( cpu )
 
def write_trailer():
	'''write test file trailer'''
	write_div()
	writecomment( "forward reference" )
	writenl()
	write( "fwd32\t.equ\t$89ABCDEF" )
	write( "fwd24\t.equ\t$456789" )
	write( "fwd16\t.equ\t$1234" )
	write( "fwd08\t.equ\t$12" )
	write_div()
	writetab( ".end" )
	write_div()
	writecomment( f"{_OS.goodcount} pass" )
	writecomment( f"{_OS.badcount} fail" )

# -------------------------------

def write_members(mnemonic):
	'''write mnemonics which share addr mode of 'mnemonic'''
	writetab( f"; check {mnemonic}" )
	writetab( f"; {len(_OS.groupmem[mnemonic])+1} mnemonics with modes {_OS.modes[mnemonic]}" )
	for m in _OS.groupmem[mnemonic]:
		writetab( f"; {m}" )
	writenl()

# -------------------------------

def good(count):
	_OS.goodcount += count

def bad(count):
	_OS.badcount += count

# -------------------------------

def writeins(ins, expr=None, mode=None):
	while len(ins) < 4:
		ins += " "

	if expr is None:
		if mode is None:
			writetab( f"{ins}" )
		else:
			writetab( f"{ins}\t\t\t; {mode}" )
	elif mode is None:
		writetab( f"{ins}\t{expr}" )
	else:
		writetab( f"{ins}\t{expr}\t; {mode}" )

# -------------------------------

def write_ins(mnemonic, mode, addrmodes):

	# legal modes in uppercase, illegal in lowercase
	# - but sometimes an illegal mode can be mistaken for another (legal) one
	mnemonic = mnemonic.upper() if mode in addrmodes else mnemonic.lower()

	# more verbose than necessary
	# - but should be fairly easy to follow

	match mode:
		case "acc":
			if "acc" in addrmodes:
				writeins( mnemonic, None, mode  )
				good( 1 )
			elif "inh" in addrmodes:
				writeins( mnemonic, None, "(acc -> inh)" )
				good( 1 )
			else:
				writeins( mnemonic, None, mode  )
				bad( 1 )

		case "accx":
			writeins( mnemonic, "A\t", mode )
			writeins( mnemonic, "B" )
			good(2) if "accx" in addrmodes else bad(2)

		case "dir":
			if "rel" in addrmodes:
				writeins( mnemonic, "$32\t", "(dir -> rel)" )
				writeins( mnemonic, "$00EF" )
				writeins( mnemonic, "bak08" )
				good( 3 )
			elif "ext" in addrmodes and not "dir" in addrmodes:
				writeins( mnemonic, "$32\t", "(dir -> ext)" )
				writeins( mnemonic, "$00EF" )
				writeins( mnemonic, "bak08" )
				good( 3 )
			else:
				writeins( mnemonic, "$32\t", mode )
				writeins( mnemonic, "$00EF" )
				writeins( mnemonic, "bak08" )
				good(3) if "dir" in addrmodes else bad(3)

		case "dual":
			if mnemonic != "STA":
				for reg in ["A", "B"]:
					writeins( mnemonic, f"{reg} $32", "dual dir" )
					writeins( mnemonic, f"{reg} bak08" )
					writenl()
					writeins( mnemonic, f"{reg} $D101", "dual ext" )
					writeins( mnemonic, f"{reg} bak16" )
					writeins( mnemonic, f"{reg} fwd16" )
					writenl()
					writeins( mnemonic, f"{reg} #$80", "dual imm" )
					writeins( mnemonic, f"{reg} #bak08" )
					writenl()
					writeins( mnemonic, f"{reg} X\t", "dual ndx" )
					writeins( mnemonic, f"{reg} $89,X" )
					writeins( mnemonic, f"{reg} $00AB, X" )
					writeins( mnemonic, f"{reg} bak08, X" )
					writeins( mnemonic, f"{reg} fwd08,X" )
					good(12) if "dual" in addrmodes else bad(12)
					if reg == "A":
						writenl()

			else:	# just for "STA", which doesn't allow "imm" mode
				for reg in ["A", "B"]:
					writeins( mnemonic, f"{reg} $32", "dual dir" )
					writeins( mnemonic, f"{reg} bak08" )
					writenl()
					writeins( mnemonic, f"{reg} $D101", "dual ext" )
					writeins( mnemonic, f"{reg} bak16" )
					writeins( mnemonic, f"{reg} fwd16" )
					writenl()
					writeins( mnemonic, f"{reg} X\t", "dual ndx" )
					writeins( mnemonic, f"{reg} $89,X" )
					writeins( mnemonic, f"{reg} $00AB, X" )
					writeins( mnemonic, f"{reg} bak08, X" )
					writeins( mnemonic, f"{reg} fwd08,X" )
					good(10) if "dual" in addrmodes else bad(10)
					if reg == "A":
						writenl()

		case "ext":
			if "dir" in addrmodes:
				writeins( mnemonic, "$0021", "(ext -> dir)" )
				writeins( mnemonic, "$D101", mode )
				writeins( mnemonic, "bak08", "(ext -> dir)" )
				writeins( mnemonic, "bak16", mode )
				writeins( mnemonic, "fwd16" )
				writeins( mnemonic, "fwd08" )
				good( 6 )
			elif "rel" in addrmodes:
				writeins( mnemonic, "$0021", "(ext -> rel)" )
				writeins( mnemonic, "$D101" )
				writeins( mnemonic, "bak08" )
				writeins( mnemonic, "bak16" )
				writeins( mnemonic, "fwd16" )
				writeins( mnemonic, "fwd08" )
				good( 6 )
			else:
				writeins( mnemonic, "$0021", mode )
				writeins( mnemonic, "$D101" )
				writeins( mnemonic, "bak08" )
				writeins( mnemonic, "bak16" )
				writeins( mnemonic, "fwd16" )
				writeins( mnemonic, "fwd08" )
				good(6) if "ext" in addrmodes else bad(6)

		case "imm":
			writeins( mnemonic, "#$80", mode )
			writeins( mnemonic, "#bak08" )
			writeins( mnemonic, "#fwd08" )
			good(3) if "imm" in addrmodes else bad(3)

		case "inh":
			if "inh" in addrmodes:
				writeins( mnemonic, None, mode )
				good( 1 )
			elif "acc" in addrmodes:
				writeins( mnemonic, None, "(inh -> acc)" )
				good( 1 )
			else:
				writeins( mnemonic, None, mode )
				bad( 1 )

		case "ndx":
			writeins( mnemonic, "X\t", mode )
			writeins( mnemonic, "$89,X" )
			writeins( mnemonic, "$00AB, X" )
			writeins( mnemonic, "bak08,X" )
			writeins( mnemonic, "fwd08, X" )
			good(5) if "ndx" in addrmodes else bad(5)

		case "rel":
			write( f":\t; backward ref for {mnemonic}\n" )
			if "rel" in addrmodes:
				# these can get promoted by mistake
				writeins( mnemonic, ":+", mode )
				writeins( mnemonic, ":-" )
				good( 2 )
			elif "dir" in addrmodes or "ext" in addrmodes:
				# these can get promoted by mistake (though guaranteed out of range)
				writeins( mnemonic, "fwd24", "(rel -> dir/ext)" )
				writeins( mnemonic, "bak24" )
				good( 2 )
			else:
				writeins( mnemonic, ":+", mode )
				writeins( mnemonic, ":-" )
				bad( 2 )
			write( f"\n:\t; forward ref for {mnemonic}" )

		case _:
			print( f"Can't happen: {mnemonic}" )

	writenl()

def write_forced(mnemonic, frommode, tomode, addrmodes):
	'''write forced mode instruction'''

	def write_fdir(ins, expr=None, tag=None):
		'''write forced direct mode instruction'''
		writetab( ".assume addr:direct" )
		writeins( mnemonic, expr, tag )

	def write_fext(ins, expr=None, tag=None):
		'''write forced direct mode instruction'''
		writetab( ".assume addr:extended" )
		writeins( ins, expr, tag )

	# legal modes in uppercase, illegal in lowercase
	# - but sometimes an illegal mode can be mistaken for another (legal) one
	# dir->dir, dir->ext
	# ext->dir, ext->ext
	# dual->dir, dual->ext

	# source mode can be one of three, destination mode one of two
	#	canforce = frommode in ["dir", "dual", "ext"] and tomode in ["dir", "ext"]

	if "dual" in addrmodes:
		canforce = frommode in ["dual"]
	else:
		canforce = frommode in ["dir", "ext"] and tomode in ["dir", "ext"] and tomode in addrmodes

	mnemonic = mnemonic.upper() if canforce else mnemonic.lower()

	tag = f"force ({frommode} -> {tomode})"

	match frommode:
		case "dir" | "ext":
			match tomode:
				case "dir":
					write_fdir( mnemonic, "$32\t", tag )
					write_fdir( mnemonic, "$00EF" )
					write_fdir( mnemonic, "$abcd" )
					write_fdir( mnemonic, "bak08" )
					write_fdir( mnemonic, "bak24" )
					write_fdir( mnemonic, "fwd32" )
					write_fdir( mnemonic, "fwd16" )
					good( 7 ) if canforce else bad( 7 )
				case "ext":
					write_fext( mnemonic, "$32\t", tag )
					write_fext( mnemonic, "$00EF" )
					write_fext( mnemonic, "$abcd" )
					write_fext( mnemonic, "bak16" )
					write_fext( mnemonic, "bak32" )
					write_fext( mnemonic, "fwd24" )
					write_fext( mnemonic, "fwd08" )
					good( 7 ) if canforce else bad( 7 )

		case "dual":
			match tomode:
				case "dir":
					for reg in ["A", "B"]:
						write_fdir( mnemonic, f"{reg} $32", tag )
						write_fdir( mnemonic, f"{reg} bak08" )
						write_fdir( mnemonic, f"{reg} $D101" )
						write_fdir( mnemonic, f"{reg} bak16" )
						write_fdir( mnemonic, f"{reg} fwd16" )
						good( 5 ) if canforce else bad( 5 )
						if reg == "A":
							writenl()
				case "ext":
					for reg in ["A", "B"]:
						write_fext( mnemonic, f"{reg} $32", tag )
						write_fext( mnemonic, f"{reg} bak08" )
						write_fext( mnemonic, f"{reg} $D101" )
						write_fext( mnemonic, f"{reg} bak16" )
						write_fext( mnemonic, f"{reg} fwd16" )
						good( 5 ) if canforce else bad( 5 )
						if reg == "A":
							writenl()

		case "imm":
			match tomode:
				case "dir":
					write_fdir( mnemonic, "#$80", tag )
					write_fdir( mnemonic, "#bak08" )
					write_fdir( mnemonic, "#fwd08" )
					bad( 3 )
				case "ext":
					write_fext( mnemonic, "#$80", tag )
					write_fext( mnemonic, "#bak08" )
					write_fext( mnemonic, "#fwd08" )
					bad( 3 )

		case "acc" | "inh":
			match tomode:
				case "dir":
					write_fdir( mnemonic, None, tag )
					bad( 1 )
				case "ext":
					write_fext( mnemonic, None, tag )
					bad( 1 )

		case "accx":
			match tomode:
				case "dir":
					write_fdir( mnemonic, "A\t", tag )
					write_fdir( mnemonic, "B" )
					bad( 2 )
				case "ext":
					write_fext( mnemonic, "A\t", tag )
					write_fext( mnemonic, "B" )
					bad( 2 )

		case "ndx":
			match tomode:
				case "dir":
					write_fdir( mnemonic, "X\t", tag )
					write_fdir( mnemonic, "$89,X" )
					write_fdir( mnemonic, "$00AB, X" )
					write_fdir( mnemonic, "bak08,X" )
					write_fdir( mnemonic, "fwd08, X" )
					bad( 5 )
				case "ext":
					write_fext( mnemonic, "X\t", tag )
					write_fext( mnemonic, "$89,X" )
					write_fext( mnemonic, "$00AB, X" )
					write_fext( mnemonic, "bak08,X" )
					write_fext( mnemonic, "fwd08, X" )
					bad( 5 )

		case "rel":
			write( f":\t; backward ref for {mnemonic}\n" )
			match tomode:
				case "dir":
					if "dir" in addrmodes or "ext" in addrmodes:
						write_fdir( mnemonic, "fwd24", tag )
						write_fdir( mnemonic, "bak24" )
						bad( 2 )
					else:
						write_fdir( mnemonic, ":+", tag )
						write_fdir( mnemonic, ":-" )
						bad( 2 )
				case "ext":
					if "dir" in addrmodes or "ext" in addrmodes:
						write_fext( mnemonic, "fwd24", tag )
						write_fext( mnemonic, "bak24" )
						bad( 2 )
					else:
						write_fext( mnemonic, ":+", tag )
						write_fext( mnemonic, ":-" )
						bad( 2 )
			write( f"\n:\t; forward ref for {mnemonic}" )

		case _:
			write( f"Can't happen: {tag}" )

	writenl()

# -------------------------------
# tests should pass without error
# -------------------------------

def write_testa(cpu):
	'''write test of all legal instructions with all legal modes'''
	if openout( f"{cpu}" ):
		write_ok_header( cpu, '', f'{cpu} Instruction Set' )

		for mnemonic in _OS.allmnemonics:
			write_div()
			legalmodes = _OS.modes[ mnemonic ]
			for addrmode in legalmodes:
				write_ins( mnemonic, addrmode, legalmodes )

		write_trailer()
		closeout()

def write_testb(cpu):
	'''write test of all group rep instructions with all legal modes'''
	if openout( f"{cpu}b" ):
		write_ok_header( cpu, "b", f"{cpu} Group Rep Instructions" )

		for mnemonic in _OS.grouprep:
			write_div()
			write_members( mnemonic )
			legalmodes = _OS.modes[ mnemonic ]
			for addrmode in legalmodes:
				write_ins( mnemonic, addrmode, legalmodes )

		write_trailer()
		closeout()

def write_testc(cpu):
	'''write test of all legal forced address modes'''
	# - "dir" and "ext" can be forced to themselves or to the other
	# - forcing removes all operand size restrictions
	if openout( f"{cpu}c" ):
		write_ok_header( cpu, "c", f"{cpu} Forced Address Modes" )

		for mnemonic in _OS.grouprep:
			legalmodes = _OS.modes[ mnemonic ]
			if "dir" in legalmodes or "ext" in legalmodes or "dual" in legalmodes:
				write_div()
				write_members( mnemonic )
				if "dual" in legalmodes:
					write_forced( mnemonic, "dual", "dir", ["dual", "dir", "ext"] )
					write_forced( mnemonic, "dual", "ext", ["dual", "dir", "ext"] )
				if "dir" in legalmodes:
					write_forced( mnemonic, "dir", "dir", legalmodes )
					if "ext" in legalmodes:
						write_forced( mnemonic, "dir", "ext", legalmodes )
				if "ext" in legalmodes:
					if "dir" in legalmodes:
						write_forced( mnemonic, "ext", "dir", legalmodes )
					write_forced( mnemonic, "ext", "ext", legalmodes )

		write_trailer()
		closeout()

# -------------------------------
# tests should somehow fail
# -------------------------------

def write_teste(cpu):
	'''write test of all instructions with all modes'''
	if openout( f"{cpu}e" ):
		write_fail_header( cpu, "e", "All instructions, all address modes" )

		for mnemonic in _OS.allmnemonics:
			write_div()
			legalmodes = _OS.modes[ mnemonic ]
			for addrmode in _OS.allmodes:
				write_ins( mnemonic, addrmode, legalmodes )

		write_trailer()
		closeout()

def write_testf(cpu):
	'''write test of all group rep instructions with all modes'''
	if openout( f"{cpu}f" ):
		write_fail_header( cpu, "f", "Group rep instructions, all address modes" )

		for mnemonic in _OS.grouprep:
			write_div()
			write_members( mnemonic )
			legalmodes = _OS.modes[ mnemonic ]
			for addrmode in _OS.allmodes:
				write_ins( mnemonic, addrmode, legalmodes )

		write_trailer()
		closeout()

def write_testg(cpu):
	'''write test of group rep instructions that are our of range'''
	# - the ones we can still catch (if out of relative range) are:
	# rel -> dir/ext
	# dir/ext -> rel
	if openout( f"{cpu}g" ):
		write_fail_header( cpu, "g", "Group rep instructions, out of range values, caught second pass" )

		for mnemonic in _OS.grouprep:
			legalmodes = _OS.modes[ mnemonic]
			hasDir = "dir" in legalmodes
			hasExt = "ext" in legalmodes
			hasRel = "rel" in legalmodes
			if hasDir or hasExt or hasRel:
				write_div()
				write_members( mnemonic )
			if hasRel:
				write_ins( mnemonic, "dir", legalmodes )
				write_ins( mnemonic, "ext", legalmodes )
			if hasDir or hasExt:
				write_ins( mnemonic, "rel", legalmodes )

		write_trailer()
		closeout()

def write_testh(cpu):
	'''write test of group rep instructions in forced modes'''

	if openout( f"{cpu}h" ):
		write_fail_header( cpu, "h", "Group rep instructions, forced modes" )

		for mnemonic in _OS.grouprep:
			write_div()
			write_members( mnemonic )
			legalmodes = _OS.modes[ mnemonic]
			for forceto in ["dir", "ext"]:
				for addrmode in _OS.allmodes:
					write_forced( mnemonic, addrmode, forceto, legalmodes )
				write_div()

		write_trailer()
		closeout()

# -------------------------------

def find_group_reps():
	'''determine which mnemonics have the same address modes'''
	seen_key = {}
	for mnemonic in _OS.allmnemonics:
		# use the addr modes of each entry as a key
		key = str( _OS.modes[mnemonic] )
		# is this mnemonic a member of any addr group we know ?
		if key in seen_key:
			_OS.groupmem[ seen_key[key] ].append( mnemonic )
		# we haven't seen this key, so the mnemonic becomes the rep
		else:
			seen_key[ key ] = mnemonic
			_OS.grouprep[ mnemonic ] = True
			_OS.groupmem[ mnemonic ] = []

def setcputest(this):
	''' setup specific cpu for testing '''

	def addins(this):
		'''add opcodes to current instruction set'''
		for mnemonic, addrmodes in this.items():
			if mnemonic not in _OS.modes:
				# address modes of each mnemonic
				_OS.modes[ mnemonic ] = []
				_OS.allmnemonics.append( mnemonic )
			for addrmode, opcode in addrmodes:
				# for testing legal address modes
				_OS.modes[ mnemonic ].append( addrmode )
				# for testing illegal address modes
				if not addrmode in _OS.allmodes:
					_OS.allmodes.append( addrmode )

	# other processors add instructions
	match CPU._normalize(this):
		case '6800':
			addins( CPU._ins6800 )
		case '6801' | '6803':
			addins( CPU._ins6800 )
			addins( CPU._ins6803 )
		case _:
			UM.noway( this )

	# put these in alphabetic order
	_OS.allmnemonics.sort()
	_OS.allmodes.sort()
	for mnemonic in _OS.allmnemonics:
		_OS.modes[mnemonic].sort()

	return True

def gentest(name):
	'''generate address mode test programs'''

	# a processor we know ?
	if not CPU.iscpu(name):
		error( "Unknown cpu", name )
		return

	cpu = CPU._normalize( name )

	# setup processor
	CPU.setcpu( cpu )
	setcputest( cpu )

	find_group_reps()

	# write all legal mnemonics in all legal modes test
	write_testa( cpu )

	# write all group reps in all legal modes test
	write_testb( cpu )

	# write legal forced mode test
	write_testc( cpu )

	# write all legal mnemonics in all modes test
	write_teste( cpu )

	# write group rep mnemonics in all modes test
	write_testf( cpu )

	# write group rep mnemonics that get through first pass
	write_testg( cpu )

	# write illegal forced address modes
	write_testh( cpu )

	closeout()

if __name__ == '__main__':
	sys.exit( gentest(sys.argv[1]) )
