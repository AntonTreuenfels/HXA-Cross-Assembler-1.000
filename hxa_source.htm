<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="color-scheme" content="normal">
<title>HXA 1.000 Source Code Overview</title>
<style>
html {background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAARElEQVQYV2M8c+bMfwY0YGJiwggTAjOQFYEkQXyYIrhKZEGYJpAiuAnIxiKbiGIcunUgPtwKZGNRTIC5lqAbYArR3QIAdA85lXmjDMQAAAAASUVORK5CYII=)}
body {margin:0 auto; padding:0; max-width:82em}
h1,h2,h3,h4 {text-align:center}
h2, h3 {border:1px solid #ccc; padding: 0.5em 0}
hr {width: 45%; margin:0 auto}
table {margin-left:auto; margin-right:auto;border: 1px solid black}
table, th, tr {text-align:center}
caption {padding:10px; caption-side:bottom}
th, td {padding-left:0.5em; padding-right:0.5em}
section {display:flex; flex-direction:row; background-color:transparent; height:100vh}
a:hover {background-color:#FFF}
#toc, #content {background-color:#EEE; padding:1em; overflow:auto}
#toc {flex:1; margin-right:1em}
#toc p {text-align:center; font-weight:bold; font-size:1.2em}
#toc li {list-style-type:none; padding:.1em, 0}
#content {flex:3}
</style>
</head><body><section><div id="toc">
<p>Contents</p><hr>
<ul><li>
</li><li><a href="#L181">Scope of This Document</a>
<ul><li>
</li><li><a href="#L182">Related Resources</a>
</li></ul>
</li><li><a href="#L183">Acknowledgments</a>
</li><li><a href="#L184">A Note on the Documentation</a>
</li><li><a href="#L185">HXA Design and Modularization</a>
<ul><li>
</li><li><a href="#L186">Design Goals</a>
</li><li><a href="#L187">Current Modules</a>
<ul><li>
</li><li><a href="#L188">hxa.py</a>
</li><li><a href="#L189">hxa_usermesg.py</a>
</li><li><a href="#L18A">hxa_pseudo.py</a>
</li><li><a href="#L18B">hxa_macro.py</a>
</li><li><a href="#L18D">hxa_codegen.py</a>
</li><li><a href="#L18E">hxa_progctr.py</a>
</li><li><a href="#L18F">hxa_file.py</a>
</li><li><a href="#L190">hxa_symbol.py</a>
</li><li><a href="#L191">hxa_source.py</a>
</li><li><a href="#L192">hxa_string.py</a>
</li><li><a href="#L193">hxa_misc.py</a>
</li><li><a href="#L194">hxa_expressions.py</a>
</li></ul>
</li></ul>
</li><li><a href="#L195">Creating an HXA Variant</a>
<ul><li>
</li><li><a href="#L196">Using Macros to Implement an Instruction Set</a>
</li><li><a href="#L198">Creating a Native CPU Handler Module</a>
<ul><li>
</li><li><a href="#L1A1">Available HXA Methods</a>
</li></ul>
</li></ul>
</li><li><a href="#L1A8">CPU Handlers</a>
<ul><li>
</li><li><a href="#L1A9">HXA_T Handler</a>
</li><li><a href="#L1AA">HXA65 Handler</a>
</li></ul>
</li><li><a href="#L1AC">Future Development</a>
</li><li><a href="#L1AD">Assembler Messages</a>
</li><li><a href="#L1AE">History</a>
</li></ul>
</div><div id="content"><h2>Hobby Cross Assembler 1.000</h2>
<h3>Source Code Overview</h3>
<p>Copyright (&copy;) 2004-2023 by Anton Treuenfels</p>
<a id="L181"></a><h3>Scope of This Document</h3>
<p>This document briefly describes</p>
<ul> <li>the design and modularization of HXA</li>
 <li>how to write a cpu <a href="hxa.htm#L007">handler</a> to accept one or more sets instruction mnemonics</li>
 <li>possible future changes</li>
 <li>the HXA message table</li>
 <li>HXA release history</li>
 </ul>
<a id="L182"></a><h4>Related Resources</h4>
<h4>HXA</h4>
<ul> <li><a href="hxa.htm">User Manual</a></li>
 <li><a href="hxa_test.htm">General Tests</a></li>
 </ul>
<hr>
<h4>Programming and Design Influences</h4>
<p><b>Merlin Assemblers</b></p>
<ul> <li>Bredon, Glen</li>
 <li><em>Roger Wagner Publishing</em></li>
 <li>this series of assemblers for the 6502-family processors used in Commodore and Apple home computers remains popular with many programmers</li>
 </ul>
<p><b>Advanced C Programming for Displays</b></p>
<ul> <li>Rochkind, Marc J.</li>
 <li><em>Prentice Hall, 1988</em></li>
 <li>the ideas on program design and portability found in this book are so completely general that although it deals only with character-oriented displays, updating it to deal with bit-mapped ones(GUIs) would be almost trivial</li>
 </ul>
<p><b>The AWK Programming Language</b></p>
<ul> <li>Aho, Alfred V., Kernighan, Brian W., and Weinberger, Peter J.</li>
 <li><em>Addison-Wesley Publishing Company, 1988</em></li>
 <li>still the best introduction to AWK. It contains many fascinating examples, including a simple assembler</li>
 </ul>
<p><b>Software Tools</b></p>
<ul> <li>Kernighan, Brian W., and Plauger, P. J.</li>
 <li><em>Addison-Wesley Publishing Company, 1976</em></li>
 <li>although some of the programs presented are no longer of much relevance, every programmer should read this book for the never-outdated discussions of program design and programming style. Most of HXA's macro processing ideas originated here</li>
 </ul>
<p><b>Writing Interactive Compilers and Interpreters</b></p>
<ul> <li>Brown, P. J.</li>
 <li><em>John Wiley & Sons, 1979 (reprinted with corrections, 1980)</em></li>
 <li>a witty, utterly delightful book full of practical advice. HXA's expression evaluation ideas originated here, as well as whatever ability it has to detect and recover from errors</li>
 </ul>
<a id="L183"></a><h3>Acknowledgments</h3>
<p>I'd like to extend an appreciation to the many people who have written assemblers before me and posted their work on the Internet. Although I often could not follow the source code (it's hard to do without printing it all out!), I learned much simply by reading their documentation. Their feature lists broadened my ideas of what is possible, and their history summaries often pointed out areas that especially benefited from extensive testing.</p>
<a id="L184"></a><h3>A Note on the Documentation</h3>
<p>HXA's documentation exists in several parts:</p>
<ul> <li>the non-processor specific main user manual</li>
 <li>the implementation manual (ie., this document)</li>
 <li>the source code itself (ie., what this document describes in overview)</li>
 <li>the test and demo program suites</li>
 </ul>
<p>To use HXA requires only the first, plus perhaps one or more of the second. To fully understand how HXA works requires the last three.</p>
<p>It must be said that writing documentation is fairly tedious. However simply creating it helps to make HXA better. This happens often enough that the process might be worthwhile even if not meant for reference.</p>
<p>Sometimes when writing a description of what a pseudo opcode is supposed to do, the question comes to mind "Does it really?" This can lead to a new or revised test to determine if it is so (and if not, why not). Sometimes describing a limitation leads to the question "Does it really have to be that way?" This in turn can lead to finding a way of eliminating the limitation in question.</p>
<p>The test suite contains many more tests to determine how HXA reacts to an error than how it reacts to legal input. Part of this is simply that there are more ways to err compared to the number of ways to do things right. Part of this is because illegal input more often causes HXA to do something unexpected. Figuring out why often turns up an overlooked possibility. HXA may then be modified and the test suite expanded to account for that possibility.</p>
<a id="L185"></a><h3>HXA Design and Modularization</h3>
<a id="L186"></a><h4>Design Goals</h4>
<p>There are many desirable traits any computer program should have, some of which conflict with each other. Of the ones HXA consciously considers, they generally rank in the following descending order:</p>
<ul> <li><b>Reliability</b>  : "The error case is the normal case." - PJ Brown</li>
 <li><b>Simplicity</b>  : both of use and implementation</li>
 <li><b>Power</b>  : it should not be necessary to 'trick' HXA to accomplish reasonable programming goals</li>
 <li><b>Flexibility</b>  : ease of adaptation to different processors and environments</li>
 <li><b>Speed</b>  : first make it work, then make it faster</li>
 <li><b>Size</b>  : as small as possible, but no smaller</li>
 </ul>
<hr>
<a id="L187"></a><h4>Current Modules</h4>
<hr>
<a id="L188"></a><h4>hxa.py</h4>
<p><a href="../source/hxa.py">Source File</a></p>
<p>The top-level supervisor.</p>
<p>This module only makes calls to other modules. It cannot itself be called from another module.</p>
<p><b>Primary Responsibilities</b></p>
<ul> <li>process the command line</li>
 <li>initialize HXA</li>
 <li>pass one: dispatch each source line</li>
 <li>pass two: resolve incomplete values and expressions</li>
 <li>file output: write listing, error and object files</li>
 </ul>
<hr>
<a id="L189"></a><h4>hxa_usermesg.py</h4>
<p><a href="../source/hxa_usermesg.py">Source File</a></p>
<p>During all phases, sends HXA status and error messages to <em>stdout</em>. Warning and error messages are also saved for possible later output to an <a href="hxa.htm#L053">error file</a>.</p>
<p>This is the only module that contains the actual text of any message HXA can display. Other modules specify only an index into a table of <a href="#L1AD">assembler messages</a> when calling this module. Replacing these message texts is one way to change HXA's default messages without altering any other module.</p>
<hr>
<a id="L18A"></a><h4>hxa_pseudo.py</h4>
<p><a href="../source/hxa_pseudo.py">Source File</a></p>
<p>Process HXA's pseudo opcodes.</p>
<p>Once this module identifies a pseudo opcode, it collects and verifies any arguments and passes them to a handler. A handler can be located in any module except the top-level supervisor.</p>
<p><b>Primary Responsibilities</b></p>
<ul> <li>pass one: identification, preliminary argument handling and dispatch of all pseudo opcodes</li>
 <li>pass two: <em>not used</em></li>
 <li>file output: <em>not used</em></li>
 </ul>
<hr>
<a id="L18B"></a><h4>hxa_macro.py</h4>
<p><a href="../source/hxa_macro.py">Source File</a></p>
<p>Handle macro definition and expansion. "Macro" is here taken in a broad sense to include if, repeat and while blocks as well.</p>
<p>Macro expansion is performed by re-reading saved source lines originally read from files. HXA nests expansion blocks by stacking indices into the saved line store. The top index on the stack indicates which line to read next.</p>
<p>Whenever the index stack is non-empty HXA reads the next line from saved store (which is why a file cannot be included from inside an expansion, as the next line read would come from saved store and not the newly included file).</p>
<p><b>Primary Responsibilities</b></p>
<ul> <li>pass one: define and expand macros, ifs, repeats and whiles; handle block nesting</li>
 <li>pass two: <em>not used</em></li>
 <li>file output: <em>not used</em></li>
 </ul>
<hr>
<a id="L18C"></a>
<a id="L18D"></a><h4>hxa_codegen.py</h4>
<p><a href="../source/hxa_codegen.py">Source File</a></p>
<p>Initializes the hardware CPU, handles translating source code into object code, and creates output data.</p>
<p>This is the only non-processor specific module that deals with native byte size and orientation. Only this module and the processor-specific <a href="#L197">cpu_---.py</a> module need to know this information.</p>
<p>The fundamental data structure HXA currently uses for data generation is an array of lists indexed by source code line. Each list contains one or more sub-lists that hold any data generated by the source code. Each sub-list consists of three elements:</p>
<ul> <li>a data address : segment and offset within segment</li>
 <li>a data type : most types generate object code, but not all do</li>
 <li>a data value : a 32-bit numeric or a variable size string</li>
 </ul>
<p><b>Primary Responsibilties</b></p>
<ul> <li>initialize any other module that needs to know something about the CPU in use</li>
 <li>pass one: create the data storage array</li>
 <li>pass two: resolve and range-check numeric data values</li>
 <li>file output: create output data in forms suitable for listing and object files</li>
 </ul>
<hr>
<a id="L18E"></a><h4>hxa_progctr.py</h4>
<p><a href="../source/hxa_progctr.py">Source File</a></p>
<p>Tracks HXA's internal program counters and segment numbers.</p>
<p>Note that no other module ever directly examines or manipulates a value they get from this module. If they need to know something about it or have something done to it, they ask this module.</p>
<p><b>Primary Responsibilities</b></p>
<ul> <li>pass one: read and write the program counter; handle implicit and explicit segments</li>
 <li>pass two: convert relative values and segments to absolute</li>
 <li>file output: format program counter values; prepare segment map for a listing file</li>
 </ul>
<hr>
<a id="L18F"></a><h4>hxa_file.py</h4>
<p><a href="../source/hxa_file.py">Source File</a></p>
<p>Interacts with the native operating system to read and write files.</p>
<p><b>Primary Responsibilities</b></p>
<ul> <li>pass one: read source files; handle file inclusion; record output filenames</li>
 <li>pass two: return file names for error reporting</li>
 <li>file output: write text and binary output files</li>
 </ul>
<hr>
<a id="L190"></a><h4>hxa_symbol.py</h4>
<p><a href="../source/hxa_symbol.py">Source File</a></p>
<p>Manages the symbol table.</p>
<p><b>Primary Responsibilities</b></p>
<ul> <li>pass one: enter labels and their values into symbol table; return label values; convert auto labels to internal form</li>
 <li>pass two: make all labels absolute; return label values</li>
 <li>file output: prepare symbol table for a listing file</li>
 </ul>
<hr>
<a id="L191"></a><h4>hxa_source.py</h4>
<p><a href="../source/hxa_source.py">Source File</a></p>
<p>Read and manage source code.</p>
<p>HXA saves every source code line it encounters. This store is used for macro expansion, error-reporting and assembly listing.</p>
<p><b>Primary Responsibilities</b></p>
<ul> <li>pass one: read and save source code lines; return them as requested</li>
 <li>pass two: return source code lines (for error reporting)</li>
 <li>file output: create listing  file</li>
 </ul>
<hr>
<a id="L192"></a><h4>hxa_string.py</h4>
<p><a href="../source/hxa_string.py">Source File</a></p>
<p><b>Primary Responsibilities</b></p>
<ul> <li>pass one: handle field splitting, escape sequences and character translation</li>
 <li>pass two: convert strings to output format</li>
 <li>file output: <em>not used</em></li>
 </ul>
<hr>
<a id="L193"></a><h4>hxa_misc.py</h4>
<p><a href="../source/hxa_misc.py">Source File</a></p>
<p>Miscellaneous functions and variables used by more than one module or too small to warrant their own module.</p>
<p>Primary Responsibilities</p>
<ul> <li>pass one: pass timing, check internal maximums, range checks, handle user stack</li>
 <li>pass two: pass timing</li>
 <li>file output: prepare pass timing for a listing file</li>
 </ul>
<hr>
<a id="L194"></a><h4>hxa_expressions.py</h4>
<p><a href="../source/hxa_expressions.py">Source File</a></p>
<p>Handles expression conversion and evaluation.</p>
<p>Every expression is converted to Reverse Polish Notation (RPN) form by a generalized operator precedence parser. This type of parser is <em>bottom-up</em> rather than <em>top-down</em>. During parsing, checks are made for syntax errors.</p>
<p>For expressions which are successfully converted to RPN form, an immediate evaluation is attempted. The evaluator is capable of partial evaluation, resolving whatever it can and saving the rest for later. During evaluation, checks are made for run-time errors.</p>
<p><b>Primary Responsibilities</b></p>
<ul> <li>pass one: convert expressions to RPN form and attempt to evaluate them</li>
 <li>pass two: complete evaluation of expressions</li>
 <li>file output: <em>not used</em></li>
 </ul>
<a id="L195"></a><h3>Creating an HXA Variant</h3>
<a id="L196"></a><h4>Using Macros to Implement an Instruction Set</h4>
<p>Note that what HXA deals with after the first pass are essentially <em>[addr, type, value]</em> lists. This implies that some CPU instruction sets might be implemented entirely as macros which expand to one or more <a href="hxa.htm#L06C">BIT--</a> pseudo opcodes.</p>
<p>The <a href="../source/cpu_hxa_t.py">HXA_T</a> handler, which has no built-in instruction set, can be used to assemble such macros with the correct program counter size, byte size and orientation.</p>
<p>A command line to use it might be:</p>
<blockquote> python hxa.py -hxa_t filename<br> </blockquote>
<p>where <em>filename</em> is a top-level source file. Within itself it would <a href="hxa.htm#L05C">include</a> another file of macro definitions of the mnemonics of a real processor. These macros would then produce the same output as those of a native assembler.</p>
<p>For some processors the officially recommended mnemonics could be used. If any expressions following such mnemonics can not be directly evaluated by HXA, they can likely be altered by HXA to an evaluable form.</p>
<p>For other processors a variant set might be possible, or even desirable. A common reason would be to reduce the effort needed to identify the address mode of a mnemonic. The mnemonic itself would indicate the address mode, and any expression would need no decoration to indicate one. Such a variant set might entail a loss of portability, but this might be acceptable in some cases.</p>
<p>As a proof-of-concept, macro include files implementing the official mnemonics of the 8080/85, Z80, 6502, 65C02 and R65C02 microprocessor instruction sets are provided in the general demos .</p>
<p>The 8080/85 mnemonics are the simplest to implement. The instruction set is fairly small and the address modes are generally indicated by the mnemonics themselves.</p>
<p>The 6502 and 65C02 also have fairly small instruction sets. The main difficulty is that the address modes are often indicated by decorating the expression. Without resorting to non-standard mnemonics, some examination and manipulation are required.</p>
<p>The macros have been defined to be compatible with the same instruction set extensions recognized by HXA65. They do not recognize any kind of <a href="#L1AB">forced address mode</a>, however. This might be better be implemented as additional macros anyway (eg., "LDAA" might be defined to always "LoaD Accumulator Absolute").</p>
<p>The R65C02 instruction set is a superset of the 65C02 instruction set. Its macro implementation is simplified by <a href="hxa.htm#L05C">including</a> the 65C02 macro implementation. Only the the 32 new instructions it adds are defined by macros.</p>
<p>The 65C02 macro implementation itself does not use this approach even though its instruction set is also a superset of the 6502 instruction set. Because it introduces new address modes for old instructions, it seems more reasonable to re-define the macros implementing those instructions.</p>
<p>The Z80 instruction set is fairly large and there are a large number of address modes. The macro file provided makes extensive use of nested macros to determine the proper data to emit.</p>
<p><b>Advantages</b></p>
<ul> <li>completely portable</li>
 <li>no cpu handler other than the already existing HXA_T version is needed</li>
 </ul>
<p><b>Disadvantages</b></p>
<ul> <li>slower assembly than a native cpu handler</li>
 <li>a (sometimes much) larger number of source lines due to macro expansion</li>
 </ul>
<hr>
<a id="L197"></a>
<a id="L198"></a><h4>Creating a Native CPU Handler Module</h4>
<p>Every native CPU <a href="hxa.htm#L007">handler</a> supporting one or more processors is implemented by a Python module. The name of the module has the form <em>cpu_---.py</em>, where "---" is usually the processor family. It is the only part that needs to be specified on the command line; HXA fills in the rest.</p>
<p>Handler modules must be in the same directory as the rest of HXA. The form of the name is mostly to distinguish handler modules from the main HXA  modules.</p>
<p>To assemble a different language, only this single module needs to be replaced. It is called only from the <a href="#L18C">code generator</a> module. This isolates it from all other HXA modules, making it unnecessary to change them as well.</p>
<p>The specification details only the following public functions that must be provided. How they work is up to the implementer. All that is required is that any inputs and outputs be correct.</p>
<p>Primary Responsibilities:</p>
<ul> <li>pass one: describe CPU; identify CPU mnemonics; begin evaluating mnemonic expressions; handle CPU-specific "ASSUME" options</li>
 <li>pass two: <em>not used</em></li>
 <li>file output: <em>not used</em></li>
 </ul>
<hr>
<p>These methods must be provided in a native handler:</p>
<ul> <li><a href="#L199">name()</a> : provides the generic or family name of the HXA variant (for display to user)</li>
 <li><a href="#L19A">reserved()</a> : provides a variant identifier symbol, plus any other symbols that are not available for programmer use</li>
 <li><a href="#L19B">iscpu()</a> : determine whether or not a token is the name of CPU this module can assemble code for</li>
 <li><a href="#L19C">getdescriptor()</a> : describe the program counter size, native orientation of multi-octet values, and the "byte" size</li>
 <li><a href="#L19D">setcpu()</a> : perform any setup needed for a particular CPU</li>
 <li><a href="#L19E">isop()</a> : determine whether or not a token is a CPU mnemonic</li>
 <li><a href="#L19F">doop()</a> : assemble one mnemonic and add the result to the code storage array in the <a href="#L18C">code generator</a></li>
 <li><a href="#L1A0">doassume()</a> : to communicate in source code information that could not otherwise be easily known to HXA</li>
 </ul>
<p>How they work, and what other methods they might call, is up to the implementer.</p>
<hr>
<a id="L199"></a>
<h4><b>name()</b></h4>
<h4>Called As</h4>
<ul> <li><b>name</b> ()</li>
 </ul>
<h4>Parameter</h4>
<ul> <li>none</li>
 </ul>
<h4>Return Value</h4>
<ul> <li>a string identifying the variant (eg., "HXA_T" or "HXA65")</li>
 </ul>
<hr>
<a id="L19A"></a>
<h4><b>reserved()</b></h4>
<h4>Called As</h4>
<ul> <li><b>reserved</b> ()</li>
 </ul>
<h4>Parameter</h4>
<ul> <li>none</li>
 </ul>
<h4>Return Value</h4>
<ul> <li>a list of tuples of the form (<em>symbol, value</em>) to be entered as <a href="hxa.htm#L021">pre-defined</a> reserved symbols</li>
 <li>one of the tuples must identify the assembler variant (eg., [ ("__HXA_T__", <em>TRUE</em>) ] )</li>
 <li>the identifier tuple may optionally be accompanied by one or more tuples describing any other reserved symbols (eg., register names)</li>
 </ul>
<hr>
<a id="L19B"></a>
<h4>iscpu()</h4>
<h4>Called As</h4>
<ul> <li><b>iscpu</b> (  token )</li>
 </ul>
<h4>Parameter</h4>
<ul> <li><em>token</em> is the string argument following a <a href="hxa.htm#L068">CPU</a> pseudo opcode</li>
 </ul>
<h4>Return Value</h4>
<ul> <li><em>TRUE</em> if <em>token</em> is the name of a CPU whose instruction set this module can assemble, otherwise <em>FALSE</em></li>
 </ul>
<hr>
<a id="L19C"></a>
<h4><b>getdescriptor()</b></h4>
<h4>Called As</h4>
<ul> <li><b>getdesciptor</b> ( name )</li>
 </ul>
<h4>Parameter</h4>
<ul> <li><em>name</em> is the name of a CPU previously identified by <a href="#L19B">iscpu()</a></li>
 </ul>
<h4>Return Value</h4>
<ul> <li>a <a href="hxa.htm#L069">CPU descriptor</a> string</li>
 </ul>
<hr>
<a id="L19D"></a>
<h4><b>setcpu()</b></h4>
<h4>Called As</h4>
<ul> <li><b>setcpu</b> ( name )</li>
 </ul>
<h4>Parameter</h4>
<ul> <li><em>name</em> is the name of a CPU previously identified by <a href="#L19B">iscpu()</a></li>
 </ul>
<h4>Return Value</h4>
<ul> <li><em>TRUE</em> if <em>name</em> is successfully initialized, otherwise <em>FALSE</em></li>
 </ul>
<hr>
<a id="L19E"></a>
<h4><b>isop()</b></h4>
<h4>Called As</h4>
<ul> <li><b>isop</b> ( token )</li>
 </ul>
<h4>Parameter</h4>
<ul> <li><em>token</em> is the <a href="hxa.htm#L025">opcode field</a> of a source line</li>
 </ul>
<h4>Return Value</h4>
<ul> <li><em>TRUE</em> if <em>token</em> is an mnemonic of the current CPU instruction set, otherwise <em>FALSE</em></li>
 </ul>
<hr>
<a id="L19F"></a>
<h4><b>doop()</b></h4>
<h4>Called As</h4>
<ul> <li><b>doop</b> ( mnemonic, cnt, exprlist )</li>
 </ul>
<h4>Parameters</h4>
<ul> <li><em>mnemonic</em> is a CPU instruction mnemonic previously identified by <a href="#L19E">isop()</a></li>
 <li><em>cnt</em> is the number of comma-separated expressions found in the expression field</li>
 <li><em>exprlist</em> is a list of the expressions in the expression field</li>
 </ul>
<h4>Return Value</h4>
<ul> <li>a ( <em>boolean, mesgndx</em> ) tuple</li>
 <li><em>boolean</em> is <em>TRUE</em> if assembly was successful, otherwise <em>FALSE</em></li>
 <li><em>mesgndx</em> is an key in the dictionary of <a href="#L1AD">assembler messages</a></li>
 </ul>
<h4>Notes</h4>
<ul> <li>this method can alter any expression in any way it likes to assure correct expression evaluation</li>
 <li>if the expression field is blank, <em>cnt</em> is zero and <em>exprlist</em> is an empty list</li>
 <li>if no commas separate expressions, <em>cnt</em> is one and <em>exprlist</em> has only one entry</li>
 <li>commas do <em>not</em> separate expressions if escaped, within a literal (char, string or regex), or between balanced parentheses</li>
 <li>no element of exprlist has been evaluated</li>
 </ul>
<hr>
<a id="L1A0"></a>
<h4><b>doassume()</b></h4>
<h4>Called As</h4>
<ul> <li><b>doassume</b> ( flag, arg )</li>
 </ul>
<h4>Parameters</h4>
<ul> <li><em>flag</em> is the left part of an ASSUME string argument, before the split character</li>
 <li><em>arg</em> is the right part of an ASSUME string argument, after the split character</li>
 </ul>
<h4>Return Value</h4>
<ul> <li><em>TRUE</em> if <em>flag</em> was handled without error or should be ignored, otherwise <em>FALSE</em></li>
 </ul>
<h4>Notes</h4>
<ul> <li><em>flag</em> and <em>arg</em> are both lower case</li>
 <li>what specific <em>flags</em> and <em>args</em> are recognized (if any), and what they mean, is up to the implementer</li>
 <li>HXA first checks its built-in assumptions before calling this method</li>
 <li>this method is called once for every comma-separated <em>flag:arg</em> pair found in the expression field</li>
 </ul>
<hr>
<a id="L1A1"></a><h4>Available HXA Methods</h4>
<p>The following methods in other modules may be called by a CPU handler.</p>
<p>In <a href="#L194">hxa_expressions.py</a>:</p>
<ul> <li><a href="#L1A2">EXP.getnum()</a> : parse an expression and fully or partially evaluate it</li>
 <li><a href="#L1A3">EXP.resolved()</a> : determine if <em>EXP.getnum()</em> resulted in a full evaluation or not</li>
 <li><a href="#L1A4">EXP.getconstnum()</a> parse and fully evaluate an expression</li>
 <li><a href="#L1A5">EXP.getinrange()</a> : fully evalute an expression and check if the result is within a range</li>
 </ul>
<p>In <a href="#L18D">hxa_codegen.py</a>:</p>
<ul> <li><a href="#L1A6">CG.store()</a> : make an entry in the code storage array</li>
 </ul>
<p>In <a href="#L189">hxa_usermesg.py</a>:</p>
<ul> <li><a href="#L1A7">UM.warn()</a> : report an HXA warning</li>
 <li><a href="#L1A7">UM.error()</a> : report an HXA error</li>
 <li><a href="#L1A7">UM.fatal()</a> : report a fatal HXA error</li>
 </ul>
<hr>
<a id="L1A2"></a>
<h4><b>EXP.getnum()</b></h4>
<h4>Usage</h4>
<ul> <li><b>EXP.getnum</b> ( expr )</li>
 </ul>
<h4>Parameter</h4>
<ul> <li><em>expr</em> is a string in the <a href="hxa.htm#L027">expression field</a> of a source code line</li>
 </ul>
<h4>Return Value</h4>
<ul> <li>a ( <em>boolean, result</em> ) tuple</li>
 <li><em>boolean</em> is <em>TRUE</em> if parse and evalution were successful, otherwise <em>FALSE</em></li>
 <li><em>result</em> is the full or partial evaluation of <em>expr</em> if <em>TRUE</em>, otherwise <em>None</em></li>
 </ul>
<hr>
<a id="L1A3"></a>
<h4><b>EXP.resolved()</b></h4>
<h4>Usage</h4>
<ul> <li><b>EXP.resolved</b> ( result )</li>
 </ul>
<h4>Parameter</h4>
<ul> <li><em>result</em> is the second part of a tuple returned by <em>EXP.getnum()</em></li>
 </ul>
<h4>Return Value</h4>
<ul> <li><em>TRUE</em> if <em>result</em> is fully evaluated (an integer value), otherwise <em>FALSE</em></li>
 </ul>
<h4>Notes</h4>
<ul> <li><em>no assumption whatsoever</em> can be made about the type of a partially evaluated expression</li>
 </ul>
<hr>
<a id="L1A4"></a>
<h4><b>EXP.getconstnum()</b></h4>
<h4>Usage</h4>
<ul> <li><b>EXP.getconstnum</b> ( expr )</li>
 </ul>
<h4>Parameter</h4>
<ul> <li><em>expr</em> is a string in the <a href="hxa.htm#L027">expression field</a> of a source code line</li>
 </ul>
<h4>Return Value</h4>
<ul> <li>a ( <em>boolean, result</em> ) tuple</li>
 <li><em>boolean</em> is <em>TRUE</em> if <em>result</em> is an integer value, otherwise <em>FALSE</em></li>
 <li><em>result</em> is the integer value of <em>expr</em> if <em>TRUE</em>, otherwise <em>None</em></li>
 </ul>
<h4>Notes</h4>
<ul> <li>if <em>expr</em> is a string expression, a boolean result will be obtained by implicitly comparing it to the null string</li>
 <li>this method is like <em>EXP.getnum()</em>, except <a href="hxa.htm#L02A">forward reference</a> is not allowed in <em>expr</em></li>
 </ul>
<hr>
<a id="L1A5"></a>
<h4><b>EXP.getinrange()</b></h4>
<h4>Usage</h4>
<ul> <li><b>EXP.getinrange</b> ( expr, min, max )</li>
 </ul>
<h4>Parameters</h4>
<ul> <li><em>expr</em> is a string in the <a href="hxa.htm#L027">expression field</a> of a source code line</li>
 <li><em>min</em> is an integer which sets the lowest value <em>expr</em> may have</li>
 <li><em>max</em> is an integer which sets the highest value <em>expr</em> may have</li>
 </ul>
<p>Result:</p>
<ul> <li>a ( <em>boolean, result</em> ) tuple</li>
 <li><em>boolean</em> is <em>TRUE</em> if <em>result</em> is an integer value between <em>min</em> and <em>max</em>, otherwise <em>FALSE</em></li>
 <li><em>result</em> is the integer value of <em>expr</em> if <em>TRUE</em>, otherwise <em>None</em></li>
 </ul>
<hr>
<a id="L1A6"></a>
<h4><b>CG.store()</b></h4>
<h4>Usage:</h4>
<ul> <li><b>CG.store</b> ( type, data )</li>
 </ul>
<h4>Parameters</h4>
<ul> <li><em>type</em> is typically one of the <a href="hxa.htm#L06C">BIT--</a> pseudo opcodes (ie., BIT--, RBIT--, SBIT-- or UBIT--)</li>
 <li><em>data</em> is typically a fully or partially evaluated expression</li>
 </ul>
<h4>Return Value</h4>
<ul> <li>None</li>
 </ul>
<h4>Note</h4>
<ul> <li>to actually save anything for later output, this method <em>must</em> be called by the handler</li>
 </ul>
<hr>
<a id="L1A7"></a>
<h4><b>UM.error()</b></h4>
<h4>Usage</h4>
<ul> <li><b>UM.error</b> ( msgndx <em>[, cause]</em> )</li>
 </ul>
<h4>Parameters</h4>
<ul> <li><em>msgndx</em> is a key into the dictionary of <a href="#L1AD">assembler messages</a></li>
 <li><em>cause</em> is an optional <a href="hxa.htm#L009">string_lit</a>  which provides additional information (most often the token causing the error)</li>
 </ul>
<h4>Return Value</h4>
<ul> <li>None</li>
 </ul>
<h4>Notes</h4>
<ul> <li>the methods <b>UM.warn()</b>  and <b>UM.fatal</b>  are also available, and have identical signatures</li>
 <li>all three methods add to the counts necessary to halt assembly</li>
 </ul>
<a id="L1A8"></a><h3>CPU Handlers</h3>
<a id="L1A9"></a><h4>HXA_T Handler</h4>
<p><a href="../source/cpu_hxa_t.py">Source File</a></p>
<p><b>T_XX</b>  processors are an imaginary family of test processors. They were created for the purpose of testing all the modules of HXA which do not depend upon any particular real processor. They currently share only three attributes with real processors:</p>
<ul> <li>a program counter size (8- to 32-bits)</li>
 <li>a native byte ordering convention (MSB or LSB)</li>
 <li>a native byte size (8-, 16- or 32-bits)</li>
 </ul>
<p>Although primarily created to test HXA, this handler can also be used to assemble real processor instruction sets implemented as <a href="hxa.htm#L07D">macro</a> <a href="hxa.htm#L05C">include</a> files.</p>
<h4>Additional Pre-defined Labels</h4>
<ul> <li>"__HXA_T__", <em>TRUE</em> : generic name</li>
 </ul>
<h4>CPU Descriptor</h4>
<p>A T_XX <a href="hxa.htm#L069">cpu descriptor</a> <em>is</em> its name. That is, in the T_XX family there is no distinction between a cpu <em>name</em> and a cpu <em>descriptor</em>. The descriptor is thus publicly exposed (as opposed to real processors, which generally hide their descriptors).</p>
<h4>Instruction Set</h4>
<p>None.</p>
<h4>ASSUME Pseudo Opcode</h4>
<p>T_XX cpus simply echo all ASSUME <em>flag</em> and <em>argument</em> values to <em>stdout</em>.</p>
<p>Generally the return value is <em>TRUE</em>. It is <em>False</em> only if the argument value contains the string "printable".</p>
<a id="L1AA"></a><h4>HXA65 Handler</h4>
<p><a href="../source/cpu_hxa65.py">Source File</a></p>
<p>The 6502 processor was created by MOS Technology in the late 1970s. It powered many home computers from Acorn, Apple, Atari, BBC, Commodore and others through the 1980s. Now controlled by Western Design Center, its descendants remain popular today in many embedded applications.</p>
<p>This handler supports the 6502, 65C02, R65C02, W65C02S 8-bit processors and the W65C816S 16-bit processor. It also supports any processor with an instruction set identical to one of these, such as the 6510 and 8502.</p>
<h4>Related Resources</h4>
<ul> <li><a href="http://www.6502.org">6502 Org</a> : Hardware and Software Forum</li>
 <li><a href="https://westerndesigncenter.com">Western Design Center</a> : Hardware Documentation</li>
 </ul>
<h4>Additional Pre-defined Labels</h4>
<ul> <li>"__HXA65__", <em>TRUE</em> : generic name</li>
 <li>"A", <em>TRUE</em> : register name</li>
 <li>"X", <em>TRUE</em> : register name</li>
 <li>"Y", <em>TRUE</em> : register name</li>
 <li>"S", <em>TRUE</em> : register name</li>
 <li>"P", <em>TRUE</em> : register name</li>
 <li>"PC", <em>TRUE</em> : register name</li>
 <li>"B", <em>TRUE</em> : register name</li>
 <li>"C", <em>TRUE</em> : register name</li>
 <li>"DP", <em>TRUE</em> : register name</li>
 <li>"SP", <em>TRUE</em> : register name</li>
 <li>"DB", <em>TRUE</em> : register name</li>
 <li>"PB", <em>TRUE</em> : register name</li>
 </ul>
<h4>CPU Descriptor</h4>
<p>"T_24_L" if the processor is "W65C816S", otherwise "T_16_L"</p>
<h4>Instruction Set</h4>
<p>All defined mnemonics of each supported processor instruction set are available. In addition, HXA65 supports several mnemonic aliases recommended by Western Design Center.</p>
<table><caption>Mnemonic Aliases</caption> <thead><tr> <th>Standard</th><th>Alias</th><th>6502</th><th>65C02</th><th>R65C02</th><th>W65C02S</th><th>W65C816S</th> </tr></thead><tbody> <tr><td>BCC</td><td>BLT</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr> <tr><td>BCS</td><td>BGE</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr> <tr><td>DEC A</td><td>DEA</td><td>&nbsp;</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr> <tr><td>INC A</td><td>INA</td><td>&nbsp;</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr> <tr><td>JSL</td><td>JSR</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>Y</td></tr> <tr><td>JML</td><td>JMP</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>Y</td></tr> <tr><td>TCD</td><td>TAD</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>Y</td></tr> <tr><td>TCS</td><td>TAS</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>Y</td></tr> <tr><td>TDC</td><td>TDA</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>Y</td></tr> <tr><td>TSC</td><td>TSA</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>Y</td></tr> <tr><td>XBA</td><td>SWP</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>Y</td></tr> </tbody></table>
<h4>Accumulator Address Mode</h4>
<p>In official Usage <em>accumulator</em> address mode is indicated by a single literal character 'A' in the expression field. A blank expression field officially indicates <em>implied</em> address mode.</p>
<p>However, no instruction which allows implied addressing also allows accumulator addressing, and vice-versa. Therefore use of the single character 'A' in the expression field is optional for accumulator mode addressing. If desired, it may be left blank. The mnemonic will still be interpreted correctly.</p>
<h4>Zero Page Addressing</h4>
<p>Many 6502-family instructions have both absolute and zero page addressing forms. In source code both forms look alike, but in object code the zero page form is usually shorter and faster.</p>
<p>The HXA65 module normally assembles the zero page form only if during pass one the operand address is calculated to be in the range $0000 to $00FF (ie., on page zero). If the operand address cannot be resolved during pass one, or is greater than $00FF, HXA65 assembles the absolute form.</p>
<p>For timing or size purposes it can occasionally be desirable to override HXA65's automatic selection of zero page address mode. <a href="#L1AB">Forced address mode</a> can be used to force absolute mode on an otherwise zero page address (and vice-versa, though this is rarer).</p>
<p>On some systems and some processors it is possible to change the default location of zero page. HXA65 can adapt to this using the ASSUME pseudo opcode (below).</p>
<h4>Extended Address Modes</h4>
<p>HXA65 accepts additional address modes for several standard instruction mnemonics. These generate exactly the same object code as the standard mnemonics. They are intended mainly to make some tasks easier or to make the sometimes-odd W65C816S standard syntax more closely resemble that of the other supported microprocessors. Note that these extensions are <em>not</em> portable.</p>
<table><caption><b>BRK</b>  - All Processors</caption> <thead><tr> <th>Syntax</th><th>Mode</th><th>Type</th> </tr></thead><tbody> <tr><td>BRK #12</td><td>immediate</td><td>extended</td></tr> <tr><td>BRK</td><td>implied</td><td>standard</td></tr> <tr><td>BRK $12</td><td>zero page</td><td>extended</td></tr> </tbody></table>
<p>The <b>BRK</b>  instruction occupies one byte of object code and accepts no arguments, but when executed the program counter actually advances by two bytes before being stored on the stack. Control is then transferred to the software interrupt service (IRQ) routine. When the IRQ routine returns, execution resumes at the second byte after the BRK instruction.</p>
<p>It is possible for the IRQ routine to retrieve the stored program counter from the stack and use it to determine the skipped byte following the BRK instruction. The IRQ routine can then make a control branch based on examining that "signature" byte.</p>
<p>The HXA65 extensions are designed to make it easier to specify the value of the signature byte. The zero page mode is designed to make the instruction resemble the standard W65C816S <b>COP</b>  instruction syntax.</p>
<table><caption><b>COP</b>  - W65C816S Only</caption> <thead><tr> <th>Syntax</th><th>Mode</th><th>Type</th> </tr></thead><tbody> <tr><td>COP #12</td><td>immediate</td><td>extended</td></tr> <tr><td>COP $12</td><td>zero page</td><td>extended</td></tr> </tbody></table>
<p>The Western Design Center standard requires the <b>COP</b>  instruction to be followed by a zero page address operand (ie., a "signature" byte).</p>
<p>However whether a co-processor uses the value <em>at</em> the zero page address (as implied by the syntax) or the value <em>of</em> the zero page address (ie., as an immediate value) is ambiguous. HXA65 therefore allows both forms.</p>
<p>Note that only COP signatures $80-$FF are available for user definition. Signatures $00-$7F are reserved by WDC.</p>
<table><caption><b>JML</b>  - W65C816S Only</caption> <thead><tr> <th>Syntax</th><th>Mode</th><th>Type</th> </tr></thead><tbody> <tr><td>JML ($1234)</td><td>absolute indirect</td><td>standard</td></tr> <tr><td>JML $123456</td><td>long absolute</td><td>extended</td></tr> </tbody></table>
<p>The W65C816S <b>JML</b>  ("jump long") instruction officially has only one address mode, absolute indirect. The JMP ("jump") instruction officially is assigned the long absolute address mode.</p>
<p>However, this can cause a problem for HXA65 when dealing with long forward jumps. Any <a href="hxa.htm#L02A">forward reference</a> in an expression means the destination address cannot be resolved during pass one. Therefore HXA65 will generate the official default address mode, which is absolute (16-bit) rather than long (24-bit).</p>
<p>In fact, it is officially impossible to use the JMP instruction to create a long forward jump without also either using <a href="#L1AB">forced address mode</a> or pre-defining the destination address via an <a href="hxa.htm#L075">equate</a>.</p>
<p>Alternatively, HXA allows the JML instruction be used for the same purpose. If the operand of the JML instruction is not indirect (ie., surrounded by balanced parentheses), HXA65 will generate a "JMP long absolute" opcode.</p>
<p>This may be the safer option if there is any possibility at all of confusing a <em>program bank</em> address with a <em>data bank</em> address. HXA65 always generates a 16-bit address rather than a 24-bit address if it thinks the address is in the data bank, but a 16-bit JMP generates its 24-bit effective address using the program bank.</p>
<table><caption><b>JSR</b>  - W65C816S Only</caption> <thead><tr> <th>Syntax</th><th>Mode</th><th>Type</th> </tr></thead><tbody> <tr><td>JSR $1234</td><td>absolute</td><td>standard</td></tr> <tr><td>JSR ($1234,X)</td><td>absolute X-indexed indirect</td><td>standard</td></tr> <tr><td>JSR $123456</td><td>long absolute</td><td>extended</td></tr> </tbody></table>
<p>Officially only the <b>JSL</b>  ("jump to subroutine long") instruction permits (and requires) the "long absolute" address mode. HXA65 will automatically generate a "JSL long absolute" opcode if it recognizes during the first pass that the operand of a JSR instruction represents a 24-bit address.</p>
<table><caption><b>PEA</b>  - W65C816S Only</caption> <thead><tr> <th>Syntax</th><th>Mode</th><th>Type</th> </tr></thead><tbody> <tr><td>PEA #$1234</td><td>immediate</td><td>extended</td></tr> <tr><td>PEA $1234</td><td>absolute</td><td>standard</td></tr> </tbody></table>
<p>The Western Design Center standard requires the <b>PEA</b>  ("push effective absolute address") instruction to be followed by an absolute address operand.</p>
<p>However the PEA instruction actually pushes the value <em>of</em> the address onto the stack, rather than the value <em>at</em> the address. That is, the operand value is actually used as an immediate value, rather than as the address of the value (as implied by the standard syntax).</p>
<p>HXA65 therefore also allows immediate addressing with the PEA instruction to better reflect what actually happens.</p>
<table><caption><b>PEI</b>  - W65C816S Only</caption> <thead><tr> <th>Syntax</th><th>Mode</th><th>Type</th> </tr></thead><tbody> <tr><td>PEI $12</td><td>direct</td><td>extended</td></tr> <tr><td>PEI ($12)</td><td>direct indirect</td><td>standard</td></tr> </tbody></table>
<p>The Western Design Center standard requires the <b>PEI</b>  ("push effective indirect address") instruction to be followed by a direct indirect address operand ("direct" is the same as "zero page" on the other processors).</p>
<p>However, there is no actual indirection involved. The PEI instruction simply pushes the value stored at the direct address onto the stack. That is, the operand is not treated as an address which holds the effective address of the actual value (a "pointer" to the effective address), but as the effective address itself.</p>
<p>HXA65 therefore also allows direct addressing with the PEI instruction to better reflect what actually happens.</p>
<table><caption><b>WDM</b>  - W65C816S Only</caption> <thead><tr> <th>Syntax</th><th>Mode</th><th>Type</th> </tr></thead><tbody> <tr><td>WDM #12</td><td>immediate</td><td>extended</td></tr> <tr><td>WDM</td><td>implied</td><td>standard</td></tr> <tr><td>WDM $12</td></td><td>zero page</td><td>extended</td></tr> </tbody></table>
<p>The <b>WDM</b>  instruction is reserved for possible future expansion by WDC. Although it is only one byte, it requires a "signature" byte to follow it. It currently acts as a two byte NOP.</p>
<p>HXA allows this signature byte to be specified as an immediate or zero page address operand in addition to an implied one. The zero page mode is designed to make the instruction resemble the standard W65C816S COP instruction syntax.</p>
<h4>ASSUME Pseudo Opcode</h4>
<a id="L1AB"></a>
<h4>Forced Address Mode</h4>
<h4>Usage</h4>
<ul> <li><b>ASSUME</b>  addr:absolute</li>
 <li><b>ASSUME</b>  addr:zeropage</li>
 <li><b>ASSUME</b>  addr:long (W65C816 only)</li>
 <li><b>ASSUME</b>  addr:direct (synonym for addr:zeropage)</li>
 </ul>
<h4>Description</h4>
<p>These four forced address modes permit a programmer to override the address mode which would otherwise be selected by HXA65. In general, zero page instructions can be forced to absolute, and vice versa, on all supported microprocessors. In the case of the W65C816S, long instructions can also be forced.</p>
<p>When address forcing is applied HXA does not perform any range-checking on the expression following the instruction. When stored it must fit into 32 bits, but if it is larger than the bits allowed, it is silently truncated. Forcing the same address mode as HXA65 would itself select thus has the effect of preventing any potential operand size error.</p>
<p>Address forcing preserves register indexing if present. For example, forcing zero page X-indexed to absolute X-indexed is legal if the instruction allows both forms.</p>
<p>Note that in cases where multiple address modes are possible, HXA65 defaults to choosing 16-bit absolute mode operands whenever it cannot resolve the associated expression on the first pass (ie., the expression contains a <a href="hxa.htm#L02A">forward reference</a>). Address forcing can be used in these cases to provide a "hint" as to the correct size to choose.</p>
<p>Address forcing applies for only a single instruction source code line. It must be applied to every instruction for which forcing is desired.</p>
<h4>Zero Page Location</h4>
<h4>Usage</h4>
<ul> <li><b>ASSUME</b>  zeropage:$xx</li>
 </ul>
<h4>Parameter</h4>
<ul> <li><em>$xx</em> is a numeric expression in the range $00 to $FF</li>
 </ul>
<h4>Description</h4>
<p>The default location of zero page on all supported processors is page zero (ie., the address range $0000 to $00FF). Instructions using a zero page address mode create a 16-bit address value by automatically using "$00" as the high eight bits.</p>
<p>However, some processors and some systems with memory management chips allow changing the location of zero page. This assumption allows the programmer to inform HXA65 that the location of zero page has changed. That is, the high eight bits of a "zero page" instruction are some other value than $00.</p>
<p><em>$xx</em> is treated as the page number of "zero page". "Zero page" is located at $xx00 to $xxFF.</p>
<p>If an instruction allows multiple possible modes, zero page addressing will be chosen if the high eight bits of an address expression matches this page number.</p>
<h4>Direct Page Location (W65C816S Only)</h4>
<h4>Usage</h4>
<ul> <li><b>ASSUME</b>  directpage:$xxxx</li>
 </ul>
<h4>Parameter</h4>
<ul> <li><em>$xxxx</em> is a numeric expression in the range $0000 to $FF00</li>
 </ul>
<h4>Description</h4>
<p>The default location of the direct page on the W65C816S is page zero in bank zero (ie., the address range $00:0000 to $00:00FF). However, this may be set to any bank zero location in the range $0000 to $FF00.</p>
<p>This assumption allows the programmer to inform HXA65 that the location of the direct page has changed.</p>
<p><em>$xxxx</em> is treated as the base address of the direct page (ie.,  the direct page is located at $00:xxxx to $00:xxxx+$FF). Direct addresses are specified as an offset from this base address.</p>
<p>If an instruction allows multiple possible modes, direct page addressing will be chosen if an address expression is in the range $xxxx and $xxxx + 255.</p>
<h4>Data Bank Location (W65C816S Only)</h4>
<h4>Usage</h4>
<ul> <li><b>ASSUME</b>  databank:$xx</li>
 </ul>
<h4>Parameter</h4>
<ul> <li><em>$xx</em> is a numeric expression in the range $00 to $FF</li>
 </ul>
<h4>Description</h4>
<p>The default location of the data bank on the W65C816S is bank zero (ie., the address range 00:0000 to $00:FFFF). However, this may be changed to any bank in the range $00 to $FF.</p>
<p>This assumption allows the programmer to inform HXA65 that the location of the data bank has changed.</p>
<p><em>$xx</em> is treated as the data bank number (ie., the data bank is located at $xx:0000 to $xx:FFFF).</p>
<p>Every data address that is specified as a 16-bit absolute address is automatically extended to 24 bits using the data bank byte. If an instruction allows multiple possible modes, absolute addressing will be chosen if the high 8 bits of the 24-bit address expression match the data bank number.</p>
<h4>Register Sizes (W65C816S Only)</h4>
<h4>Usage</h4>
<ul> <li><b>ASSUME</b>  accum:8</li>
 <li><b>ASSUME</b>  accum:16</li>
 <li><b>ASSUME</b>  index:8</li>
 <li><b>ASSUME</b>  index:16</li>
 </ul>
<h4>Description</h4>
<p>At startup the W65C816S microprocessor is in 8-bit emulator mode When programmatically switched to 16-bit native mode, the sizes of the accumulator and index registers can be controlled by manipulating two bits in the status register. One bit ("M") controls the accumulator size and the other ("X") controls the X- and Y-index register sizes.</p>
<p>While in general a programmer must know which register sizes the W65C816S is in, it doesn't matter much to HXA65. The assembled object code produced doesn't change - except in the case of immediate address mode. HXA65 must store an immediate value as either 8- or 16-bits, but doesn't itself know which is appropriate at any given time. These four assumptions allow a programmer to tell it which size to use.</p>
<a id="L1AC"></a><h3>Future Development</h3>
<p>An informal list of enhancements or changes being considered (there is no guarantee any of these will actually happen).</p>
<hr>
<h4><b>Loop..Until pseudo ops</b></h4>
<p>A conditional like "while..endwhile", except that it tests at the bottom of the loop. Not difficult to implement, but it's hard to come up with a name pair that keeps the "name..endname" symmetry of all the others</p>
<hr>
<h4>Fix known weak points (aka "bugs")</h4>
<p>a) operator tokens</p>
<p>These are currently strings, and expression evaluation may fail if a user string happens to match one. They could be made more difficult to accidentally match (by including unprintable characters, say) or their type could be changed (to numeric values, perhaps).</p>
<p>b) numeric function arguments</p>
<p>The sub-expressions which comprise function arguments in the RPN form are not range-checked. This is so that the VAL() function can return an out-of-range result which can come back in-range as part of a larger expression (and which will trigger an error if it doesn't). However since range checking only occurs once for every complete expression (at the end), an out-of-range intermediate result can be created and used for any numeric function argument. For some functions this won't matter as they will not be used if they are out of range (eg., MID$()). But any which do not range check might produce questionable results</p>
<p>c) EXIT block nesting clearing</p>
<p>EXIT skips to the end of a macro, repeat or while block and silently closes any still-open IF blocks within the block. This behavior is necessary to allow the unconditional EXIT to be used within an IF block. However this unconditional nature means that it will also "cover up" an "IF without ENDIF" problem in the block body.</p>
<p>On the one hand that's somewhat helpful, as the error then can't hurt anything outside the block (such as unexpectedly cutting off assembly for hundreds of lines).</p>
<p>On the other hand, it's an undetected error. Moreover, unlike any other source code error in the skipped over portion, it's one that is actively covered up by HXA.</p>
<p>On the other other hand, it's an error that has no practical effect. If EXIT <em>is</em> executed HXA reacts the same way whether or not there is an unbalanced IF block. If EXIT <em>is not</em> executed HXA will detect an unbalanced block.</p>
<hr>
<h4>Link files</h4>
<p>Not likely to be compatible with any existing format, if only because they tend to be tied to specfic processors (although what if a "such-and-such file" was recognized as a "processor mnemonic" and that HXA variant included an ability to output that format?)</p>
<p>It should be fairly easy to dump the state of HXA after the first pass to a text file that could also be read back as an include file. Use of a "linkfile" pseudo op would trigger this, and also suppress errors if the first segment of a source file was relative rather than absolute (unless the user also specified a binary or hex output file).</p>
<p>The main problem foreseen is turning the internal RPN expression form back to text, specifically partially resolved expressions. Labels, numeric integers and all operators are not a problem.</p>
<p>Strings would have to have unprintable characters turned into escape codes. Literal strings would not have this problem, but partial resolution might have created dynamic strings with unprintable characters.</p>
<p>Regular expressions do not exist in their literal form in partially resolved expressions. This would have to be changed or their existence in link files made illegal.</p>
<p>It would probably be a good idea to require all external labels to be declared via "public" or "global" or some such pseudo op.</p>
<h4>Additional functions</h4>
<p>New functions are easily added if a common use can be discerned. It is now more likely that user access to certain values will be provided by new functions rather than new internal variables. It's easy to write functions that take no arguments, the style is not objectionable, and it simplifies the symbol-handling code.</p>
<p>a) FIRST$(str [,len])</p>
<p>Returns first <len> characters of string (<len> defaults to one if not supplied). Similar to BASIC LEFT$(), except length parameter is optional. However, not much different from MID$(str, 1 [,len]) or MATCH$(str, /^./), except more compact if only the first character is wanted. In that case, though, is 'FIRST$(str) == "char"' more useful than '"str" ~ /^(char)/', which is already available ?</p>
<p>b) LAST$(str [,len])</p>
<p>Similar operation, comments, and objections as FIRST$(), except it operates on end of string rather than beginning. Also the extension MID$()'s length argument to negative values allows MID$(str, -1) to achieve the same thing</p>
<p>c) MIN(numexp1, numexp2)</p>
<p>Returns minimum value of two expressions - easy to implement, but is it useful ?</p>
<p>d) MAX(numexpr1, numexpr2)</p>
<ul> <li>ditto</li>
 </ul>
<p>e) TIME$() - implemented v0.180</p>
<ul> <li>essentially a wrapper for ctime(), re-named to match HXA conventions</li>
 </ul>
<p>f) ISLABEL(name) - implemented v0.190 as LABEL()</p>
<p>Is name a defined label? Already available as FORWARD("name") is itself a complete expression, although the sense is opposite (TRUE if "name" is not defined)</p>
<p>g) SEGABS(name) or SEGLDA(name) or SEGADR(name)</p>
<p>The absolute load address of a segment ( SEGBEG(firstseg) + SEGOFF(name) ). May make it easier to move to execution address (if different). But this can already be calculated using existing functions. Could also define this as a macro for ease of use, although it might have to be re-defined for every program using a different name for 'firstseg'</p>
<p>h) LABEL(strexpr) or GLOBAL(strexpr)</p>
<p>Makes a label out of strexpr and makes sure it is a global. But how would a value be assigned to it? Might also consider as a pseudo-op: .LABEL strexp. Presumably it would receive the value of the program counter at that point. Or allow global string expressions in the label field (what are the implications of this? One is that skipping during block definitions has to somehow account for this, but when used in this context they probably would not be constants. Perhaps a ".LABEL" psop is better suited, as skipping would be satisfied by the psop and the expression itself left for later resolution). Might also provide something like this so macros named by string expressions during definition (which is allowed) could be expanded by string expressions which evaluated to their names (which isn't).</p>
<p>However PUTBACKS essentially provides all this functionality, including naming macros to expand by string expressions. Still, global labels in macro definitions are somewhat of a special case as things now stand, and a ".LABEL" psop would remove that condition in a consistent manner.</p>
<p>i) REGEX(strexpr)</p>
<p>Make a regular expression out of strexpr</p>
<p>j) CPU$() - implemented v0.180</p>
<ul> <li>returns name of current CPU being used</li>
 </ul>
<p>k) User Functions</p>
<p>Easiest might be one-line functions:</p>
<blockquote> function myfunc(]mynum,]mystr$)=expr<br> </blockquote>
<p>Formal arguments must be variable or local labels. Definition would place the argument names and expression in a table and verify the expression can be parsed without error. Types would be deduced from the argument names so parsing could handle. Evaluation might be a two-argument injected operator: the name of the function and the number of arguments. Execution would pull the arguments off the evaluation stack and assign them to the formal arguments, with the proviso that pulling an operator means an actual argument could not be resolved (which might be okay). Then recursive calls to parse (always succeeds) and evaluate the function definition (might fail if there is a forward reference in the expression, and might be okay). Might even be possible to handle optional arguments with defaults:</p>
<blockquote> function myfunc(]mynum1,]mynum2=1)=expr<br> </blockquote>
<p>How would recursive calls to user-defined functions work?</p>
<p>l) PUSH$(strexpr[, name]), POP$([name]), TOP$([name]), EMPTY([name])</p>
<p>User stack functions for default and named stacks. PUSH$() returns argument and pushes it on stack. POP$() returns top stack item and pops it off stack. TOP$() returns top stack item but does not pop it. EMPTY() returns TRUE if the stack is empty</p>
<p>Alternatively:</p>
<p>.PUSH arg pushes item on stack. .POP assigns top item to a label and removes it from stack .TOP assigns top item to a label but does not remove it from stack. .EMPTY() returns TRUE if the stack is empty</p>
<p>If only one stack, how are types verified? Should pushing or popping evaluate the argument? If not, how would we know type is correct for label being assigned to? Maybe two stacks: a numeric stack and a string stack. If stacks are themselves named, then the name indicates type?</p>
<p>Implemented v0.200 with one string stack. Multiple named stacks turn out to be a pain to manage. A mix of pseudo ops and functions: PUSHS, POP$(), PEEK$(), EMPTY()</p>
<p>m) LOOP0() and LOOP1()</p>
<p>Return the zero- and one-based iteration counts of repeat and while loops. Defaults to zero if not block active.</p>
<p>The idea would be to eliminate manually implement loop counters. LOOP1() can be thought of as "number of loops started" and LOOP0() as "number of loops completed".</p>
<p>These have been implemented experimentally (easily done), but no noticeable speed improvement. Something a bit unexpected because multiple calculations were now avoided.</p>
<p>Non-intuitive behavior at while block starts (the functions can be used in tricky ways to "jump start" the loop).</p>
<p>When used in nested blocks it can be difficult to apprehend what the result of any particular call should be.</p>
<h4>Explicit Expression Caching</h4>
<p>A pseudo op which parses an expression and stores it in a cache without evaluating it. The advantage would be that any expression a programmer knew to be heavily used could be cached just once.</p>
<h4>Partial File Output</h4>
<p>In addition to what we have now, another idea would be to have matched "FILEGROUP..ENDGROUP" psops where all segments named between the two would be output to the same file (named as an argument to FILEGROUP) in the order they appear. Any segment could belong to multiple output files.</p>
<p>If lots of segments it could be a pain to name them all, though. Perhaps a regular expression could be of assistance?</p>
<p>Would this be of any use anyway?</p>
<h4>More list file options</h4>
<p>Perhaps an indication of which are source and which are expansion lines. - implemented v0.180</p>
<p>A source file indication might also be useful for included files. - implemented v0.180</p>
<p>User-defined page headers. These would probably require new functions to obtain file names, page number, time, etc. The main difficulty seems to be what to do with headers that require more than one line to display. If they are not part of the main text body either they are truncated or they mess up the top margin. If they are part of the main text body they could conceivably "squeeze out" the real text.</p>
<p>Should any title be automatically truncated to fit on one line? - implemented v0.180, but only appear on first page due to above problems.</p>
<p>Optionally sort the symbol listing based on value as well as alphabetically. Or make both sorts optional, with alphabetically default ON and value OFF. - implemented v0.180 as both methods always used</p>
<p>A PAGE pseudo op to force the next listed line to be at the top of the next page. Because this would actually be printed itself, a PAGE at the first line of a new page would cause the rest of the page to be blank. Should this be suppressed? Should PAGE have any effect in an unlisted section? If blank lines follow PAGE in the source, should they be listed at the top of that next page? - implemented v0.180 (no page top suppression, no effect in unlisted section)</p>
<h4>ENDMACRO [name] psop</h4>
<p>Extend ENDMACRO to match an optional name to the current MACRO name, much like ENDSEGMENT can optionally match the current SEGMENT name - implemented v0.180</p>
<h4>ASSERT expr psop</h4>
<p>Issue an error message if "expr" is false. A macro based around an IF psop could easily do the same thing during the first pass. ASSERT's difference would be that it could save any partially resolved expression during the first pass and then complete evaluation during the second. Perhaps ASSERT1 and ASSERT2 could force evaluation during a particular pass.</p>
<p>Could this be incorporated into the code storage array as an "ASSRT" type? Brief inspection indicates that a fair number of places would have to be taught the difference. The biggest problem appears to be that unlike the other element types, "ASSRT" would not generate code or data. Rather than teach every other part to ignore "ASSRT", it might be simpler to give it its own, basically parallel, structure. - implemented v0.200 (piggy-backing on code used for display of EQU, DS, etc)</p>
<h4>CPU Switching Support</h4>
<p>Allow variants which support multiple CPUs to switch between them at assembly time. The basic desire is to disallow certain CPU/instruction combinations from happening, eg., some portion of a program must run using only the lowest common instruction set. Instructions not supported in that section must cause an error, but could be allowed in other sections.</p>
<p>One idea might be a ".CPUSET" psop which lists all CPUs to be used. If no ".CPUSET" psop appears before ".CPU" then the only allowed CPU is the one named by ".CPU". Otherwise any CPU listed by ".CPUSET" is allowed.</p>
<p>Another would be a ".CPUCLEAR" psop to "unset" the current CPU back to blank. Then "CPU" could be used to set any supported processor.</p>
<h4>Arrays</h4>
<p>Singly-dimensioned arrays of numbers or strings. It seems fairly straightforward to store them in the symbol table. One idea is that their indices can be thought of as part of their name, thus allowing them to be stored as scalars. This might also make it possible to "skip" elements or more generally to treat them as associative arrays. It also seems relatively easy to extend expression evaluation to handle them. The main difficulty appears to be how to assign values to elements. The standard method of using the label field would have to be extended to recognize array notation with a potentially complex index expression. An alternative syntax - eg., ARRAY name, index, value - is easy to implement but not at all what programmers are used to, plus would not look at all like how they are later used.</p>
<h4>Implied Formal Macro Arguments</h4>
<p>This would allow a macro to accept a variable number of actual arguments without having to declare default values for any unspecified ones The definition might use "..." as the last formal argument to signal that any number (including zero) more arguments can follow. The expansion would assign any arguments found past the last named formal argument to pre-defined labels, possibly '?1', '?2', etc. '?0' could be a count of how many are actually present at expansion time. References to pre-defined labels with no assigned values should default to null strings? OR might ALWAYS define these at expansion time, and let user choose whether or not to use formal argument names as well (which would still be required in order to use default arguments with them). Though the "..." notation is designed to flag that "extra" arguments are acceptable (do not throw them away as is currently done). Another way might be to create another "ASSUME" convention that also flags extra arguments are just accepted as implied actual arguments, which has the advantage of only needing to be done once, and the disadvantage of applying globally with no visibility beyond where it's done. Of course, considering default arguments, there is in effect a way to 'count' arguments already.</p>
<p>Does this add more complication than it's worth?</p>
<h4>FLOAT and DOUBLE pseudo ops</h4>
<p>Enter single- and double-precision floating point values into object code. These would accept only literal data, not expressions. Floating point numbers could still not be used in expressions HXA could evaluate.</p>
<p>The default format would be IEEE 744.</p>
<p>Add an ASSUME float:(format) to the list of acceptable assumptions. CPU handler modules would implement their own recognized formats.</p>
<h4>INCRAW pseudo op</h4>
<p>Include files in .RAW format.</p>
<a id="L1AD"></a><h3>Assembler Messages</h3>
<table><caption>Default Message Texts</caption> <thead><tr><th>Index</th><th>Text</th></tr></thead><tbody>
<p><tr><td colspan="2">&nbsp;</td></tr> <tr><th colspan="2">Internal Error/Debug</th></tr> <tr><td colspan="2">&nbsp;</td></tr> <tr><td>BadMsg</td><td>Expanded text not found</td></tr> <tr><td>NoWay</td><td>Can't happen</td></tr> <tr><td>Debug</td><td>Debug called by</td></tr></p>
<p><tr><td colspan="2">&nbsp;</td></tr> <tr><th colspan="2">General Status</th></tr> <tr><td colspan="2">&nbsp;</td></tr> <tr><td>Fread</td><td>Reading</td></tr> <tr><td>Fwrite</td><td>Writing</td></tr> <tr><td>BegOne</td><td>Pass One started</td></tr> <tr><td>EndOne</td><td>Pass One ended</td></tr> <tr><td>BegTwo</td><td>Pass Two started</td></tr> <tr><td>EndTwo</td><td>Pass Two ended</td></tr> <tr><td>Quit</td><td>Assembly halted</td></tr></p>
<p><tr><td colspan="2">&nbsp;</td></tr> <tr><th colspan="2">Warning/Error/Fatal</th></tr> <tr><td colspan="2">&nbsp;</td></tr> <tr><td>ErrFile</td><td>Error file</td></tr> <tr><td>Warn</td><td>Warning in</td></tr> <tr><td>Error</td><td>Error in</td></tr> <tr><td>Fatal</td><td>Fatal error in</td></tr> <tr><td>Fault</td><td>Detail</td></tr> <tr><td>NoFault</td><td>No detail</td></tr> <tr><td>HaveWarn</td><td>Warnings detected</td></tr> <tr><td>HaveErr</td><td>Errors detected</td></tr> <tr><td>HaveFatal</td><td>Fatal error detected</td></tr> <tr><td>BadOp</td><td>While processing CPU mnemonic</td></tr> <tr><td>BadMacro</td><td>While processing macro</td></tr> <tr><td>BadPsop</td><td>While processing pseudo opcode</td></tr> <tr><td>BadLabel</td><td>While processing label</td></tr> <tr><td>BadLine</td><td>While processing line</td></tr> <tr><td>BadAssert</td><td>Assertion failed</td></tr> <tr><td>BadAssume</td><td>Unrecognized assumption</td></tr></p>
<p><tr><td colspan="2">&nbsp;</td></tr> <tr><th colspan="2">File</th></tr> <tr><td colspan="2">&nbsp;</td></tr> <tr><td>NoFile</td><td>File not found</td></tr> <tr><td>NotOpen</td><td>Can't open file</td></tr> <tr><td>CircInc</td><td>Current file still being read</td></tr> <tr><td>PrevInc</td><td>Current file already included</td></tr> <tr><td>BinTrunc</td><td>Binary bytes actually read</td></tr></p>
<p><tr><td colspan="2">&nbsp;</td></tr> <tr><th colspan="2">Token</th></tr> <tr><td colspan="2">&nbsp;</td></tr> <tr><td>Ignored</td><td>Unexpected token(s) ignored</td></tr> <tr><td>BadToken</td><td>Unexpected token</td></tr> <tr><td>BadField</td><td>Expecting expression</td></tr></p>
<p><tr><td colspan="2">&nbsp;</td></tr> <tr><th colspan="2">Expected Token Not Found</th></tr> <tr><td colspan="2">&nbsp;</td></tr> <tr><td>NeedToken</td><td>Expecting label or opcode</td></tr> <tr><td>NeedOpcode</td><td>Expecting opcode</td></tr> <tr><td>NeedChr</td><td>Expecting character value</td></tr> <tr><td>NeedCond</td><td>Expecting conditional expression</td></tr> <tr><td>NeedFile</td><td>Expecting filename</td></tr> <tr><td>NeedGlobal</td><td>Expecting global name</td></tr> <tr><td>NeedHex</td><td>Expecting hex character pairs</td></tr> <tr><td>NeedLabel</td><td>Expecting label</td></tr> <tr><td>NeedVarble</td><td>Expecting variable name</td></tr> <tr><td>NeedNum</td><td>Expecting numeric expression</td></tr> <tr><td>NeedNumNam</td><td>Expecting numeric name</td></tr> <tr><td>NeedNumVal</td><td>Expecting constant numeric expression</td></tr> <tr><td>NeedStr</td><td>Expecting string expression</td></tr> <tr><td>NeedStrNam</td><td>Expecting string name</td></tr> <tr><td>NeedRegex</td><td>Expecting regular expression pattern</td></tr> <tr><td>NeedEqu</td><td>Expecting equate pattern</td></tr> <tr><td>NeedXlt</td><td>Expecting translate pattern</td></tr> <tr><td>NeedPos</td><td>Expecting positive value</td></tr> <tr><td>NeedCond</td><td>Expecting conditional expression</td></tr></p>
<p><tr><td colspan="2">&nbsp;</td></tr> <tr><th colspan="2">Expression Parse and Evaluation</th></tr> <tr><td colspan="2">&nbsp;</td></tr> <tr><td>BadEOE</td><td>Unexpected end of expression</td></tr> <tr><td>BadRgtPar</td><td>Unmatched right parenthesis</td></tr> <tr><td>BadLftPar</td><td>Unmatched left parenthesis</td></tr> <tr><td>NeedOperand</td><td>Expecting operand</td></tr> <tr><td>NeedOperator</td><td>Expecting operator</td></tr> <tr><td>NeedFunction</td><td>Expecting function name</td></tr> <tr><td>NeedCall</td><td>Expecting function call</td></tr> <tr><td>BadFunction</td><td>Unknown function name</td></tr> <tr><td>BadFncEval</td><td>Incomplete evaluation</td></tr> <tr><td>BadArgCnt</td><td>Unexpected argument count</td></tr> <tr><td>BadArgSep</td><td>Unexpected comma</td></tr> <tr><td>BadType</td><td>Unexpected type</td></tr> <tr><td>DivZero</td><td>Divide by zero</td></tr> <tr><td>BadTrnry1</td><td>Unmatched '?' operator</td></tr> <tr><td>BadTrnry2</td><td>Unmatched ':' operator</td></tr> <tr><td>BadValStr</td><td>Expecting non-null string</td></tr></p>
<p><tr><td colspan="2">&nbsp;</td></tr> <tr><th colspan="2">CPU Instruction Set</th></tr> <tr><td colspan="2">&nbsp;</td></tr> <tr><td>BadCPU</td><td>CPU not recognized</td></tr> <tr><td>NoCPU</td><td>CPU type not set</td></tr> <tr><td>BadMode</td><td>Address mode not recognized</td></tr></p>
<p><tr><td colspan="2">&nbsp;</td></tr> <tr><th colspan="2">Segment / Program Counter</th></tr> <tr><td colspan="2">&nbsp;</td></tr> <tr><td>BadPC</td><td>Invalid program counter</td></tr> <tr><td>SegIsAO</td><td>Segment is absolute origin</td></tr> <tr><td>SegIsRO</td><td>Segment is relative origin</td></tr> <tr><td>SegIsAE</td><td>Segment is absolute end</td></tr> <tr><td>SegIsRE</td><td>Segment is relative end</td></tr> <tr><td>SegIsID</td><td>Segment is initialized</td></tr> <tr><td>SegIsND</td><td>Segment is uninitialized</td></tr> <tr><td>SegIsPT</td><td>Segment is pad to</td></tr> <tr><td>SegIsPF</td><td>Segment is pad from</td></tr> <tr><td>SegIsCO</td><td>Segment is common</td></tr> <tr><td>SegDfltName</td><td>Segment #</td></tr> <tr><td>BadSegUse</td><td>Program cannot be both monolithic and segmented</td></tr> <tr><td>BadSegOut</td><td>Legal only inside segment fragment</td></tr> <tr><td>BadSegAbs</td><td>Cannot make segment absolute</td></tr> <tr><td>BadSegTmplt</td><td>Invalid filename template</td></tr></p>
<p><tr><td colspan="2">&nbsp;</td></tr> <tr><th colspan="2">Symbol Table</th></tr> <tr><td colspan="2">&nbsp;</td></tr> <tr><td>RsrvName</td><td>Reserved name</td></tr> <tr><td>UndefName</td><td>Name not found</td></tr> <tr><td>DupName</td><td>Duplicate name</td></tr></p>
<p><tr><td colspan="2">&nbsp;</td></tr> <tr><th colspan="2">Block Processing</th></tr> <tr><td colspan="2">&nbsp;</td></tr> <tr><td>NeedMacName</td><td>Expecting macro name</td></tr> <tr><td>NeedArgDflt</td><td>Expecting default argument value</td></tr> <tr><td>NeedArgName</td><td>Expecting formal argument name</td></tr> <tr><td>NeedMatch</td><td>Name does not match</td></tr> <tr><td>NeedArgVal</td><td>Expecting actual argument value</td></tr> <tr><td>BadDef</td><td>Definition ignored</td></tr> <tr><td>BadBlock</td><td>Matching block structure not found</td></tr> <tr><td>BadOpenBlk</td><td>Unclosed open block structure</td></tr> <tr><td>BadNestBlk</td><td>Unclosed nested block within block expansion</td></tr> <tr><td>BadOutExp</td><td>Allowed only within block expansion</td></tr> <tr><td>BadInExp</td><td>Not allowed within block expansion</td></tr></p>
<p><tr><td colspan="2">&nbsp;</td></tr> <tr><th colspan="2">Listing</th></tr> <tr><td colspan="2">&nbsp;</td></tr> <tr><td>ListFile</td><td>Listing File</td></tr> <tr><td>InsSet</td><td>Instruction Set</td></tr> <tr><td>InsAny</td><td>Unspecified</td></tr> <tr><td>Source</td><td>Source file</td></tr> <tr><td>PrgType</td><td>Program Type</td></tr> <tr><td>IsSeg</td><td>Segmented</td></tr> <tr><td>IsMono</td><td>Monolithic</td></tr> <tr><td>NoRecord</td><td>   (No data recorded)</td></tr> <tr><td>OBJ</td><td>Object Code Listing</td></tr> <tr><td>LBL</td><td>Symbol Table Listing</td></tr> <tr><td>XRF</td><td>Cross-Reference Listing</td></tr> <tr><td>SEG</td><td>Segment Map Listing</td></tr> <tr><td>STS</td><td>	Assembly Statistics Listing</td></tr> <tr><td>Glbl</td><td>Global Labels</td></tr> <tr><td>Auto</td><td>Local, Variable and Anonymous Labels</td></tr> <tr><td>NumAlpha</td><td>Numeric Name     Ref Cnt    Hex Value    Dec Value</td></tr> <tr><td>NumValue</td><td>Numeric Value    Ref Cnt    Hex Value    Dec Value</td></tr> <tr><td>NAformat</td><td> {:<18} {:^4s}   ${:>9s} {:>12d}</td></tr> <tr><td>StrAlpha</td><td>String Name      Ref Cnt   Value</td></tr> <tr><td>SAformat</td><td> {:<18} {:^4s}   "{}"</td></tr> <tr><td>Mac</td><td>Macros</td></tr> <tr><td>MacAlpha</td><td>Name            Exp Cnt</td></tr> <tr><td>MacFormat</td><td> {:<18} {:>3s}</td></tr> <tr><td>XrefAlpha</td><td>Event Listing# Source#  File</td></tr> <tr><td>SegCols</td><td>Num - Name       Hex Value    Dec Value</td></tr> <tr><td>SegNumNam</td><td>{:03} - {}</td></tr> <tr><td>SegOff</td><td> Object Offset  ${:>9s}  {:>11s}</td></tr> <tr><td>SegBeg</td><td> Start Address  ${:>9s}  {:>11s}</td></tr> <tr><td>SegLen</td><td>   Byte Length..${:>9s}  {:>11s}</td></tr> <tr><td>SegEnd</td><td>   End Address..${:>9s}  {:>11s}</td></tr> <tr><td>BadPagFmt</td><td>Invalid Page Format</td></tr> <tr><td>__PassOne</td><td>Pass One time</td></tr> <tr><td>__PassTwo</td><td>Pass Two time</td></tr> <tr><td>SrcLines</td><td>    Source Lines</td></tr> <tr><td>ExpLines</td><td> Expansion Lines</td></tr> <tr><td>TotLines</td><td>     Total Lines</td></tr> <tr><td>LinesSec</td><td>Lines per second</td></tr> <tr><td>DataVals</td><td>    Data values stored</td></tr> <tr><td>ValsSec</td><td>Resolutions per second</td></tr> <tr><td>ObjSize</td><td>Object Bytes</td></tr></p>
<p><tr><td colspan="2">&nbsp;</td></tr> <tr><th colspan="2">Range Errors</th></tr> <tr><td colspan="2">&nbsp;</td></tr> <tr><td>BadRngLo</td><td>Value less than minimum</td></tr> <tr><td>BadRngHi</td><td>Value greater than maximum</td></tr> <tr><td>BadRange</td><td>Value is out of range</td></tr></p>
<p><tr><td colspan="2">&nbsp;</td></tr> <tr><th colspan="2">Over Internal Limit</th></tr> <tr><td colspan="2">&nbsp;</td></tr> <tr><td>maxwarn</td><td>Warning count</td></tr> <tr><td>maxerr</td><td>Error count</td></tr> <tr><td>maxloop</td><td>Loop body count</td></tr> <tr><td>maxdepth</td><td>Block nesting depth</td></tr> <tr><td>maxputback</td><td>Putback line count</td></tr> <tr><td>maxseg</td><td>Segment count</td></tr> <tr><td>maxstack</td><td>User stack depth</td></tr></p>
<p><tr><td colspan="2">&nbsp;</td></tr> <tr><th colspan="2">Output Line Prefix</th></tr> <tr><td colspan="2">&nbsp;</td></tr> <tr><td>OutPfx</td><td>; &ast;&ast;&ast;</td></tr> <tr><td>ErrPfx</td><td>; >>>>></td></tr> <tr><td>ErrPfx2</td><td>; -</td></tr> <tr><td>ErrPfx3</td><td>;</td></tr> <tr><td>ErrPfx4</td><td>; >>> In</td></tr> <tr><td>InfoPfx</td><td>&ast;&ast;&ast;&ast;&ast;</td></tr> <tr><td>EquIfx</td><td>=</td></tr> <tr><td>InIfx</td><td>in</td></tr></p>
<p><tr><td colspan="2">&nbsp;</td></tr> <tr><th colspan="2">Miscellaneous</th></tr> <tr><td colspan="2">&nbsp;</td></tr> <tr><td>UniqVal</td><td>Value already set</td></tr> <tr><td>OddVal</td><td>Unusual value</td></tr> <tr><td>OddUse</td><td>Unusual use</td></tr> <tr><td>NoEffect</td><td>No effect</td></tr> <tr><td>TimerReset</td><td>Timer reset to zero</td></tr> <tr><td>StkEmpty</td><td>User stack empty</td></tr> <tr><td>StkNotEmpty</td><td>User stack not empty</td></tr> <tr><td>TotTime</td><td>Total Time</td></tr> </tbody></table></p>
<a id="L1AE"></a><h3>History</h3>
<h4>v0.10 - October 2004</h4>
<p><b>All Versions</b></p>
<ul> <li>initial release</li>
 </ul>
<p><b>HXA65 Version</b></p>
<ul> <li>6502, 65C02, R65C02 and W65C02S processors supported</li>
 </ul>
<h4>v0.11 - March 2005</h4>
<p><b>All Versions</b></p>
<p><em>Added</em></p>
<ul> <li>WHILE..ENDWHILE conditional pseudo ops</li>
 <li>RBIT--, SBIT-- and UBIT-- ranged data storage pseudo ops</li>
 <li>built-in __VER__ symbol</li>
 </ul>
<p><em>Deprecated</em></p>
<ul> <li>built-in VER() function</li>
 </ul>
<p><em>Bug Fix - Modulus Operator</em></p>
<ul> <li>then: "%0" and "%1" always interpreted as binary numbers</li>
 <li>now: always correctly interpreted in context as either binary numbers or modulus operators</li>
 </ul>
<p><em>Bug Fix - Erroneous Nested IF Evaluation</em></p>
<ul> <li>then: a nested IF condition in a false ELSE branch could be evaluated (and if true its branch processed) when the nesting depth became greater than in the companion true IF branch of the ELSE</li>
 <li>now: IF conditions nested in false ELSE branches are always ignored</li>
 </ul>
<p><b>HXA65 Version</b></p>
<p><em>Added</em></p>
<ul> <li>W65C816S processor support</li>
 </ul>
<h4>v0.12 - August 2005</h4>
<p><b>All Versions</b></p>
<p><em>Added</em></p>
<ul> <li>SEGMENT and ENDSEGMENT pseudo ops to create segmented source code</li>
 <li>PADTO pseudo op to insert $00 bytes until reaching a modular byte boundary</li>
 <li>HEXFILE pseudo op to create Intel format hexadecimal output files</li>
 <li>MAXDEPTH pseudo op to limit local scope nesting depth</li>
 </ul>
<p><em>Extended</em></p>
<ul> <li>ASSUME pseudo op support for modifying the default behavior of HEXFILE</li>
 <li>END pseudo op now accepts an expression which is interpreted as a start address to be written to an Intel hexadecimal output file</li>
 <li>the same global label can be assigned the same value any number of times</li>
 <li>the same local label in the same local scope can be assigned the same value any number of times</li>
 </ul>
<p><em>Bug Fix - Byte at Highest Processor Address</em></p>
<ul> <li>then: placing a byte at the highest processor address advanced the internal program counter past that address, which triggered a fatal error</li>
 <li>now: the program counter is allowed to have a value one past the highest legal processor address, as long as no attempt is made to store anything at that address</li>
 </ul>
<p><em>Bug Fix - Unrecognized LIST-- Option</em></p>
<ul> <li>then: unrecognized LIST-- options triggered warnings both when first encountered while reading the source code and later during actual listing</li>
 <li>now: unrecognized LIST-- options trigger warnings only when first encountered while reading the source code</li>
 </ul>
<h4>v0.121 - May 2006</h4>
<p><b>All Versions</b></p>
<p><em>Extended</em></p>
<ul> <li>label, macro and pseudo-op alias names can now contain period characters, as long as each one is surrounded by alphanumeric characters</li>
 <li>string arguments of the CPU, ECHO, MESGTEXT, PSALIAS and XLATE psops now work like arguments of the ASSUME psop, in that delimiting double quote marks are are optional, but if present the string must be non-null and any escape sequences are processed</li>
 <li>the ECHO pseudo op now outputs a blank line if no argument is supplied</li>
 <li>the STATS list option produces more detail</li>
 </ul>
<p><em>Error Detection</em></p>
<ul> <li>attempting to define a macro with an illegal name in the label field no longer causes a second (cascade) error when "ENDMACRO" is encountered</li>
 <li>some internal routines now attempt to examine every sub-field of the expression field rather than giving up after the first error is detected</li>
 </ul>
<p><em>Bug Fix - Escaped Backslash</em></p>
<ul> <li>then: a "created" escape sequence consisting of a replaced escaped backslash and the immediately following character was itself replaced if the same sequence also occurred later in the string</li>
 <li>now: "created" escape sequences formed during escape code replacement are never themselves replaced</li>
 </ul>
<p><em>Bug Fix - Escaped Double Quote Mark</em></p>
<ul> <li>then: any double quote mark immediately preceeded by one or more escape characters was considered escaped, which is not correct if the number of escape characters is even</li>
 <li>now: a double quote mark is escaped only when immediately preceeded by an odd number of escape characters</li>
 </ul>
<h4>v0.122 - May 2006</h4>
<p><b>All Versions</b></p>
<p><em>Bug Fix - Leftover Debug Code</em></p>
<ul> <li>then: v0.121 expression parsing copied each token found to a check file</li>
 <li>now: debug code removed</li>
 </ul>
<h4>v0.130 - October 2006</h4>
<p><b>All Versions</b></p>
<p><em>Added</em></p>
<ul> <li>string labels (global, local and variable)</li>
 <li>string concatenation (implied operator)</li>
 <li>logical function: FORWARD()</li>
 <li>numeric functions: INDEX() , INDEXR() , LEN() , ORD() , VAL()</li>
 <li>string functions: CHR$() , LOWER$() , MATCH$() , MID$() , STR$() , UPPER$()</li>
 </ul>
<p><em>Extended</em></p>
<ul> <li>the ASSUME, CPU, ECHO, MESGTEXT, PSALIAS and XLATE pseudo ops now accept string expressions in place of string literals. If an argument starts with a string literal, label or function then it is assumed to be a string expression and escapes are processed; otherwise it is accepted as-is</li>
 <li>the ERROR, FATAL and WARN pseudo ops also now optionally accept the same string/not string expression argument as above. If an argument is supplied it is displayed as part of the last line of the error message</li>
 <li>in the expression field a comma character does not divide arguments if it appears between balanced parentheses, in addition to the previous cases of being escaped or within a string literal</li>
 <li>block nesting enforcement is now applied to segment fragments, include files and macro, repeat and while block expansions (instead of just their definitions). When a block closes any blocks opened after it which are still open are flagged as errors</li>
 </ul>
<p><em>Changed</em></p>
<ul> <li>the --FILE and INCLUDE pseudo ops now accept string expressions to specify filenames, which subjects them to escape processing (filenames delimited by angle-brackets remain unaffected by escape processing)</li>
 <li>use of the INCLUDE pseudo op within a macro, repeat or while block expansion is now treated as an error instead of merely issuing a warning (this assists block nesting enforcement)</li>
 <li>characters in ECHO arguments and all other assembler messages which are not printable ASCII are replaced by a "[xx]" sequence, where 'xx' is a two-character ASCII representation of the hexadecimal value of the replaced character</li>
 <li>the logical-AND ('&&') and logical-OR ('||') operators now short-circuit , skipping over their right-hand side arguments without evaluating them if the final result can be determined solely from the left-hand side result</li>
 </ul>
<p><em>Bug Fix - Source Line Count</em></p>
<ul> <li>then: the source line count reported in the statistics portion of a listing did not count lines from any included files</li>
 <li>now: all lines from all user source files are counted</li>
 </ul>
<p><em>Partial Bug Fix - Unbalanced IF Blocks Within Block Expansions</em></p>
<ul> <li>then: in order to allow the EXIT pseudo op to be used inside an IF block, at the end of every block expansion the IF nesting level was set back to whatever it was at the start of the expansion, which could cause "IF without ENDIF" errors in a block definition to be ignored even if EXIT was not used</li>
 <li>now: unbalanced IF blocks in block expansions might be ignored only if EXIT is actually executed in that block</li>
 </ul>
<h4>v0.140 - April 2007</h4>
<p><b>All Versions</b></p>
<p><em>Added</em></p>
<ul> <li>HEX data storage pseudo op</li>
 </ul>
<p><em>Extended</em></p>
<ul> <li>the upper limit of the numeric argument supplied to PADTO has been raised from 512 to the maximum value of the program counter plus one, which makes padding to specific address values possible (thanks to <b>Dave Plummer</b>  for provoking a re-thinking of this pseudo op)</li>
 <li>hexadecimal numeric literals and escape sequences may now be expressed C-style (ie., with an '0x' prefix) in addition to Motorola and Intel styles</li>
 <li>in segmented source the ORG that makes the first segment absolute can now occur in any fragment of it before the end of the source, rather than being required before data is stored in any other segment (it still must occur before any data is stored in the first segment)</li>
 </ul>
<p><em>Bug Fix - PADTO Pseudo Op</em></p>
<ul> <li>then: PADTO could be used even if the program counter had an indeterminate value, leading to unpredicatable behavior since it depends on the program counter to decide how much to padding to add</li>
 <li>now: PADTO triggers a fatal error if the program counter is invalid when its use is attempted (the same as all other pseudo ops that depend on the program counter)</li>
 </ul>
<p><em>Bug Fix - Listing Long Source Lines</em></p>
<ul> <li>then: single source lines with a sufficiently long run of non-space characters caused the listing routine to go into an infinite loop as it tried to chop them down for listing on multiple consecutive lines</li>
 <li>now: long runs of non-space characters are properly listed on consecutive lines (thanks to <b>Dave Plummer</b>  for finding this bug)</li>
 </ul>
<p><em>Bug Fix - Labels In Nested Repeat Control Expressions</em></p>
<ul> <li>then: control expressions of nested repeat loops were evaluated prematurely, leading to incorrect error reports if a label in the expression received a value only after that point</li>
 <li>now: evaluation of control expressions of repeat loops occurs only when they are actually needed</li>
 </ul>
<h4>v0.150 - October 2007</h4>
<p><b>All Versions</b></p>
<p><em>Added</em></p>
<ul> <li>ternary conditional operator ("?:") in numeric expressions</li>
 <li>INCBIN pseudo op to include binary file data</li>
 <li>READONCE pseudo op to prevent multiple inclusions of a source file</li>
 <li>EXITIF pseudo op to permit simple conditional exit from block expansions</li>
 <li>COMMON pseudo op to help manage "scratch" memory in segmented programs</li>
 <li>non-zero error codes returned at program exit if error(s) detected</li>
 </ul>
<p><em>Extended</em></p>
<ul> <li>macro formal arguments may now also be variable and local labels, which at expansion time are treated as the left-hand side of an implied "EQU" pseudo op, with the actual argument treated as the right-hand side</li>
 <li>the OBJECT list flag can now be used to turn on and off listing of whole sections of source code regardless of whether any data was generated by lines within <em>OFF</em> sections</li>
 <li>the PADTO pseudo op now accepts an optional argument which specifies the value it should pad the object code with</li>
 </ul>
<p><em>Changed</em></p>
<ul> <li>all status and error messages are now sent to <em>stdout</em>, which can be redirected to avoid or capture all screen (console) output</li>
 </ul>
<p><em>Bug Fix - Object Filename Extension</em></p>
<ul> <li>then: v0.140 code changes resulted in the default filename created by the OBJFILE pseudo op not having any extension</li>
 <li>now: the default filename created by the OBJFILE pseudo op has an 'OBJ' extension (again)</li>
 </ul>
<p><b>HXA65 Version</b></p>
<p><em>Extended</em></p>
<ul> <li>the ASSUME pseudo op now accepts "zeropage:", "directpage:" and "databank:" options to inform HXA65 that the default location of these has been changed (for processors or systems that allow this)</li>
 <li>the string following "accum:" or "index:" in an ASSUME pseudo op is now treated as a numeric expression</li>
 </ul>
<p><em>Changed</em></p>
<ul> <li>a single legal address mode for an instruction is now determined before any address mode forcing is applied rather than after, which disallows a few previously allowed forcings from a mode that would normally be illegal to a legal one (all to or from a W65C816S long indirect mode)</li>
 </ul>
<p><em>Bug Fix - DEA and INA Instruction Aliases (65C02 and Above)</em></p>
<ul> <li>then: treated as "accumulator" mode instructions, which allows the expression field to be blank (which is correct) or to contain the literal character 'A' (which is not)</li>
 <li>now: treated as "implied" mode instructions, which allows only a blank expression field and matches all the other register increment/decrement instructions</li>
 </ul>
<h4>v0.160 - February 2008</h4>
<p><b>All Versions</b></p>
<p><em>Added</em></p>
<ul> <li>PSNULL customization pseudo op to aid porting source code when HXA has no equivalent pseudo op suitable for aliasing</li>
 <li>SEGBEG(), SEGEND(), SEGLEN() and SEGOFF() functions to allow source code access to segment absolute addresses, sizes and byte offsets within the raw binary object file</li>
 <li>ABSEND and RELEND pseudo ops to allow aligning segments by their end addresses rather than starting</li>
 <li>RELORG pseudo op to explicitly declare a relative origin segment</li>
 </ul>
<p><em>Extended</em></p>
<ul> <li>the INDEX() , INDEXR() , MATCH$() and MID$() functions now accept a negative value for the start position, which is interpreted as an offset from the right end of the affected string argument rather than the left</li>
 <li>comma characters (",") no longer need to be escaped to be recognized in character literals (though they still can be, if desired)</li>
 <li>"ABSORG", "$=" and "&ast;=" (if it does not start in the first column of a line) are now all accepted as aliases for "ORG" .</li>
 </ul>
<p><em>Changed</em></p>
<ul> <li>a leading "&ast;" character now indicates a comment line only if it occupies the first column of a line (instead of simply being the first non-whitespace character on the line)</li>
 </ul>
<p><em>Error Detection</em></p>
<ul> <li>macro definition and expansion routines now attempt to examine every argument in the expression field rather than giving up after the first error is detected</li>
 <li>expression parsing now displays expressions which end unexpectedly in their entirety, which helps identify them if there are several expressions on one source line</li>
 <li>nested block structures which are opened but not closed before the nesting block is closed now cause a fatal error (instead of simply an error)</li>
 <li>the STR$() function now causes an error if its argument is outside the range of a 32-bit signed integer and returns the null string</li>
 </ul>
<p><em>Bug Fix - ONEXPAND Error Message Text</em></p>
<ul> <li>then: the error message displayed if the ONEXPAND pseudo op was used outside of a macro expansion was incorrect</li>
 <li>now: a correct error message is displayed</li>
 </ul>
<p><em>Bug Fix - STR$() Function</em></p>
<ul> <li>then: STR$() failed with a misleading error message if its numeric argument was a label which had been assigned the minimum integer value specified in decimal (but not binary or hexadecimal)</li>
 <li>now: STR$() properly converts the minimum integer value no matter how it is specified</li>
 </ul>
<h4>v0.161 - July 2008</h4>
<p><b>All Versions</b></p>
<p><em>Extended</em></p>
<ul> <li>segment nesting is now allowed</li>
 <li>the list file segment map now reports the type of each segment</li>
 <li>the END pseudo op now always warns if used within any open block structure (which makes clearer why some unclosed block errors occur)</li>
 </ul>
<p><em>Bug Fix - Source Line in Error Messages</em></p>
<ul> <li>then: v0.160 changes sometimes resulted in error messages showing the wrong source line as the cause if the error was not detected immediately but only after additional source lines had been read</li>
 <li>now: the source line actually responsible is always displayed (again)</li>
 </ul>
<h4>v0.162 - February 2009</h4>
<p><b>All Versions</b></p>
<p><em>Extended</em></p>
<ul> <li>the MACRO (in the preferred form), --SEGMENT , --TIMER and UNDEF pseudo ops now optionally accept string expressions which evaluate to global-style names as well as literal global-style names</li>
 </ul>
<p><em>Error Detection</em></p>
<ul> <li>errors detected during definition of macro, repeat and while blocks now cause a "definition ignored" warning (the blocks cannot be expanded)</li>
 <li>errors reported during expansion of macro, repeat or while blocks now show the source lines which activated every currently open block, rather than just the one which activated the outermost open block</li>
 </ul>
<p><em>Bug Fix - Source Line in Error Messages</em></p>
<ul> <li>then: the v0.161 fix to this problem still did not always report the proper source line if delayed error detection occurred in a nested block</li>
 <li>now: the source line actually responsible is always displayed (again)</li>
 </ul>
<h4>v0.163 - July 2009</h4>
<p><b>All Versions</b></p>
<p><em>Extended</em></p>
<ul> <li>the ORD() function now accepts an optional second argument, a numeric value which is the index of the character in the string argument to apply the function to</li>
 <li>in expressions, global name arguments may now be specified by string expressions wherever a name is required</li>
 <li>the IF and ELSEIF , WHILE and EXITIF conditional pseudo ops now accept string expressions</li>
 <li>the conditional branch of the ternary conditional now accepts string expressions</li>
 <li>the true and false branches of the ternary conditional now accept string, global name and regular expressions when these are correct in context</li>
 <li>the STRING and STRINGR pseudo ops now accept any number of mixed string and numeric expressions as arguments</li>
 <li>the LIST-- pseudo ops now accept a "LINENUMS" flag to consecutively number each line of a listing</li>
 <li>the END pseudo op can now be used within an "INCLUDE" file (with a warning) but has no effect</li>
 </ul>
<p><em>Changed</em></p>
<ul> <li>v0.162 moved segment fix-up to the second pass but did not stop processing if errors were discovered, which meant additional error reports might be correct or might just be cascade errors</li>
 <li>if segment fix-up errors are discovered further code resolution is skipped</li>
 </ul>
<h4>v0.170 - April 2010</h4>
<p><b>All Versions</b></p>
<p><em>Added</em></p>
<ul> <li>PUTBACKS pseudo op to push a string expression evaluated at assembly time back onto the input (so it becomes the next input line)</li>
 <li>MAXPUTBACK pseudo op to limit the number of consecutive lines that may be pushed back (to avoid infinite looping)</li>
 <li>UNINITIALIZED pseudo op to explicitly declare that a segment does not hold data and prevent any data storage to it</li>
 <li>FILL pseudo op to insert an arbitrary number of constant bytes into the object code</li>
 <li>SRECFILE pseudo op to create Motorola format hexadecimal output files</li>
 <li>--BYSEG pseudo ops to allow segmented programs to output each data-containing segment as a separate file</li>
 <li>--BYBLOCK pseudo ops to allow segmented programs to output each contiguous group of data-containing segments as a separate file</li>
 <li>PAGESIZE , MARGINS and LINESPACE pseudo ops to allow greater control over listing format</li>
 </ul>
<p><em>Extended</em></p>
<ul> <li>the UNDEF pseudo op now accepts multiple macro names for deletion</li>
 <li>the DS and COMMON pseudo ops now implicitly declare a segment UNINITIALIZED as well</li>
 <li>hexadecimal opt-strings of the type used in arguments to the HEX , FILL and PADTO pseudo ops now optionally accept a radix indicator</li>
 <li>ASSUME pseudo op support for modifying the default formats of Motorola hexadecimal output files</li>
 <li>the general upper limit of numeric calculations has been extended from 2^31-1 to 2^32-1 (the allowed range now covers all signed and unsigned 32-bit integers)</li>
 <li>the general upper limit of the program counter has been extended from 2^31 to 2^32 (full 32-bit program counters are now allowed)</li>
 <li>the RBIT--, SBIT-- and UBIT-- ranged data storage pseudo ops now have 32-bit types to go along with the previous 8-, 16- and 24-bit variants</li>
 <li>the logical short circuit operators '&&' and '||' now accept string expressions as operands</li>
 <li>the unary arithmetic, bitwise and logical operators can now be applied to string operands (which are first implicitly compared to the null string)</li>
 <li>the LIST-- pseudo ops now accept a "LINEWRAP" flag to control whether text too long to list on one line is wrapped or truncated</li>
 </ul>
<p><em>Changed</em></p>
<ul> <li>the ONEXPAND pseudo op is now an alias of PUTBACK</li>
 <li>the optional second argument of the PADTO pseudo op, which specifies the value to pad with, is now a hexadecimal opt-string</li>
 <li>binary and hexadecimal numeric literals are now interpreted as unsigned rather than signed values, which matches what decimal numeric literals have always been (and like them can be negated with the unary '-' operator)</li>
 <li>decimal literals which are out of 32-bit unsigned range can no longer be used (intermediate values during expression evaluation still can be, however)</li>
 <li>the precedence of the unary extract operators has been raised to that of the other unary operators, and like them now affect only the operand to their immediate right (use parentheses to create a larger "operand")</li>
 </ul>
<p><em>Error Detection</em></p>
<ul> <li>global labels in macro definitions no longer cause a warning during macro expansion if they appear on a line by themselves (this facilitates one-time-use label creation by PUTBACKS ; an error will still occur if more than one value is ever assigned to such a label)</li>
 </ul>
<p><em>Deprecated</em></p>
<ul> <li>built-in '__VER__' symbol (use VER() function instead)</li>
 </ul>
<p><em>Bug Fix - DS Pseudo Op in Segmented Programs</em></p>
<ul> <li>then: the DS pseudo op could be used in initialized segments, which caused incorrect segment size and offset information to be reported for them</li>
 <li>now: the DS pseudo op can be used only in uninitialized segments</li>
 </ul>
<p><em>Bug Fix - SEGOFF() Function and Uninitialized Segments</em></p>
<ul> <li>then: the SEGOFF() function reported an offset value in the object file for every non-common segment, which could cause incorrect results for all segments following an uninitialized non-common segment</li>
 <li>now: uninitialized segments whether explicitly or implicitly declared have no offset value in the object file</li>
 </ul>
<p><em>Bug Fix - More than 64K Object Code in Intel Hexadecimal Output Files</em></p>
<ul> <li>then: in 20- and 32-bit Intel hexadecimal output files, the offset value field of a data record could exceed its 16-bit limit</li>
 <li>now: a new extended address record is written to the output file whenever the offset value plus the data size of the next record exceeds 64K</li>
 </ul>
<p><em>Bug Fix - First Character of Records in Intel Hexadecimal Output Files</em></p>
<ul> <li>then: an Ascii semi-colon (';')</li>
 <li>now: an Ascii colon (':')</li>
 </ul>
<p><em>Bug Fix - Numeric Values of Zero and One in STRING- Pseudo Ops</em></p>
<ul> <li>then: when used as numeric operands of these pseudo ops, mis-interpreted during type fixup as operators</li>
 <li>now: always correctly interpreted as operands</li>
 </ul>
<p><em>Bug Fix - Logical '&&' and '||' Short Circuiting</em></p>
<ul> <li>then: if during the first pass the left hand side expression could not be evaluated, an attempt to evaluate the right hand side would be made, which is incorrect until it is known that short-circuiting does not apply</li>
 <li>now: no attempt is made to evaluate the right hand side until the left hand side is completely evaluated and short-circuiting does not apply</li>
 </ul>
<h4>v0.180 - July 2011</h4>
<p><b>All Versions</b></p>
<p><em>Added</em></p>
<ul> <li>CPU$() , FILE$() , MESG$() , TIME$() and VER$() functions</li>
 <li>TITLE pseudo op to replace the default listing title</li>
 <li>PAGE pseudo op to force a formfeed in a listing</li>
 <li>USESEGMENTS pseudo op to explicitly declare a segmented source</li>
 <li>global labels and macro names can now be cross-referenced as part of a listing, with appearances keyed to both source and listing file lines</li>
 </ul>
<p><em>Extended</em></p>
<ul> <li>if a symbol table is included in a listing, numeric global labels are shown twice, first alphabetically (along with any variable labels) and then by value (along with any internal forms of local labels, if enabled)</li>
 <li>if a symbol table is included in a listing, defined macro names are now also shown</li>
 <li>if an object section is included in a listing, source lines are flagged to indicate if they are from include files or macro expansions or both</li>
 <li>hexadecimal escape sequences in char and string literals can now use any number of digits, per the C standard (though at most only two count)</li>
 <li>'\0' is now a recognized mnemonic escape sequence that converts to ASCII nul ($00) (no other octal or decimal numeric sequence is yet recognized)</li>
 <li>the ENDMACRO pseudo op now accepts an optional name argument, which if present must match the name of the macro being defined</li>
 <li>the ASSUME pseudo op now supports custom byte extraction orders (ie., other than the default LSB and MSB orders)</li>
 <li>a "byte" can now be 8-, 16- or 32-bits ie., the smallest size that will increase the program counter by one unit</li>
 <li>the STRING-- pseudo ops now null-pad if needed to fit 8-bit character values into 16- or 32-bit "byte" values</li>
 <li>the HEX and INCBIN pseudo ops now zero-pad if needed to fill the last 16- or 32-bit "byte" value occupied</li>
 <li>the FILL and PADTO pseudo ops now interpret their arguments in terms of 8-, 16- or 32-bit "bytes" as needed</li>
 <li>the "bit extraction" operators "&lt;", "&gt;" and "^" are now "byte-size" aware</li>
 <li>Intel and Motorola hexadecimal files now have non-standard extensions to support address-correct 16- and 32-bit "byte" output files</li>
 </ul>
<p><em>Changed</em></p>
<ul> <li>unprintable characters in output strings are now converted to C-style '\x--' sequences instead of '[--]' sequences</li>
 <li>the minimum listing page width is now zero, which acts as a flag to always print each output string on one line without wrapping or truncation</li>
 <li>the minimum listing page width for non-zero values is no longer fixed but is only required to be large enough to print at least one character of any output string plus any added indentation or line number</li>
 <li>the single quote character must now always be escaped to be recognized in a character literal</li>
 <li>for all pseudo ops which accept or require a filename argument, that argument is now an opt-string, except that any enclosing angle-brackets are always removed from both "as-is" and evaluated strings</li>
 <li>"implicit" segments in monolithic programs are now created whenever consecutive data storage occurs at non-consecutive addresses instead of whenever the program counter value decreases</li>
 <li>attempting to use the "SEGMENT" or "USESEGMENTS" pseudo ops after using "ORG" (ie., making the program monolithic) is now a fatal error rather than just an error</li>
 <li>the BYTE-, WORD- and LONG-family pseudo op aliases are now "byte size" aware</li>
 </ul>
<p><em>Error Detection</em></p>
<ul> <li>global labels in macro definitions no longer cause warnings at all during macro expansion as long as every assignment to one has the same value (but a different value will cause both a warning and an error to occur)</li>
 <li>regular expression literals are now checked to verify the presence of both characters of the metachar pairs '[]', '()' and '{}' if an unescaped opening char is detected (note this check does not guarantee the overall correctness of the expression and is meant only to avoid simple errors)</li>
 </ul>
<p><em>Bug Fix - FILL and PADTO Pseudo Ops with No Value Argument</em></p>
<ul> <li>then: defaulted to numeric zero, which the run-time package both complained about and converted to character $30 (ASCII zero)</li>
 <li>now: defaults to string null, which is correctly converted to character $00 (ASCII nul)</li>
 </ul>
<p><em>Bug Fix - C-style Escape Codes in Char and String Literals</em></p>
<ul> <li>then: only the form '\0x--' accepted, which is both incorrect form and limited in the number of digits accepted</li>
 <li>now: both '\0x--' (legacy support) and '\x--' (correct) forms accepted, with no limit on the number of digits accepted</li>
 </ul>
<p><em>Bug Fix - ECHO Pseudo Op with No Argument</em></p>
<ul> <li>then: the default null string argument rendered as a pair of double quotes due to a later change introduced to guarantee all ECHO arguments "printable"</li>
 <li>now: the default null string causes only a carriage return (again)</li>
 </ul>
<p><em>Bug Fix - Commas in Regular Expression Literals</em></p>
<ul> <li>then: argument field splitting divided regular expression literals which contained one or more commas into two or more arguments</li>
 <li>now: argument field splitting does not divide regular expression literals which contain comma characters</li>
 </ul>
<p><em>Bug Fix - Record Counts in No-Header Motorola Hexadecimal Output Files</em></p>
<ul> <li>then: if multiple output files were requested via "SRECBYSEG" or "SRECBYBLOCK" and the header record (only) suppressed, the record count in each successive output file was cumulative over all previous output files</li>
 <li>now: the record count in each output file is for that file only</li>
 </ul>
<p><em>Bug Fix - Output Files Created Despite No Data Generated</em></p>
<ul> <li>then: a source file which specified output file(s) but did not actually generate any data nonetheless created output file(s) which contained no data (but were not necessarily zero length)</li>
 <li>now: source files which generate no data do not create output files</li>
 </ul>
<h4>v.181 - January 2012</h4>
<p><b>HXA65 Version</b></p>
<p><em>Bug Fix - Relative Branch Offset Values</em></p>
<ul> <li>then: off-by-one error resulted from v0.180 changes to storage of data addresses that did not account for how HXA65 stores generated data</li>
 <li>now: relative branch calculations correct (again) (thanks to <b>dclxvi</b>  for finding this bug)</li>
 </ul>
<h4>v0.182 - June 2012</h4>
<p><b>All Versions</b></p>
<p><em>Extended</em></p>
<ul> <li>label names may now contain multiple consecutive underscore characters wherever only one was previously permitted</li>
 <li>program listing files now also show the absolute address associated with data stored using any of the 'RBIT--' (pc-relative) pseudo ops</li>
 </ul>
<p><em>Error Detection</em></p>
<ul> <li>all unrecoverable evaluation-time expression errors are now treated uniformly, reporting the error as soon as it occurs and preventing the assembly of just the source line they are found in</li>
 </ul>
<p><b>HXA65 Version</b></p>
<p><em>Bug Fix - W65C816S Incorrect Op Codes</em></p>
<ul> <li>then: opcodes for 'load long absolute x-indexed' and 'load long indirect y-indexed' were incorrect ($8-x instead of $B-x)</li>
 <li>now: opcodes are correct (thanks to <b>dclxvi</b>  for finding this bug)</li>
 </ul>
<h4>v0.190 - October 2012</h4>
<p><b>All Versions</b></p>
<p><em>Added</em></p>
<ul> <li>IFDEF and IFNDEF pseudo ops and LABEL() function to determine the presence or absence of a global numeric label in the symbol table</li>
 <li>__HXA__ built-in global numeric label</li>
 </ul>
<p><em>Extended</em></p>
<ul> <li>all user-named labels are now defined as a single type indicator character followed by zero or more alphanumeric, underscore and period characters</li>
 <li>a single colon character can now be used as a branch target label, marking a location as both a forward and a backward target</li>
 </ul>
<p><em>Error Detection</em></p>
<ul> <li>all fatal errors triggered by exceeding a maximum limit are now treated uniformly, reporting the error and displaying the value exceeded</li>
 <li>an attempt to evaluate a null expression now reports the expression type expected rather than that a null expression was found</li>
 </ul>
<p><em>Bug Fix - Local String Labels More Than 10 Characters Long</em></p>
<ul> <li>then: prior code changes led to them being treated in program listings as numeric labels of indeterminate value</li>
 <li>now: treated as string values (again)</li>
 </ul>
<p><b>HXA_T Version</b></p>
<p><em>Added</em></p>
<ul> <li>"__HXA_T__" built-in global numeric label</li>
 </ul>
<p><b>HXA65 Version</b></p>
<p><em>Added</em></p>
<ul> <li>"__HXA65__" built-in global numeric label</li>
 </ul>
<p><em>Changed</em></p>
<ul> <li>the register names "A", "S", "X" and "Y" are now reserved label names</li>
 </ul>
<h4>v0.191 - December 2012</h4>
<p><b>All Versions</b></p>
<p><em>Changed</em></p>
<ul> <li>macro names are now recognized only after a complete definition has been processed without error, instead of conditionally being recognized after a correct first line and later deleted if further processing detected other definition errors</li>
 </ul>
<p><em>Bug Fix - Defining Macro Names Ending in Colons</em></p>
<ul> <li>then: defining a macro with a name ending in a colon worked properly only if the name was declared in the expression field</li>
 <li>now: defining a macro with a name ending in a colon works properly using either the label or expression fields to declare the name</li>
 </ul>
<h4>v0.200 - August 2013</h4>
<p><b>All Versions</b></p>
<p><em>Added</em></p>
<ul> <li>PUSHS, MAXSTACK and ASSERT pseudo ops</li>
 <li>EMPTY(), PEEK$() and POP$() functions</li>
 </ul>
<p><em>Extended</em></p>
<ul> <li>binary numeric literals may now be specified using an "0b" prefix as well as the existing "%" prefix or "B" suffix variants</li>
 <li>the "READONCE" pseudo op now warns if the base filename of the current file matches a base filename previously included</li>
 <li>non-object-generating pseudo ops such as "ASSERT", "ABSEND", "DS", "END", "EQU", and "ORG" now show any values they create at the point they occur in the "OBJECT" section of a listing</li>
 <li>an "ALLEQU" flag has been added to the "LIST--" options to control the display of values assigned by equates to non-global labels in the "OBJECT" section</li>
 </ul>
<p><em>Changed</em></p>
<ul> <li>the "PUTBACKS" pseudo op now requires at least one argument, instead of reporting a warning when none are present</li>
 <li>the built-in functions "LOWER$()" and "UPPER$()" have been re-named "TOLOWER$()" and "TOUPPER$()"</li>
 </ul>
<p><em>Bug Fix - Extended Address Records in Intel Hexadecimal Output Files</em></p>
<ul> <li>then: new extended address records were written based only on whether more than 32K of data was written since the last one</li>
 <li>now: new extended address records are written if the difference between the current data record address and the current extended address is greater than 64K or less than zero, if the current data will cross a 64K offset, or if more than 32K of data has been written since the last one</li>
 </ul>
<h4>v0.201 - Unreleased</h4>
<p><b>All Versions</b></p>
<p><em>Extended</em></p>
<ul> <li>all error messages now indicate how HXA treated the source line, eg., as a mnemonic, pseudo opcode, macro invocation, etc.</li>
 </ul>
<h4>v1.000  December 2023</h4>
<p><b>All Versions</b></p>
<p><em>Added</em></p>
<ul> <li>command-line name of a dynamically loaded CPU instruction mnemonic module</li>
 <li>command-line flags '--help' and '--quiet'</li>
 <li>'#' and '//' comment markers</li>
 <li>an explicit string concatenation binary operator, the plus sign ('+', ASCII 0x2B)</li>
 <li>a string variable can now hold a regular expression pattern</li>
 <li>hexadecimal escape codes in the range 0x00 to 0xFF can only be the next two following characters</li>
 <li>Unicode and Unicode Basic Lingual Plane hexadecimal escape codes</li>
 <li>RAWFILE, RAWBYBLK and RAWBYSEG pseudo ops to allow undecorated hexadecimal text file output</li>
 <li>MAXLOOP pseudo op to disallow infinite looping in repeat and while block expansions</li>
 <li>MAXSEG pseudo op to set the number of segments that can be created</li>
 <li>PLUSEQU and MINUSEQU pseudo ops to add and subtract values from existing variable labels</li>
 <li>PADFROM segment type to allow starting a segment at an address unknown before assembly</li>
 <li>WARNON and WARNOFF pseudo ops to control console display of warning messages</li>
 <li>ABS(), DIR$(), ISLABEL(), ISMACRO(), ROOTFILE$(), and SGN() functions and aliases</li>
 <li>'printable' and 'objstr' assumptions</li>
 <li>'ascii', 'latin-1', 'utf-8', 'utf-16', 'utf-16be', 'utf-16le', 'utf-32', 'utf-32be' and 'utef-32le' assumption flags</li>
 </ul>
<p><em>Extended</em></p>
<ul> <li>there is no limit on the integer value a numeric expression can have, as long as no effort is made to store more than 32 bits of it</li>
 <li>the binary multiplication operator, '&ast;', now works on strings as well as numbers, as long as the order is 'string' &ast; 'number'</li>
 <li>ASSUME:HEXFILE now accepts a 'flat' flag to force 16-bit output records</li>
 <li>SRCFILE, SRECBYBLK and SRECBYSEG header records now include the name of the root file by default</li>
 <li>ASSUME:SRECFILE now accepts a 'noname' flag to suppress the name of the rootfile in the header record</li>
 <li>ELIF is now an alias for ELSEIF</li>
 <li>IFDEF and IFNDEF now check for macro names as well as global labels</li>
 </ul>
<p><em>Changed</em></p>
<ul> <li>assembler source language changed from Thompson AWK 5.0 to Python 3.11.4</li>
 <li>the parameter order of INCBIN has been swapped</li>
 <li>the DS pseudo opcode will not accept a negative value for the size to store</li>
 <li>PADTO is now a distinct segment type, rather than an optional attribute of an existing segment type</li>
 <li>ternary conditionals of the form expr0 ? (expr1 ? expr2 : expr3 ) : expr4 must now be explicitly parenthesized</li>
 <li>FILE$() function now returns the name of the file currently being read</li>
 </ul>
<p><em>Deprecated</em></p>
<ul> <li>MS-DOS no longer explicitly supported</li>
 <li>implicit string concatenation by placing two string operands adjacent to each other (not functional!)</li>
 <li>all caches removed</li>
 </ul>
</div></section></body></html>
