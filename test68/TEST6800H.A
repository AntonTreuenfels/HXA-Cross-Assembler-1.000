; Hobby Cross-Assembler HXA68 Error Test 6800h
; 6800\Instruction Set
; error: Group rep instructions, forced modes

; generated by MODE68.PY - Wed Jun 12 11:53:55 2024


; warning(s):

; errors(s): 568
; - unrecognized address mode
; - the 12 undetected errors (of the 580 reported by MODE68)
; are all relative address modes converted to direct/extended

; fatal:

; -------------------------------

		.listfile
		.errfile

		.maxerr	10000		; increase default count

; -------------------------------

		.cpu	6800
		.org	$1000

; -------------------------------

; backward reference

bak08	.equ	$12
bak16	.equ	$1234
bak24	.equ	$456789
bak32	.equ	$89ABCDEF

; -------------------------------

		; check ABA
		; 25 mnemonics with modes ['inh']
		; CBA
		; CLC
		; CLI
		; CLV
		; DAA
		; DES
		; DEX
		; INS
		; INX
		; NOP
		; RTI
		; RTS
		; SBA
		; SEC
		; SEI
		; SEV
		; SWI
		; TAB
		; TAP
		; TBA
		; TPA
		; TSX
		; TXS
		; WAI

		.assume addr:direct
		aba 			; force (inh -> dir)

		.assume addr:direct
		aba 	A $32	; force (dual -> dir)
		.assume addr:direct
		aba 	A bak08
		.assume addr:direct
		aba 	A $D101
		.assume addr:direct
		aba 	A bak16
		.assume addr:direct
		aba 	A fwd16

		.assume addr:direct
		aba 	B $32	; force (dual -> dir)
		.assume addr:direct
		aba 	B bak08
		.assume addr:direct
		aba 	B $D101
		.assume addr:direct
		aba 	B bak16
		.assume addr:direct
		aba 	B fwd16

		.assume addr:direct
		aba 	#$80	; force (imm -> dir)
		.assume addr:direct
		aba 	#bak08
		.assume addr:direct
		aba 	#fwd08

		.assume addr:direct
		aba 	$32		; force (dir -> dir)
		.assume addr:direct
		aba 	$00EF
		.assume addr:direct
		aba 	$abcd
		.assume addr:direct
		aba 	bak08
		.assume addr:direct
		aba 	bak24
		.assume addr:direct
		aba 	fwd32
		.assume addr:direct
		aba 	fwd16

		.assume addr:direct
		aba 	$32		; force (ext -> dir)
		.assume addr:direct
		aba 	$00EF
		.assume addr:direct
		aba 	$abcd
		.assume addr:direct
		aba 	bak08
		.assume addr:direct
		aba 	bak24
		.assume addr:direct
		aba 	fwd32
		.assume addr:direct
		aba 	fwd16

		.assume addr:direct
		aba 	X		; force (ndx -> dir)
		.assume addr:direct
		aba 	$89,X
		.assume addr:direct
		aba 	$00AB, X
		.assume addr:direct
		aba 	bak08,X
		.assume addr:direct
		aba 	fwd08, X

		.assume addr:direct
		aba 	A		; force (accx -> dir)
		.assume addr:direct
		aba 	B

		.assume addr:direct
		aba 			; force (acc -> dir)

:	; backward ref for aba

		.assume addr:direct
		aba 	:+	; force (rel -> dir)
		.assume addr:direct
		aba 	:-

:	; forward ref for aba


; -------------------------------

		.assume addr:extended
		aba 			; force (inh -> ext)

		.assume addr:extended
		aba 	A $32	; force (dual -> ext)
		.assume addr:extended
		aba 	A bak08
		.assume addr:extended
		aba 	A $D101
		.assume addr:extended
		aba 	A bak16
		.assume addr:extended
		aba 	A fwd16

		.assume addr:extended
		aba 	B $32	; force (dual -> ext)
		.assume addr:extended
		aba 	B bak08
		.assume addr:extended
		aba 	B $D101
		.assume addr:extended
		aba 	B bak16
		.assume addr:extended
		aba 	B fwd16

		.assume addr:extended
		aba 	#$80	; force (imm -> ext)
		.assume addr:extended
		aba 	#bak08
		.assume addr:extended
		aba 	#fwd08

		.assume addr:extended
		aba 	$32		; force (dir -> ext)
		.assume addr:extended
		aba 	$00EF
		.assume addr:extended
		aba 	$abcd
		.assume addr:extended
		aba 	bak16
		.assume addr:extended
		aba 	bak32
		.assume addr:extended
		aba 	fwd24
		.assume addr:extended
		aba 	fwd08

		.assume addr:extended
		aba 	$32		; force (ext -> ext)
		.assume addr:extended
		aba 	$00EF
		.assume addr:extended
		aba 	$abcd
		.assume addr:extended
		aba 	bak16
		.assume addr:extended
		aba 	bak32
		.assume addr:extended
		aba 	fwd24
		.assume addr:extended
		aba 	fwd08

		.assume addr:extended
		aba 	X		; force (ndx -> ext)
		.assume addr:extended
		aba 	$89,X
		.assume addr:extended
		aba 	$00AB, X
		.assume addr:extended
		aba 	bak08,X
		.assume addr:extended
		aba 	fwd08, X

		.assume addr:extended
		aba 	A		; force (accx -> ext)
		.assume addr:extended
		aba 	B

		.assume addr:extended
		aba 			; force (acc -> ext)

:	; backward ref for aba

		.assume addr:extended
		aba 	:+	; force (rel -> ext)
		.assume addr:extended
		aba 	:-

:	; forward ref for aba


; -------------------------------

		; check ADC
		; 11 mnemonics with modes ['dual']
		; ADD
		; AND
		; BIT
		; CMP
		; EOR
		; LDA
		; ORA
		; SBC
		; STA
		; SUB

		.assume addr:direct
		adc 			; force (inh -> dir)

		.assume addr:direct
		ADC 	A $32	; force (dual -> dir)
		.assume addr:direct
		ADC 	A bak08
		.assume addr:direct
		ADC 	A $D101
		.assume addr:direct
		ADC 	A bak16
		.assume addr:direct
		ADC 	A fwd16

		.assume addr:direct
		ADC 	B $32	; force (dual -> dir)
		.assume addr:direct
		ADC 	B bak08
		.assume addr:direct
		ADC 	B $D101
		.assume addr:direct
		ADC 	B bak16
		.assume addr:direct
		ADC 	B fwd16

		.assume addr:direct
		adc 	#$80	; force (imm -> dir)
		.assume addr:direct
		adc 	#bak08
		.assume addr:direct
		adc 	#fwd08

		.assume addr:direct
		adc 	$32		; force (dir -> dir)
		.assume addr:direct
		adc 	$00EF
		.assume addr:direct
		adc 	$abcd
		.assume addr:direct
		adc 	bak08
		.assume addr:direct
		adc 	bak24
		.assume addr:direct
		adc 	fwd32
		.assume addr:direct
		adc 	fwd16

		.assume addr:direct
		adc 	$32		; force (ext -> dir)
		.assume addr:direct
		adc 	$00EF
		.assume addr:direct
		adc 	$abcd
		.assume addr:direct
		adc 	bak08
		.assume addr:direct
		adc 	bak24
		.assume addr:direct
		adc 	fwd32
		.assume addr:direct
		adc 	fwd16

		.assume addr:direct
		adc 	X		; force (ndx -> dir)
		.assume addr:direct
		adc 	$89,X
		.assume addr:direct
		adc 	$00AB, X
		.assume addr:direct
		adc 	bak08,X
		.assume addr:direct
		adc 	fwd08, X

		.assume addr:direct
		adc 	A		; force (accx -> dir)
		.assume addr:direct
		adc 	B

		.assume addr:direct
		adc 			; force (acc -> dir)

:	; backward ref for adc

		.assume addr:direct
		adc 	:+	; force (rel -> dir)
		.assume addr:direct
		adc 	:-

:	; forward ref for adc


; -------------------------------

		.assume addr:extended
		adc 			; force (inh -> ext)

		.assume addr:extended
		ADC 	A $32	; force (dual -> ext)
		.assume addr:extended
		ADC 	A bak08
		.assume addr:extended
		ADC 	A $D101
		.assume addr:extended
		ADC 	A bak16
		.assume addr:extended
		ADC 	A fwd16

		.assume addr:extended
		ADC 	B $32	; force (dual -> ext)
		.assume addr:extended
		ADC 	B bak08
		.assume addr:extended
		ADC 	B $D101
		.assume addr:extended
		ADC 	B bak16
		.assume addr:extended
		ADC 	B fwd16

		.assume addr:extended
		adc 	#$80	; force (imm -> ext)
		.assume addr:extended
		adc 	#bak08
		.assume addr:extended
		adc 	#fwd08

		.assume addr:extended
		adc 	$32		; force (dir -> ext)
		.assume addr:extended
		adc 	$00EF
		.assume addr:extended
		adc 	$abcd
		.assume addr:extended
		adc 	bak16
		.assume addr:extended
		adc 	bak32
		.assume addr:extended
		adc 	fwd24
		.assume addr:extended
		adc 	fwd08

		.assume addr:extended
		adc 	$32		; force (ext -> ext)
		.assume addr:extended
		adc 	$00EF
		.assume addr:extended
		adc 	$abcd
		.assume addr:extended
		adc 	bak16
		.assume addr:extended
		adc 	bak32
		.assume addr:extended
		adc 	fwd24
		.assume addr:extended
		adc 	fwd08

		.assume addr:extended
		adc 	X		; force (ndx -> ext)
		.assume addr:extended
		adc 	$89,X
		.assume addr:extended
		adc 	$00AB, X
		.assume addr:extended
		adc 	bak08,X
		.assume addr:extended
		adc 	fwd08, X

		.assume addr:extended
		adc 	A		; force (accx -> ext)
		.assume addr:extended
		adc 	B

		.assume addr:extended
		adc 			; force (acc -> ext)

:	; backward ref for adc

		.assume addr:extended
		adc 	:+	; force (rel -> ext)
		.assume addr:extended
		adc 	:-

:	; forward ref for adc


; -------------------------------

		; check ADCA
		; 23 mnemonics with modes ['dir', 'ext', 'imm', 'ndx']
		; ADCB
		; ADDA
		; ADDB
		; ANDA
		; ANDB
		; BITA
		; BITB
		; CMPA
		; CMPB
		; CPX
		; EORA
		; EORB
		; LDAA
		; LDAB
		; LDS
		; LDX
		; ORAA
		; ORAB
		; SBCA
		; SBCB
		; SUBA
		; SUBB

		.assume addr:direct
		adca			; force (inh -> dir)

		.assume addr:direct
		adca	A $32	; force (dual -> dir)
		.assume addr:direct
		adca	A bak08
		.assume addr:direct
		adca	A $D101
		.assume addr:direct
		adca	A bak16
		.assume addr:direct
		adca	A fwd16

		.assume addr:direct
		adca	B $32	; force (dual -> dir)
		.assume addr:direct
		adca	B bak08
		.assume addr:direct
		adca	B $D101
		.assume addr:direct
		adca	B bak16
		.assume addr:direct
		adca	B fwd16

		.assume addr:direct
		adca	#$80	; force (imm -> dir)
		.assume addr:direct
		adca	#bak08
		.assume addr:direct
		adca	#fwd08

		.assume addr:direct
		ADCA	$32		; force (dir -> dir)
		.assume addr:direct
		ADCA	$00EF
		.assume addr:direct
		ADCA	$abcd
		.assume addr:direct
		ADCA	bak08
		.assume addr:direct
		ADCA	bak24
		.assume addr:direct
		ADCA	fwd32
		.assume addr:direct
		ADCA	fwd16

		.assume addr:direct
		ADCA	$32		; force (ext -> dir)
		.assume addr:direct
		ADCA	$00EF
		.assume addr:direct
		ADCA	$abcd
		.assume addr:direct
		ADCA	bak08
		.assume addr:direct
		ADCA	bak24
		.assume addr:direct
		ADCA	fwd32
		.assume addr:direct
		ADCA	fwd16

		.assume addr:direct
		adca	X		; force (ndx -> dir)
		.assume addr:direct
		adca	$89,X
		.assume addr:direct
		adca	$00AB, X
		.assume addr:direct
		adca	bak08,X
		.assume addr:direct
		adca	fwd08, X

		.assume addr:direct
		adca	A		; force (accx -> dir)
		.assume addr:direct
		adca	B

		.assume addr:direct
		adca			; force (acc -> dir)

:	; backward ref for adca

		.assume addr:direct
		adca	fwd24	; force (rel -> dir)
		.assume addr:direct
		adca	bak24

:	; forward ref for adca


; -------------------------------

		.assume addr:extended
		adca			; force (inh -> ext)

		.assume addr:extended
		adca	A $32	; force (dual -> ext)
		.assume addr:extended
		adca	A bak08
		.assume addr:extended
		adca	A $D101
		.assume addr:extended
		adca	A bak16
		.assume addr:extended
		adca	A fwd16

		.assume addr:extended
		adca	B $32	; force (dual -> ext)
		.assume addr:extended
		adca	B bak08
		.assume addr:extended
		adca	B $D101
		.assume addr:extended
		adca	B bak16
		.assume addr:extended
		adca	B fwd16

		.assume addr:extended
		adca	#$80	; force (imm -> ext)
		.assume addr:extended
		adca	#bak08
		.assume addr:extended
		adca	#fwd08

		.assume addr:extended
		ADCA	$32		; force (dir -> ext)
		.assume addr:extended
		ADCA	$00EF
		.assume addr:extended
		ADCA	$abcd
		.assume addr:extended
		ADCA	bak16
		.assume addr:extended
		ADCA	bak32
		.assume addr:extended
		ADCA	fwd24
		.assume addr:extended
		ADCA	fwd08

		.assume addr:extended
		ADCA	$32		; force (ext -> ext)
		.assume addr:extended
		ADCA	$00EF
		.assume addr:extended
		ADCA	$abcd
		.assume addr:extended
		ADCA	bak16
		.assume addr:extended
		ADCA	bak32
		.assume addr:extended
		ADCA	fwd24
		.assume addr:extended
		ADCA	fwd08

		.assume addr:extended
		adca	X		; force (ndx -> ext)
		.assume addr:extended
		adca	$89,X
		.assume addr:extended
		adca	$00AB, X
		.assume addr:extended
		adca	bak08,X
		.assume addr:extended
		adca	fwd08, X

		.assume addr:extended
		adca	A		; force (accx -> ext)
		.assume addr:extended
		adca	B

		.assume addr:extended
		adca			; force (acc -> ext)

:	; backward ref for adca

		.assume addr:extended
		adca	fwd24	; force (rel -> ext)
		.assume addr:extended
		adca	bak24

:	; forward ref for adca


; -------------------------------

		; check ASL
		; 11 mnemonics with modes ['accx', 'ext', 'ndx']
		; ASR
		; CLR
		; COM
		; DEC
		; INC
		; LSR
		; NEG
		; ROL
		; ROR
		; TST

		.assume addr:direct
		asl 			; force (inh -> dir)

		.assume addr:direct
		asl 	A $32	; force (dual -> dir)
		.assume addr:direct
		asl 	A bak08
		.assume addr:direct
		asl 	A $D101
		.assume addr:direct
		asl 	A bak16
		.assume addr:direct
		asl 	A fwd16

		.assume addr:direct
		asl 	B $32	; force (dual -> dir)
		.assume addr:direct
		asl 	B bak08
		.assume addr:direct
		asl 	B $D101
		.assume addr:direct
		asl 	B bak16
		.assume addr:direct
		asl 	B fwd16

		.assume addr:direct
		asl 	#$80	; force (imm -> dir)
		.assume addr:direct
		asl 	#bak08
		.assume addr:direct
		asl 	#fwd08

		.assume addr:direct
		asl 	$32		; force (dir -> dir)
		.assume addr:direct
		asl 	$00EF
		.assume addr:direct
		asl 	$abcd
		.assume addr:direct
		asl 	bak08
		.assume addr:direct
		asl 	bak24
		.assume addr:direct
		asl 	fwd32
		.assume addr:direct
		asl 	fwd16

		.assume addr:direct
		asl 	$32		; force (ext -> dir)
		.assume addr:direct
		asl 	$00EF
		.assume addr:direct
		asl 	$abcd
		.assume addr:direct
		asl 	bak08
		.assume addr:direct
		asl 	bak24
		.assume addr:direct
		asl 	fwd32
		.assume addr:direct
		asl 	fwd16

		.assume addr:direct
		asl 	X		; force (ndx -> dir)
		.assume addr:direct
		asl 	$89,X
		.assume addr:direct
		asl 	$00AB, X
		.assume addr:direct
		asl 	bak08,X
		.assume addr:direct
		asl 	fwd08, X

		.assume addr:direct
		asl 	A		; force (accx -> dir)
		.assume addr:direct
		asl 	B

		.assume addr:direct
		asl 			; force (acc -> dir)

:	; backward ref for asl

		.assume addr:direct
		asl 	fwd24	; force (rel -> dir)
		.assume addr:direct
		asl 	bak24

:	; forward ref for asl


; -------------------------------

		.assume addr:extended
		asl 			; force (inh -> ext)

		.assume addr:extended
		asl 	A $32	; force (dual -> ext)
		.assume addr:extended
		asl 	A bak08
		.assume addr:extended
		asl 	A $D101
		.assume addr:extended
		asl 	A bak16
		.assume addr:extended
		asl 	A fwd16

		.assume addr:extended
		asl 	B $32	; force (dual -> ext)
		.assume addr:extended
		asl 	B bak08
		.assume addr:extended
		asl 	B $D101
		.assume addr:extended
		asl 	B bak16
		.assume addr:extended
		asl 	B fwd16

		.assume addr:extended
		asl 	#$80	; force (imm -> ext)
		.assume addr:extended
		asl 	#bak08
		.assume addr:extended
		asl 	#fwd08

		.assume addr:extended
		ASL 	$32		; force (dir -> ext)
		.assume addr:extended
		ASL 	$00EF
		.assume addr:extended
		ASL 	$abcd
		.assume addr:extended
		ASL 	bak16
		.assume addr:extended
		ASL 	bak32
		.assume addr:extended
		ASL 	fwd24
		.assume addr:extended
		ASL 	fwd08

		.assume addr:extended
		ASL 	$32		; force (ext -> ext)
		.assume addr:extended
		ASL 	$00EF
		.assume addr:extended
		ASL 	$abcd
		.assume addr:extended
		ASL 	bak16
		.assume addr:extended
		ASL 	bak32
		.assume addr:extended
		ASL 	fwd24
		.assume addr:extended
		ASL 	fwd08

		.assume addr:extended
		asl 	X		; force (ndx -> ext)
		.assume addr:extended
		asl 	$89,X
		.assume addr:extended
		asl 	$00AB, X
		.assume addr:extended
		asl 	bak08,X
		.assume addr:extended
		asl 	fwd08, X

		.assume addr:extended
		asl 	A		; force (accx -> ext)
		.assume addr:extended
		asl 	B

		.assume addr:extended
		asl 			; force (acc -> ext)

:	; backward ref for asl

		.assume addr:extended
		asl 	fwd24	; force (rel -> ext)
		.assume addr:extended
		asl 	bak24

:	; forward ref for asl


; -------------------------------

		; check ASLA
		; 26 mnemonics with modes ['acc']
		; ASLB
		; ASRA
		; ASRB
		; CLRA
		; CLRB
		; COMA
		; COMB
		; DECA
		; DECB
		; INCA
		; INCB
		; LSRA
		; LSRB
		; NEGA
		; NEGB
		; PSHA
		; PSHB
		; PULA
		; PULB
		; ROLA
		; ROLB
		; RORA
		; RORB
		; TSTA
		; TSTB

		.assume addr:direct
		asla			; force (inh -> dir)

		.assume addr:direct
		asla	A $32	; force (dual -> dir)
		.assume addr:direct
		asla	A bak08
		.assume addr:direct
		asla	A $D101
		.assume addr:direct
		asla	A bak16
		.assume addr:direct
		asla	A fwd16

		.assume addr:direct
		asla	B $32	; force (dual -> dir)
		.assume addr:direct
		asla	B bak08
		.assume addr:direct
		asla	B $D101
		.assume addr:direct
		asla	B bak16
		.assume addr:direct
		asla	B fwd16

		.assume addr:direct
		asla	#$80	; force (imm -> dir)
		.assume addr:direct
		asla	#bak08
		.assume addr:direct
		asla	#fwd08

		.assume addr:direct
		asla	$32		; force (dir -> dir)
		.assume addr:direct
		asla	$00EF
		.assume addr:direct
		asla	$abcd
		.assume addr:direct
		asla	bak08
		.assume addr:direct
		asla	bak24
		.assume addr:direct
		asla	fwd32
		.assume addr:direct
		asla	fwd16

		.assume addr:direct
		asla	$32		; force (ext -> dir)
		.assume addr:direct
		asla	$00EF
		.assume addr:direct
		asla	$abcd
		.assume addr:direct
		asla	bak08
		.assume addr:direct
		asla	bak24
		.assume addr:direct
		asla	fwd32
		.assume addr:direct
		asla	fwd16

		.assume addr:direct
		asla	X		; force (ndx -> dir)
		.assume addr:direct
		asla	$89,X
		.assume addr:direct
		asla	$00AB, X
		.assume addr:direct
		asla	bak08,X
		.assume addr:direct
		asla	fwd08, X

		.assume addr:direct
		asla	A		; force (accx -> dir)
		.assume addr:direct
		asla	B

		.assume addr:direct
		asla			; force (acc -> dir)

:	; backward ref for asla

		.assume addr:direct
		asla	:+	; force (rel -> dir)
		.assume addr:direct
		asla	:-

:	; forward ref for asla


; -------------------------------

		.assume addr:extended
		asla			; force (inh -> ext)

		.assume addr:extended
		asla	A $32	; force (dual -> ext)
		.assume addr:extended
		asla	A bak08
		.assume addr:extended
		asla	A $D101
		.assume addr:extended
		asla	A bak16
		.assume addr:extended
		asla	A fwd16

		.assume addr:extended
		asla	B $32	; force (dual -> ext)
		.assume addr:extended
		asla	B bak08
		.assume addr:extended
		asla	B $D101
		.assume addr:extended
		asla	B bak16
		.assume addr:extended
		asla	B fwd16

		.assume addr:extended
		asla	#$80	; force (imm -> ext)
		.assume addr:extended
		asla	#bak08
		.assume addr:extended
		asla	#fwd08

		.assume addr:extended
		asla	$32		; force (dir -> ext)
		.assume addr:extended
		asla	$00EF
		.assume addr:extended
		asla	$abcd
		.assume addr:extended
		asla	bak16
		.assume addr:extended
		asla	bak32
		.assume addr:extended
		asla	fwd24
		.assume addr:extended
		asla	fwd08

		.assume addr:extended
		asla	$32		; force (ext -> ext)
		.assume addr:extended
		asla	$00EF
		.assume addr:extended
		asla	$abcd
		.assume addr:extended
		asla	bak16
		.assume addr:extended
		asla	bak32
		.assume addr:extended
		asla	fwd24
		.assume addr:extended
		asla	fwd08

		.assume addr:extended
		asla	X		; force (ndx -> ext)
		.assume addr:extended
		asla	$89,X
		.assume addr:extended
		asla	$00AB, X
		.assume addr:extended
		asla	bak08,X
		.assume addr:extended
		asla	fwd08, X

		.assume addr:extended
		asla	A		; force (accx -> ext)
		.assume addr:extended
		asla	B

		.assume addr:extended
		asla			; force (acc -> ext)

:	; backward ref for asla

		.assume addr:extended
		asla	:+	; force (rel -> ext)
		.assume addr:extended
		asla	:-

:	; forward ref for asla


; -------------------------------

		; check BCC
		; 16 mnemonics with modes ['rel']
		; BCS
		; BEQ
		; BGE
		; BGT
		; BHI
		; BLE
		; BLS
		; BLT
		; BMI
		; BNE
		; BPL
		; BRA
		; BSR
		; BVC
		; BVS

		.assume addr:direct
		bcc 			; force (inh -> dir)

		.assume addr:direct
		bcc 	A $32	; force (dual -> dir)
		.assume addr:direct
		bcc 	A bak08
		.assume addr:direct
		bcc 	A $D101
		.assume addr:direct
		bcc 	A bak16
		.assume addr:direct
		bcc 	A fwd16

		.assume addr:direct
		bcc 	B $32	; force (dual -> dir)
		.assume addr:direct
		bcc 	B bak08
		.assume addr:direct
		bcc 	B $D101
		.assume addr:direct
		bcc 	B bak16
		.assume addr:direct
		bcc 	B fwd16

		.assume addr:direct
		bcc 	#$80	; force (imm -> dir)
		.assume addr:direct
		bcc 	#bak08
		.assume addr:direct
		bcc 	#fwd08

		.assume addr:direct
		bcc 	$32		; force (dir -> dir)
		.assume addr:direct
		bcc 	$00EF
		.assume addr:direct
		bcc 	$abcd
		.assume addr:direct
		bcc 	bak08
		.assume addr:direct
		bcc 	bak24
		.assume addr:direct
		bcc 	fwd32
		.assume addr:direct
		bcc 	fwd16

		.assume addr:direct
		bcc 	$32		; force (ext -> dir)
		.assume addr:direct
		bcc 	$00EF
		.assume addr:direct
		bcc 	$abcd
		.assume addr:direct
		bcc 	bak08
		.assume addr:direct
		bcc 	bak24
		.assume addr:direct
		bcc 	fwd32
		.assume addr:direct
		bcc 	fwd16

		.assume addr:direct
		bcc 	X		; force (ndx -> dir)
		.assume addr:direct
		bcc 	$89,X
		.assume addr:direct
		bcc 	$00AB, X
		.assume addr:direct
		bcc 	bak08,X
		.assume addr:direct
		bcc 	fwd08, X

		.assume addr:direct
		bcc 	A		; force (accx -> dir)
		.assume addr:direct
		bcc 	B

		.assume addr:direct
		bcc 			; force (acc -> dir)

:	; backward ref for bcc

		.assume addr:direct
		bcc 	:+	; force (rel -> dir)
		.assume addr:direct
		bcc 	:-

:	; forward ref for bcc


; -------------------------------

		.assume addr:extended
		bcc 			; force (inh -> ext)

		.assume addr:extended
		bcc 	A $32	; force (dual -> ext)
		.assume addr:extended
		bcc 	A bak08
		.assume addr:extended
		bcc 	A $D101
		.assume addr:extended
		bcc 	A bak16
		.assume addr:extended
		bcc 	A fwd16

		.assume addr:extended
		bcc 	B $32	; force (dual -> ext)
		.assume addr:extended
		bcc 	B bak08
		.assume addr:extended
		bcc 	B $D101
		.assume addr:extended
		bcc 	B bak16
		.assume addr:extended
		bcc 	B fwd16

		.assume addr:extended
		bcc 	#$80	; force (imm -> ext)
		.assume addr:extended
		bcc 	#bak08
		.assume addr:extended
		bcc 	#fwd08

		.assume addr:extended
		bcc 	$32		; force (dir -> ext)
		.assume addr:extended
		bcc 	$00EF
		.assume addr:extended
		bcc 	$abcd
		.assume addr:extended
		bcc 	bak16
		.assume addr:extended
		bcc 	bak32
		.assume addr:extended
		bcc 	fwd24
		.assume addr:extended
		bcc 	fwd08

		.assume addr:extended
		bcc 	$32		; force (ext -> ext)
		.assume addr:extended
		bcc 	$00EF
		.assume addr:extended
		bcc 	$abcd
		.assume addr:extended
		bcc 	bak16
		.assume addr:extended
		bcc 	bak32
		.assume addr:extended
		bcc 	fwd24
		.assume addr:extended
		bcc 	fwd08

		.assume addr:extended
		bcc 	X		; force (ndx -> ext)
		.assume addr:extended
		bcc 	$89,X
		.assume addr:extended
		bcc 	$00AB, X
		.assume addr:extended
		bcc 	bak08,X
		.assume addr:extended
		bcc 	fwd08, X

		.assume addr:extended
		bcc 	A		; force (accx -> ext)
		.assume addr:extended
		bcc 	B

		.assume addr:extended
		bcc 			; force (acc -> ext)

:	; backward ref for bcc

		.assume addr:extended
		bcc 	:+	; force (rel -> ext)
		.assume addr:extended
		bcc 	:-

:	; forward ref for bcc


; -------------------------------

		; check JMP
		; 2 mnemonics with modes ['ext', 'ndx']
		; JSR

		.assume addr:direct
		jmp 			; force (inh -> dir)

		.assume addr:direct
		jmp 	A $32	; force (dual -> dir)
		.assume addr:direct
		jmp 	A bak08
		.assume addr:direct
		jmp 	A $D101
		.assume addr:direct
		jmp 	A bak16
		.assume addr:direct
		jmp 	A fwd16

		.assume addr:direct
		jmp 	B $32	; force (dual -> dir)
		.assume addr:direct
		jmp 	B bak08
		.assume addr:direct
		jmp 	B $D101
		.assume addr:direct
		jmp 	B bak16
		.assume addr:direct
		jmp 	B fwd16

		.assume addr:direct
		jmp 	#$80	; force (imm -> dir)
		.assume addr:direct
		jmp 	#bak08
		.assume addr:direct
		jmp 	#fwd08

		.assume addr:direct
		jmp 	$32		; force (dir -> dir)
		.assume addr:direct
		jmp 	$00EF
		.assume addr:direct
		jmp 	$abcd
		.assume addr:direct
		jmp 	bak08
		.assume addr:direct
		jmp 	bak24
		.assume addr:direct
		jmp 	fwd32
		.assume addr:direct
		jmp 	fwd16

		.assume addr:direct
		jmp 	$32		; force (ext -> dir)
		.assume addr:direct
		jmp 	$00EF
		.assume addr:direct
		jmp 	$abcd
		.assume addr:direct
		jmp 	bak08
		.assume addr:direct
		jmp 	bak24
		.assume addr:direct
		jmp 	fwd32
		.assume addr:direct
		jmp 	fwd16

		.assume addr:direct
		jmp 	X		; force (ndx -> dir)
		.assume addr:direct
		jmp 	$89,X
		.assume addr:direct
		jmp 	$00AB, X
		.assume addr:direct
		jmp 	bak08,X
		.assume addr:direct
		jmp 	fwd08, X

		.assume addr:direct
		jmp 	A		; force (accx -> dir)
		.assume addr:direct
		jmp 	B

		.assume addr:direct
		jmp 			; force (acc -> dir)

:	; backward ref for jmp

		.assume addr:direct
		jmp 	fwd24	; force (rel -> dir)
		.assume addr:direct
		jmp 	bak24

:	; forward ref for jmp


; -------------------------------

		.assume addr:extended
		jmp 			; force (inh -> ext)

		.assume addr:extended
		jmp 	A $32	; force (dual -> ext)
		.assume addr:extended
		jmp 	A bak08
		.assume addr:extended
		jmp 	A $D101
		.assume addr:extended
		jmp 	A bak16
		.assume addr:extended
		jmp 	A fwd16

		.assume addr:extended
		jmp 	B $32	; force (dual -> ext)
		.assume addr:extended
		jmp 	B bak08
		.assume addr:extended
		jmp 	B $D101
		.assume addr:extended
		jmp 	B bak16
		.assume addr:extended
		jmp 	B fwd16

		.assume addr:extended
		jmp 	#$80	; force (imm -> ext)
		.assume addr:extended
		jmp 	#bak08
		.assume addr:extended
		jmp 	#fwd08

		.assume addr:extended
		JMP 	$32		; force (dir -> ext)
		.assume addr:extended
		JMP 	$00EF
		.assume addr:extended
		JMP 	$abcd
		.assume addr:extended
		JMP 	bak16
		.assume addr:extended
		JMP 	bak32
		.assume addr:extended
		JMP 	fwd24
		.assume addr:extended
		JMP 	fwd08

		.assume addr:extended
		JMP 	$32		; force (ext -> ext)
		.assume addr:extended
		JMP 	$00EF
		.assume addr:extended
		JMP 	$abcd
		.assume addr:extended
		JMP 	bak16
		.assume addr:extended
		JMP 	bak32
		.assume addr:extended
		JMP 	fwd24
		.assume addr:extended
		JMP 	fwd08

		.assume addr:extended
		jmp 	X		; force (ndx -> ext)
		.assume addr:extended
		jmp 	$89,X
		.assume addr:extended
		jmp 	$00AB, X
		.assume addr:extended
		jmp 	bak08,X
		.assume addr:extended
		jmp 	fwd08, X

		.assume addr:extended
		jmp 	A		; force (accx -> ext)
		.assume addr:extended
		jmp 	B

		.assume addr:extended
		jmp 			; force (acc -> ext)

:	; backward ref for jmp

		.assume addr:extended
		jmp 	fwd24	; force (rel -> ext)
		.assume addr:extended
		jmp 	bak24

:	; forward ref for jmp


; -------------------------------

		; check PSH
		; 2 mnemonics with modes ['accx']
		; PUL

		.assume addr:direct
		psh 			; force (inh -> dir)

		.assume addr:direct
		psh 	A $32	; force (dual -> dir)
		.assume addr:direct
		psh 	A bak08
		.assume addr:direct
		psh 	A $D101
		.assume addr:direct
		psh 	A bak16
		.assume addr:direct
		psh 	A fwd16

		.assume addr:direct
		psh 	B $32	; force (dual -> dir)
		.assume addr:direct
		psh 	B bak08
		.assume addr:direct
		psh 	B $D101
		.assume addr:direct
		psh 	B bak16
		.assume addr:direct
		psh 	B fwd16

		.assume addr:direct
		psh 	#$80	; force (imm -> dir)
		.assume addr:direct
		psh 	#bak08
		.assume addr:direct
		psh 	#fwd08

		.assume addr:direct
		psh 	$32		; force (dir -> dir)
		.assume addr:direct
		psh 	$00EF
		.assume addr:direct
		psh 	$abcd
		.assume addr:direct
		psh 	bak08
		.assume addr:direct
		psh 	bak24
		.assume addr:direct
		psh 	fwd32
		.assume addr:direct
		psh 	fwd16

		.assume addr:direct
		psh 	$32		; force (ext -> dir)
		.assume addr:direct
		psh 	$00EF
		.assume addr:direct
		psh 	$abcd
		.assume addr:direct
		psh 	bak08
		.assume addr:direct
		psh 	bak24
		.assume addr:direct
		psh 	fwd32
		.assume addr:direct
		psh 	fwd16

		.assume addr:direct
		psh 	X		; force (ndx -> dir)
		.assume addr:direct
		psh 	$89,X
		.assume addr:direct
		psh 	$00AB, X
		.assume addr:direct
		psh 	bak08,X
		.assume addr:direct
		psh 	fwd08, X

		.assume addr:direct
		psh 	A		; force (accx -> dir)
		.assume addr:direct
		psh 	B

		.assume addr:direct
		psh 			; force (acc -> dir)

:	; backward ref for psh

		.assume addr:direct
		psh 	:+	; force (rel -> dir)
		.assume addr:direct
		psh 	:-

:	; forward ref for psh


; -------------------------------

		.assume addr:extended
		psh 			; force (inh -> ext)

		.assume addr:extended
		psh 	A $32	; force (dual -> ext)
		.assume addr:extended
		psh 	A bak08
		.assume addr:extended
		psh 	A $D101
		.assume addr:extended
		psh 	A bak16
		.assume addr:extended
		psh 	A fwd16

		.assume addr:extended
		psh 	B $32	; force (dual -> ext)
		.assume addr:extended
		psh 	B bak08
		.assume addr:extended
		psh 	B $D101
		.assume addr:extended
		psh 	B bak16
		.assume addr:extended
		psh 	B fwd16

		.assume addr:extended
		psh 	#$80	; force (imm -> ext)
		.assume addr:extended
		psh 	#bak08
		.assume addr:extended
		psh 	#fwd08

		.assume addr:extended
		psh 	$32		; force (dir -> ext)
		.assume addr:extended
		psh 	$00EF
		.assume addr:extended
		psh 	$abcd
		.assume addr:extended
		psh 	bak16
		.assume addr:extended
		psh 	bak32
		.assume addr:extended
		psh 	fwd24
		.assume addr:extended
		psh 	fwd08

		.assume addr:extended
		psh 	$32		; force (ext -> ext)
		.assume addr:extended
		psh 	$00EF
		.assume addr:extended
		psh 	$abcd
		.assume addr:extended
		psh 	bak16
		.assume addr:extended
		psh 	bak32
		.assume addr:extended
		psh 	fwd24
		.assume addr:extended
		psh 	fwd08

		.assume addr:extended
		psh 	X		; force (ndx -> ext)
		.assume addr:extended
		psh 	$89,X
		.assume addr:extended
		psh 	$00AB, X
		.assume addr:extended
		psh 	bak08,X
		.assume addr:extended
		psh 	fwd08, X

		.assume addr:extended
		psh 	A		; force (accx -> ext)
		.assume addr:extended
		psh 	B

		.assume addr:extended
		psh 			; force (acc -> ext)

:	; backward ref for psh

		.assume addr:extended
		psh 	:+	; force (rel -> ext)
		.assume addr:extended
		psh 	:-

:	; forward ref for psh


; -------------------------------

		; check STAA
		; 4 mnemonics with modes ['dir', 'ext', 'ndx']
		; STAB
		; STS
		; STX

		.assume addr:direct
		staa			; force (inh -> dir)

		.assume addr:direct
		staa	A $32	; force (dual -> dir)
		.assume addr:direct
		staa	A bak08
		.assume addr:direct
		staa	A $D101
		.assume addr:direct
		staa	A bak16
		.assume addr:direct
		staa	A fwd16

		.assume addr:direct
		staa	B $32	; force (dual -> dir)
		.assume addr:direct
		staa	B bak08
		.assume addr:direct
		staa	B $D101
		.assume addr:direct
		staa	B bak16
		.assume addr:direct
		staa	B fwd16

		.assume addr:direct
		staa	#$80	; force (imm -> dir)
		.assume addr:direct
		staa	#bak08
		.assume addr:direct
		staa	#fwd08

		.assume addr:direct
		STAA	$32		; force (dir -> dir)
		.assume addr:direct
		STAA	$00EF
		.assume addr:direct
		STAA	$abcd
		.assume addr:direct
		STAA	bak08
		.assume addr:direct
		STAA	bak24
		.assume addr:direct
		STAA	fwd32
		.assume addr:direct
		STAA	fwd16

		.assume addr:direct
		STAA	$32		; force (ext -> dir)
		.assume addr:direct
		STAA	$00EF
		.assume addr:direct
		STAA	$abcd
		.assume addr:direct
		STAA	bak08
		.assume addr:direct
		STAA	bak24
		.assume addr:direct
		STAA	fwd32
		.assume addr:direct
		STAA	fwd16

		.assume addr:direct
		staa	X		; force (ndx -> dir)
		.assume addr:direct
		staa	$89,X
		.assume addr:direct
		staa	$00AB, X
		.assume addr:direct
		staa	bak08,X
		.assume addr:direct
		staa	fwd08, X

		.assume addr:direct
		staa	A		; force (accx -> dir)
		.assume addr:direct
		staa	B

		.assume addr:direct
		staa			; force (acc -> dir)

:	; backward ref for staa

		.assume addr:direct
		staa	fwd24	; force (rel -> dir)
		.assume addr:direct
		staa	bak24

:	; forward ref for staa


; -------------------------------

		.assume addr:extended
		staa			; force (inh -> ext)

		.assume addr:extended
		staa	A $32	; force (dual -> ext)
		.assume addr:extended
		staa	A bak08
		.assume addr:extended
		staa	A $D101
		.assume addr:extended
		staa	A bak16
		.assume addr:extended
		staa	A fwd16

		.assume addr:extended
		staa	B $32	; force (dual -> ext)
		.assume addr:extended
		staa	B bak08
		.assume addr:extended
		staa	B $D101
		.assume addr:extended
		staa	B bak16
		.assume addr:extended
		staa	B fwd16

		.assume addr:extended
		staa	#$80	; force (imm -> ext)
		.assume addr:extended
		staa	#bak08
		.assume addr:extended
		staa	#fwd08

		.assume addr:extended
		STAA	$32		; force (dir -> ext)
		.assume addr:extended
		STAA	$00EF
		.assume addr:extended
		STAA	$abcd
		.assume addr:extended
		STAA	bak16
		.assume addr:extended
		STAA	bak32
		.assume addr:extended
		STAA	fwd24
		.assume addr:extended
		STAA	fwd08

		.assume addr:extended
		STAA	$32		; force (ext -> ext)
		.assume addr:extended
		STAA	$00EF
		.assume addr:extended
		STAA	$abcd
		.assume addr:extended
		STAA	bak16
		.assume addr:extended
		STAA	bak32
		.assume addr:extended
		STAA	fwd24
		.assume addr:extended
		STAA	fwd08

		.assume addr:extended
		staa	X		; force (ndx -> ext)
		.assume addr:extended
		staa	$89,X
		.assume addr:extended
		staa	$00AB, X
		.assume addr:extended
		staa	bak08,X
		.assume addr:extended
		staa	fwd08, X

		.assume addr:extended
		staa	A		; force (accx -> ext)
		.assume addr:extended
		staa	B

		.assume addr:extended
		staa			; force (acc -> ext)

:	; backward ref for staa

		.assume addr:extended
		staa	fwd24	; force (rel -> ext)
		.assume addr:extended
		staa	bak24

:	; forward ref for staa


; -------------------------------


; -------------------------------

; forward reference

fwd32	.equ	$89ABCDEF
fwd24	.equ	$456789
fwd16	.equ	$1234
fwd08	.equ	$12

; -------------------------------

		.end

; -------------------------------

; 104 pass
; 580 fail
