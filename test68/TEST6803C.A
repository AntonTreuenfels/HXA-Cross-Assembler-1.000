; Hobby Cross-Assembler HXA68 Test 6803c
; 6803\Instruction Set
; ok: 6803 Forced Address Modes

; generated by MODE68.PY - Sat Jun 15 18:03:32 2024

; no errors to detect

; -------------------------------

		.listfile
		.errfile

		.maxerr	10000		; increase default count

; -------------------------------

		.cpu	6803
		.org	$1000

; -------------------------------

; backward reference

bak08	.equ	$12
bak16	.equ	$1234
bak24	.equ	$456789
bak32	.equ	$89ABCDEF

; -------------------------------

		; check ADC
		; 11 mnemonics with modes ['dual']
		; ADD
		; AND
		; BIT
		; CMP
		; EOR
		; LDA
		; ORA
		; SBC
		; STA
		; SUB

		.assume addr:direct
		ADC 	A $32	; force (dual -> dir)
		.assume addr:direct
		ADC 	A bak08
		.assume addr:direct
		ADC 	A $D101
		.assume addr:direct
		ADC 	A bak16
		.assume addr:direct
		ADC 	A fwd16

		.assume addr:direct
		ADC 	B $32	; force (dual -> dir)
		.assume addr:direct
		ADC 	B bak08
		.assume addr:direct
		ADC 	B $D101
		.assume addr:direct
		ADC 	B bak16
		.assume addr:direct
		ADC 	B fwd16

		.assume addr:extended
		ADC 	A $32	; force (dual -> ext)
		.assume addr:extended
		ADC 	A bak08
		.assume addr:extended
		ADC 	A $D101
		.assume addr:extended
		ADC 	A bak16
		.assume addr:extended
		ADC 	A fwd16

		.assume addr:extended
		ADC 	B $32	; force (dual -> ext)
		.assume addr:extended
		ADC 	B bak08
		.assume addr:extended
		ADC 	B $D101
		.assume addr:extended
		ADC 	B bak16
		.assume addr:extended
		ADC 	B fwd16


; -------------------------------

		; check ADCA
		; 26 mnemonics with modes ['dir', 'ext', 'imm', 'ndx']
		; ADCB
		; ADDA
		; ADDB
		; ADDD
		; ANDA
		; ANDB
		; BITA
		; BITB
		; CMPA
		; CMPB
		; CPX
		; EORA
		; EORB
		; LDAA
		; LDAB
		; LDD
		; LDS
		; LDX
		; ORAA
		; ORAB
		; SBCA
		; SBCB
		; SUBA
		; SUBB
		; SUBD

		.assume addr:direct
		ADCA	$32		; force (dir -> dir)
		.assume addr:direct
		ADCA	$00EF
		.assume addr:direct
		ADCA	$abcd
		.assume addr:direct
		ADCA	bak08
		.assume addr:direct
		ADCA	bak24
		.assume addr:direct
		ADCA	fwd32
		.assume addr:direct
		ADCA	fwd16

		.assume addr:extended
		ADCA	$32		; force (dir -> ext)
		.assume addr:extended
		ADCA	$00EF
		.assume addr:extended
		ADCA	$abcd
		.assume addr:extended
		ADCA	bak16
		.assume addr:extended
		ADCA	bak32
		.assume addr:extended
		ADCA	fwd24
		.assume addr:extended
		ADCA	fwd08

		.assume addr:direct
		ADCA	$32		; force (ext -> dir)
		.assume addr:direct
		ADCA	$00EF
		.assume addr:direct
		ADCA	$abcd
		.assume addr:direct
		ADCA	bak08
		.assume addr:direct
		ADCA	bak24
		.assume addr:direct
		ADCA	fwd32
		.assume addr:direct
		ADCA	fwd16

		.assume addr:extended
		ADCA	$32		; force (ext -> ext)
		.assume addr:extended
		ADCA	$00EF
		.assume addr:extended
		ADCA	$abcd
		.assume addr:extended
		ADCA	bak16
		.assume addr:extended
		ADCA	bak32
		.assume addr:extended
		ADCA	fwd24
		.assume addr:extended
		ADCA	fwd08


; -------------------------------

		; check ASL
		; 11 mnemonics with modes ['accx', 'ext', 'ndx']
		; ASR
		; CLR
		; COM
		; DEC
		; INC
		; LSR
		; NEG
		; ROL
		; ROR
		; TST

		.assume addr:extended
		ASL 	$32		; force (ext -> ext)
		.assume addr:extended
		ASL 	$00EF
		.assume addr:extended
		ASL 	$abcd
		.assume addr:extended
		ASL 	bak16
		.assume addr:extended
		ASL 	bak32
		.assume addr:extended
		ASL 	fwd24
		.assume addr:extended
		ASL 	fwd08


; -------------------------------

		; check JMP
		; 2 mnemonics with modes ['ext', 'ndx']
		; LSL

		.assume addr:extended
		JMP 	$32		; force (ext -> ext)
		.assume addr:extended
		JMP 	$00EF
		.assume addr:extended
		JMP 	$abcd
		.assume addr:extended
		JMP 	bak16
		.assume addr:extended
		JMP 	bak32
		.assume addr:extended
		JMP 	fwd24
		.assume addr:extended
		JMP 	fwd08


; -------------------------------

		; check JSR
		; 6 mnemonics with modes ['dir', 'ext', 'ndx']
		; STAA
		; STAB
		; STD
		; STS
		; STX

		.assume addr:direct
		JSR 	$32		; force (dir -> dir)
		.assume addr:direct
		JSR 	$00EF
		.assume addr:direct
		JSR 	$abcd
		.assume addr:direct
		JSR 	bak08
		.assume addr:direct
		JSR 	bak24
		.assume addr:direct
		JSR 	fwd32
		.assume addr:direct
		JSR 	fwd16

		.assume addr:extended
		JSR 	$32		; force (dir -> ext)
		.assume addr:extended
		JSR 	$00EF
		.assume addr:extended
		JSR 	$abcd
		.assume addr:extended
		JSR 	bak16
		.assume addr:extended
		JSR 	bak32
		.assume addr:extended
		JSR 	fwd24
		.assume addr:extended
		JSR 	fwd08

		.assume addr:direct
		JSR 	$32		; force (ext -> dir)
		.assume addr:direct
		JSR 	$00EF
		.assume addr:direct
		JSR 	$abcd
		.assume addr:direct
		JSR 	bak08
		.assume addr:direct
		JSR 	bak24
		.assume addr:direct
		JSR 	fwd32
		.assume addr:direct
		JSR 	fwd16

		.assume addr:extended
		JSR 	$32		; force (ext -> ext)
		.assume addr:extended
		JSR 	$00EF
		.assume addr:extended
		JSR 	$abcd
		.assume addr:extended
		JSR 	bak16
		.assume addr:extended
		JSR 	bak32
		.assume addr:extended
		JSR 	fwd24
		.assume addr:extended
		JSR 	fwd08


; -------------------------------

; forward reference

fwd32	.equ	$89ABCDEF
fwd24	.equ	$456789
fwd16	.equ	$1234
fwd08	.equ	$12

; -------------------------------

		.end

; -------------------------------

; 90 pass
; 0 fail
