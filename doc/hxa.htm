<!DOCTYPE html><html lang="en-US"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="color-scheme" content="normal">
<title>HXA 1.200 User Manual</title>
<style>
html {background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAARElEQVQYV2M8c+bMfwY0YGJiwggTAjOQFYEkQXyYIrhKZEGYJpAiuAnIxiKbiGIcunUgPtwKZGNRTIC5lqAbYArR3QIAdA85lXmjDMQAAAAASUVORK5CYII=)}
body {margin:0 auto; padding:0; max-width:82em}
h1,h2,h3,h4 {text-align:center}
h2, h3 {border:1px solid #ccc; padding: 0.5em 0}
hr {width: 45%; margin:0 auto}
table {margin-left:auto; margin-right:auto;border: 1px solid black}
table, th, tr {text-align:center}
caption {padding:10px; caption-side:bottom}
th, td {padding-left:0.5em; padding-right:0.5em}
section {display:flex; flex-direction:row; background-color:transparent; height:100vh}
a:hover {background-color:#FFF}
#toc, #content {background-color:#EEE; padding:1em; overflow:auto}
#toc {flex:1; margin-right:1em}
#toc p {text-align:center; font-weight:bold; font-size:1.2em}
#toc li {list-style-type:none; padding:.1em, 0}
#content {flex:3}
</style>
</head><body><section><div id="toc">
<p>Contents</p><hr>
<ul><li>
</li><li><a href="#L001">Introduction to HXA</a>
<ul><li>
</li><li><a href="#L002">Scope of this Document</a>
</li><li><a href="#L003">License and Terms</a>
</li><li><a href="#L004">Related Resources</a>
</li><li><a href="#L005">HXA Features</a>
</li></ul>
</li><li><a href="#L006">Executing HXA</a>
<ul><li>
</li><li><a href="#L008">Exit Codes</a>
</li></ul>
</li><li><a href="#L00A">Conventions</a>
</li><li><a href="#L00E">Source Code Organization</a>
</li><li><a href="#L01C">Input File</a>
<ul><li>
</li><li><a href="#L01E">Label Field</a>
</li><li><a href="#L025">Opcode Field</a>
</li><li><a href="#L027">Expression Field</a>
<ul><li>
</li><li><a href="#L028">Operands</a>
<ul><li>
</li><li><a href="#L02F">Functions</a>
</li></ul>
</li><li><a href="#L052">Operators</a>
</li></ul>
</li><li><a href="#L053">Comment Field</a>
</li></ul>
</li><li><a href="#L054">Output Files</a>
</li><li><a href="#L069">Pseudo Opcodes</a>
</li><li><a href="#L07F">Macros</a>
<ul><li>
</li><li><a href="#L082">Macro Parameters</a>
</li></ul>
</li><li><a href="#L08C">Conditional Assembly</a>
</li><li><a href="#L099">User Customization</a>
<ul><li>
</li><li><a href="#L09E">Maximum Limits</a>
</li></ul>
</li><li><a href="#L0A6">Appendices</a>
<ul><li>
</li><li><a href="#L0A7">Intel</a>
</li><li><a href="#L0A9">Motorola</a>
</li><li><a href="#L0AC">Octet Extraction Order</a>
</li><li><a href="#L0AE">Non-Standard BYTE Sizes</a>
</li><li><a href="#L0B0">Floating Point Output</a>
</li></ul>
</li></ul>
</div><div id="content"><h2>Hobby Cross Assembler 1.200</h2>
<h3>User Manual</h3>
<p>Copyright (&copy;) 2004-2024 by Anton Treuenfels</p>
<a id="L001"></a><h3>Introduction to HXA</h3>
<p>HXA is a macro cross assembler created simply for fun as a hobby project (hence the name). It therefore reflects many of my own ideas about what is and is not important in assembler design.</p>
<p>Perhaps the most central idea from a programmer's viewpoint is that HXA requires almost every intention to be made explicit in assembly source code. I've had the experience of trying to read source code in unfamiliar languages for assemblers whose manuals I did not have. That's not so easy, so HXA tries to make sure both writer and reader have no doubt about what is supposed to happen.</p>
<p>An area of ongoing concern is error detection and reporting. HXA has been designed from the start to detect many possible source code errors. If found, errors are reported in a consistent manner that attempts to make clear what, why and where something went wrong. The aim is to give a progammer trying to fix an error a "fighting chance".</p>
<p>HXA makes an effort to accomodate programmers used to the conventions of other assemblers. It is fairly agnostic with regard to how numeric literals are specified, for example.</p>
<p>A couple of things I don't worry much about are size and speed. Current machines are very fast and have very large memories, so concerns of this nature in an assembler aren't too pressing. While trying to never needlessly inflate HXA, when push comes to shove I permit it to get larger and slower.</p>
<p>I hope you find using HXA to be both productive and enjoyable. If you have any questions or comments, please let me know. There are many excellent ideas still unstolen, and these will help decide which ones are plundered next :)</p>
<p>Anton Treuenfels</p>
<ul> <li><A HREF="mailto:teamtempest&#64;yahoo.com">teamtempest&#64;yahoo.com</A></li>
 </ul>
<ul> <li>5248 Horizon Dr</li>
 <li>Fridley, MN 55421</li>
 </ul>
<hr>
<a id="L002"></a><h4>Scope of this Document</h4>
<p>This document describes only those portions of HXA which are processor-independent. As assemblers in general are largely concerned with textual manipulation of assembly source code, this is actually most of HXA. Such things as expression evaluation, macro definition and expansion, and source code organization are all handled here.</p>
<p>Most of HXA is not concerned with specific central processors (CPUs). Details of specific CPUs are confined to a single module. This is the only portion of HXA which "understands" the processor instruction opcodes of any particular assembly language.</p>
<p>Replacement of this file is one method of producing variants of HXA capable of handling different assembly languages. Each existing such variant is discussed in a separate document.</p>
<hr>
<a id="L003"></a><h4>License and Terms</h4>
<p>This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the <A HREF="The_GNU_General_Public_License_v3_0.htm">GNU General Public License</A> along with this program; if not, write to:</p>
<ul> <li>Free Software Foundation</li>
 <li>51 Franklin Street, Fifth Floor</li>
 <li>Boston, MA 02110-1335</li>
 <li>USA</li>
 </ul>
<hr>
<a id="L004"></a><h4>Related Resources</h4>
<h4>HXA</h4>
<ul> <li><a href="hxa_source.htm">Implementation Manual</a></li>
 <li><a href="hxa_test.htm">General Tests</a></li>
 </ul>
<hr>
<a id="L005"></a><h4>HXA Features</h4>
<h4>Labels</h4>
<ul> <li><em>numeric</em> and <em>string</em> types</li>
 <li><a href="#L020">global</a>, <a href="#L022">local</a>, <a href="#L023">variable</a> and <a href="#L024">anonymous</a> (aka <em>branch target</em>) sub-types</li>
 </ul>
<h4>Expressions</h4>
<ul> <li>algebraic <a href="#L026">expression evaluation</a>, including nested sets of parentheses</li>
 <li>operands include <a href="#L01D">labels</a>, <a href="#L02B">numbers</a>, <a href="#L029">program counters</a>, <a href="#L02C">characters</a>, <a href="#L02D">strings</a> and <a href="#L02E">regular expressions</a></li>
 <li><a href="#L052">operators</a> include arithmetic, logical, string and regular expression pattern matching</li>
 <li><a href="#L02F">functions</a> include numeric, logical and string</li>
 <li>numeric operands can be expressed in binary, decimal and hexadecimal in <b>C</b> , <a href="#L0A7">Intel</a> and <a href="#L0A9">Motorola</a> formats</li>
 <li>characters and strings can include <a href="#L00C">escape sequences</a></li>
 </ul>
<h4>Pseudo Opcodes</h4>
<ul> <li><a href="#L06E">BIT--</a>, <a href="#L06F">RBIT--</a>, <a href="#L070">SBIT--</a> and <a href="#L071">UBIT--</a> numeric data storage pseudo opcodess allow selection of bytes, byte order and range-checking of values stored</li>
 <li><a href="#L080">MACRO</a>, <a href="#L084">REPEAT</a> and <a href="#L086">WHILE</a> blocks with automatic local label scoping and no fixed limit on nesting depth</li>
 <li><a href="#L08D">IF</a> conditional assembly blocks with no fixed limit on nesting depth</li>
 <li><a href="#L05E">INCLUDE</a> multiple source files with no fixed limit on nesting depth</li>
 <li>customize HXA by redefining <a href="#L077">character set translation</a>, status and error <a href="#L09C">message texts</a>, and <a href="#L09A">pseudo opcode names</a></li>
 <li>supports both <a href="#L00F">monolithic</a> and <a href="#L010">segmented</a> programming styles</li>
 </ul>
<h4>Optional File Output</h4>
<ul> <li>object in raw binary, raw text, <a href="#L0A8">Intel Hex</a> or <a href="#L0AA">Motorola SRecord</a> formats</li>
 <li>output in one piece, by <a href="#L05D">blocks</a> or by <a href="#L05C">segments</a></li>
 <li><a href="#L056">list files</a> and <a href="#L055">error files</a></li>
 </ul>
<a id="L006"></a><h3>Executing HXA</h3>
<a id="L007"></a>
<h4>Useage</h4>
<blockquote> python hxa.py <em>[drive:][path]</em>filename<em>[.ext]</em> -cpuhandler <em>[-h] [-q]</em><br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>[drive:][path]filename[.ext]</em> is a filesystem path name locating the <b>root file</b>  (ie., the first source file to assemble)</li>
 <li><em>-cpuhandler</em> is a Python module that processes instruction mnemonics for one or more CPUs</li>
 <li><em>-h </em>is a case-insensitive flag that simply prints a help message and exits HXA with a return value of zero</li>
 <li><em>-q</em> is a case-insensitive flag that suppresses console output (ie, <em>quiet mode</em>)</li>
 </ul>
<h4>Aliases</h4>
<ul> <li><em>-h</em> can also be written as <em>/?</em> and <em>--help</em></li>
 <li><em>-q</em> can also be written as <em>--quiet</em></li>
 </ul>
<h4>Description</h4>
<p>HXA accepts one to three arguments (in any order) following its invocation. One <em>filename</em> and one <em>cpuhandler</em> must appear, and one optional flag may appear. All parameters beyond the first three are ignored.</p>
<p>HXA will display its useage message, and possibly an error, then exit if:</p>
<ul> <li>the help flag appears as one of its arguments</li>
 <li>exactly one source file is not specified</li>
 <li>exactly one processor handler is not specified</li>
 </ul>
<p>If one of the flags is <em>-h</em> (or an alias) there will be no error returned, otherwise a fatal exit code will be returned.</p>
<p><em>Filename</em> is assumed to be a text file in UTF-8 format. It is further assumed that this file contains source code appropriate for the <em>cpuhandler</em> in use. This handler is dynamically imported at run time, allowing assembly of code for any <a href="#L06A">CPU</a> which has a handler.</p>
<p>Trying to name multiple source files on the command line is a fatal error. Multiple source files can be assembled together only by using the <a href="#L05E">INCLUDE</a> pseudo opcode within <em>filename</em>.</p>
<p>HXA assumes the directory of <em>filename</em> is the current working directory on this device. An absolute path (ie., a <em>[drive:][path]</em> prefix to <em>filename</em>) to this directory will be created. By default, all output files will be placed in this same directory.</p>
<p>Unless they are already absolute, all input and output files named within <em>filename</em> are considered relative to the working directory.</p>
<p>The net effect is that files named within <em>filename</em> can normally be specified by their location relative to it. However, if desired an absolute location can be used instead.</p>
<p>All <em>cpuhandler</em> modules are assumed to be located in the same directory HXA is first executed from. Unlike assembler source files, they cannot be located in arbitrary directories.</p>
<p>Once <em>filename</em> has been successfully located, it is read and assembled in two passes. During HXA's first pass, wherever possible <a href="#L01D">labels</a> are assigned values and <a href="#L026">expressions</a> are evaluated. During HXA's second pass, any unresolved labels and expressions are evaluated again. If after the second pass nothing remains unresolved, assembly is successful and object files may be produced.</p>
<p>By default, HXA produces no output other than status and error messages. To produce absolute object files in binary form, at least one of the <a href="#L057">OBJ--</a> pseudo opcodes must be used. To produce absolute object files in text form, at least one of the <a href="#L058">RAW--</a>, <a href="#L059">HEX--</a> or <a href="#L05A">SREC--</a> pseudo opcodes must be used.</p>
<p>Status and error messages are sent to <em>stdout</em> (normally the console). If no console output is desired, the <em>-q</em> (quiet) flag may be specified on the command line. HXA does still tracks warning and error messages, and will write them to any <a href="#L055">error file</a>.</p>
<p>Alternatively, <em>stdout</em> may be re-directed to a file (to capture all such output) or the null (NUL) device (to ignore all such output).</p>
<p>There are no other command-line options or flags. Changes to HXA's default behavior are made explicit by <a href="#L069">pseudo opcodes</a>.</p>
<p>If the command line does not conform to these requirements, HXA prints its help message and exits with a fatal error.</p>
<h4>Examples</h4>
<ul> <li>python hxa.py testfile.a -hxatest</li>
 <li>python hxa.py helloworld.asm -hxa65 -q</li>
 <li>python hxa.py -h</li>
 <li>python hxa.py -q -hxa80 demo.a</li>
 </ul>
<hr>
<a id="L008"></a><h4>Exit Codes</h4>
<p>At exit, HXA returns a value of zero if no warnings or errors were encountered during assembly.</p>
<p>Non-zero exit values are bit-mapped:</p>
<ul> <li>1 means <a href="#L094">warning</a> messages were issued, but assembly was not halted</li>
 <li>2 means <a href="#L095">error</a> messages were issued, and assembly was halted at the end of the current pass</li>
 <li>4 means a <a href="#L096">fatal</a> error message was issued, and assembly was halted immediately.</li>
 </ul>
<p>If more than one of these occurred, then multiple types of messsages were issued. In these cases the return value may range from one to seven.</p>
<a id="L009"></a>
<a id="L00A"></a><h3>Conventions</h3>
<ul> <li><b>NUMERIC_EXPR</b></li>
 <li>an expression which evaluates to an integer numeric value</li>
 </ul>
<ul> <li><b>CONST_EXPR</b></li>
 <li>a <em>numeric_expr</em> expression which evaluates immediately (ie., the expession contains no <a href="#L02A">forward reference</a>)</li>
 </ul>
<ul> <li><b>POSITIVE_EXPR</b></li>
 <li>a <em>const_expr</em> which evaluates to a value greater than zero</li>
 </ul>
<ul> <li><b>CPU_ADDR</b></li>
 <li>a <em>const_expr</em> which evaluates to a legal address of the current <a href="#L06A">CPU</a></li>
 </ul>
<ul> <li><b>STRING_LIT</b></li>
 <li>a quoted literal string value of zero or more Unicode character codes</li>
 </ul>
<ul> <li><b>STRING_EXPR$</b></li>
 <li>an expression which evaluates to a string value of zero or more Unicode character codes</li>
 </ul>
<ul> <li><b>CONST_EXPR$</b></li>
 <li>a <em>string_expr</em> expression which evaluates immediately (ie., the expression contains no <a href="#L02A">forward reference</a>)</li>
 </ul>
<ul> <li><b>CONDITIONAL_EXPR</b></li>
 <li>either a <em>const_expr</em> (<em>TRUE</em> if non-zero) OR a <em>const_expr$</em> (<em>TRUE</em> if non-null)</li>
 </ul>
<ul> <li><b>GLOBAL_NAME</b></li>
 <li>a <a href="#L01F">numeric global</a> label OR a <em>const_expr$</em> which evaluates to a numeric global label</li>
 </ul>
<ul> <li><b>OPT_STR</b></li>
 <li>treated as a <em>const_expr$</em> if it begins with a string literal, label or function. If it does not, it is accepted "as-is". In particular, the "as-is" form is <em>not</em> subject to <a href="#L00C">escape processing</a></li>
 </ul>
<ul> <li><b>HEX_STR</b></li>
 <li>an <em>opt-str</em> consisting of hexadecimal character pairs. Any pair may be separated by one or more spaces for clarity. A hexadecimal radix indicator in <b>C</b> , <a href="#L0A7">Intel</a> or <a href="#L0A9">Motorola</a> form may be included</li>
 </ul>
<ul> <li><b>PATH_NAME</b></li>
 <li>an <em>opt_str</em> that evaluates to any path the filesystem allows. If enclosed in left- ('<', ASCII 0x3C) and right- ('>', ASCII 0x3C) angle brackets instead of quote marks, it is accepted "as-is" without processing or interpretation</li>
 </ul>
<hr>
<a id="L00B"></a>
<h4>The Equality Idiom</h4>
<p>Several HXA pseudo ops accept or require <em>equality</em> arguments. The general form of these arguments are <em>opt_strs</em> containing a single un-escaped equals sign ('=', ASCII 0x3D) or colon (':', ASCII 0x3A):</p>
<ul> <li>name = expr</li>
 <li>name : expr</li>
 </ul>
<p>The general meaning is that the value of <em>expr</em> is somehow used by <em>name</em>.</p>
<p>Normally <em>name</em> is a <em>string_lit</em>. It identifies what the equality is about or serves as the target of an assignment.</p>
<p>Normally <em>expr</em> is an <em>opt_str</em>. <em>Expr</em> may or may not be processed immediately (or at all), depending on where the equality idiom is used. Note that if <em>expr</em> has the form of a <em>const_expr$</em>, it is twice subjected to escape processing. Once when it is first evaluated, and once again when it is split at the equals sign.</p>
<p>Equality arguments are similar in many ways to sub-fields of the expression field, except that here the separator character is not a comma. In particular:</p>
<ul> <li>an unescaped equals or colon sign outside of a literal string marks a split point</li>
 <li>leading and trailing whitespace is removed from each argument</li>
 <li>blank or empty arguments are not allowed</li>
 </ul>
<p>A difference:</p>
<ul> <li>there must be exactly two arguments, <em>name</em> and <em>expr</em>. Fewer cause an error, more are ignored</li>
 </ul>
<hr>
<a id="L00C"></a>
<h4>Escape Sequence</h4>
<p>Escape sequences can be used in <a href="#L02C">character</a>, <a href="#L073">string</a>, and <a href="#L02E">regular expression</a> literals to represent Unicode character codes that are difficult to specify otherwise (eg., control codes). There are two types of escape sequences, <em>mnemonic</em> and <em>hexadecimal</em>.</p>
<h4>Mnemonic Escape Sequences</h4>
<p>Mnemonic escapes take the form of a backslash ('\', ASCII 0x5C) followed by a printable character. HXA recognizes the following mnemonic escapes:</p>
<ul> <li>\0 : NUL, ASCII 0x00, zero byte</li>
 <li>\b : BS, ASCII 0x08, backspace</li>
 <li>\f : FF, ASCII 0x0C, formfeed</li>
 <li>\n : NL, ASCII 0x0A, newline</li>
 <li>\r : CR, ASCII 0x0D, carriage return</li>
 <li>\s : space, ASCII 0x20, space</li>
 <li>\t : HT, ASCII 0x09, horizontal tab</li>
 <li>\v : VT, ASCII 0x0B, vertical tab</li>
 </ul>
<p>Any other characters following a backslash simply become themselves. This can be used to "turn off" the normal interpretation of certain characters:</p>
<ul> <li>\" : ASCII 0x22, double quote mark</li>
 <li>\' : ASCII 0x27, single quote mark</li>
 <li>\, : ASCII 0x2C, comma</li>
 <li>\\ : ASCII 0x5C, single backslash</li>
 </ul>
<h4>Hexadecimal Escape Sequences</h4>
<p>Hexadecimal escape sequences can represent any character in the Unicode specification. These escape sequences are all introduced by a single backslash character ('\', ASCII 0x5C) followed by a hexadecimal literal number.</p>
<p>Character codes in the range 0x00 to 0xFF can be represented in any of <b>C</b> , <a href="#L0A7">Intel</a> or <a href="#L0A9">Motorola</a> formats. The numeric literals themselves are described by exactly two following hexadecimal characters.</p>
<p>The only exception is for character codes in Intel format, which must start with a decimal character. A '0' (ASCII 0x30) character prefix can be used whenever desired or necessary.</p>
<p>Character codes in the range 0x0000 to 0xFFFF (ie., the Unicode Basic Lingual Plane) can be represented by the letter 'u' (ASCII 0x75) followed by exactly four hexadecimal characters.</p>
<p>Character codes in the range 0x000000 to 0x10FFFF (ie., the entire Unicode set) can be representened by the letter 'U' (ASCII 0x55) followed by exactly eight hexadecimal characters.</p>
<h4>Examples</h4>
<p>The bell character (ASCII 0x07):</p>
<ul> <li>\07h : Intel</li>
 <li>\007H : Intel</li>
 <li>\0x07 : C</li>
 <li>\$07 : Motorola</li>
 <li>\x07 : C</li>
 <li>\u0007 : Unicode Basic Lingual Plane</li>
 <li>\U00000007 : full Unicode set</li>
 </ul>
<hr>
<a id="L00D"></a>
<h4>Name Scoping</h4>
<p><a href="#L022">Local</a> labels in particular are affected by HXA's scope rules for names.</p>
<p>Scoping is for the most part managed automatically based on block concepts. Entering a block creates a new local scope, and exiting a block ends it. Since blocks can be nested, so can scopes.</p>
<p>For example, a file is considered a block. The <a href="#L007">root file</a> begins as a single local scope. Each <a href="#L05E">INCLUDE</a> file automtically creates a new nested local scope within the including file.</p>
<p>Any given scope can be further subdivided into smaller local scopes by <a href="#L020">global</a> labels. A global label in the label field of a source line ends the current local scope and opens a new one at the same level. Local labels are visible only between global labels, never across them.</p>
<p>Nested local scopes are also created by the expansion of <a href="#L080">macro</a>, <a href="#L084">repeat</a> and <a href="#L086">while</a> blocks. Local labels used in these scopes are not visible outside them.</p>
<p>In <a href="#L010">segmented</a> source files, each use of a segment fragment creates a nested local scope while that fragment is active.</p>
<p>All these scopes follow the same rules as the original file-level local scope. That is, they can be subdivided by global labels and any local labels in a subdivision must be unique.</p>
<a id="L00E"></a><h3>Source Code Organization</h3>
<p>HXA provides two forms of source code organization, monolithic (the default) and segmented. Mixing the two forms is not allowed; every HXA program is all one or all the other. Which form a programmer uses is a matter of which is more convenient for any particular program.</p>
<p>Technically all HXA programs are segmented, but in a monolithic program this is implicit. A programmer doesn't usually see or need to know how segments are handled internally.</p>
<a id="L00F"></a>
<h4>Monolithic</h4>
<p>In the default monolithic (<em>one block</em>) organization, object code organization mirrors source code organization. Object code is output in the same order it is encountered in the source code.</p>
<p>A monolithic program is characterized by <em>not</em> having any <a href="#L012">SEGMENT</a> or <a href="#L013">ENDSEGMENT</a> pseudo opcodes in the source code.</p>
<p>Only the <a href="#L06C">ABSORG</a> pseudo opcode can be used to set the program counter. Setting the program counter can be done at any time, to any legal value of the current <a href="#L06A">CPU</a>. Object code will grow consecutively from this first address until encountering another <b>ABSORG</b>  or an <a href="#L06D">END</a> pseudo opcode, or the source code runs out.</p>
<p>Keep in mind that at assembly time, each <b>ABSORG</b>  affects only the addresses the object code will be assembled for. A typical object file will still be output and later loaded as a whole. If there is executable code that is meant to run at somewhere other than the load address, there must be some means of getting the executable to that address.</p>
<p>The value of monolithic organization lies primarily in its simplicity. It is easy to understand and easy to start programming in.</p>
<p>However, in simple hardware architectures, in principle nothing can stop an assembly language program from freely mixing together executable code, constant data and variable locations. This can become dangerous. Assembly programmers can easily overwrite memory locations that are not meant to be overwritten.</p>
<p>Therefore, in practice these are usually separated into separate memory blocks, both for safety and consistency.</p>
<p>To accomplish this with monolithic source code often means placing constant data and variable locations far away from the executable code that will use them. This can make the source code hard to work with as programs become larger and jumping around while editing source code becomes more common.</p>
<a id="L010"></a>
<h4>Segmented</h4>
<p>HXA provides segments as an optional method of program organization. Using this, assembly programmers have a greater degree of control over how and where object code is placed in the output. Object code can be output in a different order than the source code order.</p>
<p>As used here, a <em>segment</em> is just a block of consecutive memory addresses without any internal gaps. There can be gaps between segments, but not within them. A segmented program consists of one or more of these memory blocks.</p>
<p>A segmented program can be explicitly declared by using the optional <a href="#L011">USESEGMENTS</a> pseudo opcode. Alternatively, use of the <a href="#L012">SEGMENT</a> pseudo opcode will itself implicitly declare a program to be segmented.</p>
<p>In segmented programs, all segments are explicitly named by the programmer. These names have their own namespace, so if necessary they can match <a href="#L01D">label</a> names without conflict (though this is not recommended).</p>
<p>The first use of any name establishes the existence of that segment. It also creates the first segment <em>fragment</em>.</p>
<p>A segment fragment consists of a named group of zero or more source code lines delimited by a matched pair of <b>SEGMENT..ENDSEGMENT</b>  pseudo opcodes. The grouped source lines are called the <em>body</em> of the segment fragment.</p>
<p>Segment names are not case-sensitive, and can be re-used at any time. Each use of the same name creates a segment <em>fragment</em> belonging to the same segment as the first. Regardless of where they appear in the source code, all segment fragments with the same name are part of the same segment.</p>
<p>Segment fragments may be nested to any depth by directly nesting <b>SEGMENT..ENDSEGMENT</b>  pairs. It is legal for a fragment to nest inside another fragment of the same segment. In such cases, in the output file the nested fragment will succeed the one it is nesting in.</p>
<p>Every segment fragment causes a nested <a href="#L00D">local scope</a> to be created without ending the existing one. As each fragment ends, so does the nested local scope it created. The local scope the fragment interrupted is restored.</p>
<p>When an object file is produced, all the fragments of a segment are brought together and output as a single block. The fragment order is the same as the order they first appeared in the source code. The segment order is the same as the order segment names first appeared in the source code. Output files are thus in segment order first, and then fragment order within each segment.</p>
<p>One way to control the segment output order is to create a <em>segment map</em> near the start of the source code. The simplest such map simply creates one empty fragment for every named segment, in the order the segments should be output. This allows convenient changes to the "map" whenever necessary.</p>
<p>Named segments can have one of six basic types:</p>
<ul> <li><a href="#L06C">absolute origin</a>; starts at a specified address</li>
 <li><a href="#L015">absolute end</a>; ends at a specified address</li>
 <li><a href="#L014">relative origin</a>; starts at the end of the preceeding segment; the default type</li>
 <li><a href="#L016">relative end</a>; ends at the start of the succeeding segment</li>
 <li><a href="#L017">pad to</a>; starts at the end of the preceeding segment, ends at a specified address</li>
 <li><a href="#L018">pad from</a>; starts at specified address, ends at the start of the succeeding segment</li>
 </ul>
<p>Once a segment has a type, that type cannot be changed.</p>
<p>There must be <b>at least one absolute segment</b> , but any others can be relative. If there <em>is</em> only one absolute segment, all its predecessors must be relative end, and all its successors must be relative origin.</p>
<p>Every segment maintains its own program counter, which is the same size as the single program counter of a monolithic program. No individual segment program counter is allowed to have a value outside of the what the <a href="#L06A">CPU</a> in use allows. When all the segments are made absolute, they collectively are not allowed to have such a value.</p>
<p>If a segment is <em>not</em> absolute origin, the only labels within it which have a value known during the first pass are those defined by <a href="#L078">EQU</a>. The values of all other labels in these segments depend directly or indirectly on the segment program counter. Because during the first pass HXA tracks offsets within segments rather than absolute addresses, every use of a label value or segment program counter from any non-absolute origin segment is a <a href="#L02A">forward reference</a>.</p>
<p>In general this does not cause any difficulty, as HXA resolves (or forbids) these references as it does all forward references. However, because <em>all</em> references to labels defined in non-absolute origin segments are forward, some expressions which work perfectly well in monolithic programs will fail in segmented programs.</p>
<p>For example, in a monolithic program the value of any label which appears in the label column of a source line is available for use in any expression context. But in non-absolute origin segments, similar labels can be used in constant expressions only if they were part of an <b>EQU</b>  assignment.</p>
<p>In segmented source code, no segment program counter has any value outside a segment fragment. Between segment fragments, it is a fatal error to use any pseudo opcode or cpu mnemonic that relies on a defined program counter value.</p>
<p>Segments offer the advantage that in the source executable code can be placed near the constant data and variable locations it will use, yet in the object code these will all still be cleanly separated from each other. The main disadvantage is that segments require explicit management.</p>
<hr>
<a id="L011"></a>
<h4>USESEGMENTS</h4>
<h4>Usage</h4>
<blockquote> <b>USESEGMENTS</b><br> </blockquote>
<h4>Description</h4>
<p>Explicitly instructs HXA to treat the source program as <a href="#L010">segmented</a> rather than <a href="#L00F">monolithic</a>.</p>
<p><b>USESEGMENTS</b>  can be used as often as desired, both inside and outside segments, but only the first use actually does anything. If it is used <em>before</em> the first <a href="#L06C">ABSORG</a> pseudo opcode, the source code is treated as describing a segmented program. If after, a fatal error occurs, because no program can be both segmented and monolithic at the same time.</p>
<p><b>USESEGMENTS</b>  is optional, as the <a href="#L012">SEGMENT</a> pseudo opcode implicitly performs the same task. However, it can help make programmer intent clearer.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L127">"USESEGMENTS" psop</a></li>
 </ul>
<hr>
<a id="L012"></a>
<h4>SEGMENT</h4>
<h4>Usage</h4>
<blockquote> <b>SEGMENT</b>  name<br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>name</em> is a <a href="#L009">global_name</a></li>
 </ul>
<h4>Description</h4>
<p>Marks the start of a segment fragment.</p>
<p>Segment names are <em>not</em> case-sensitive, nor are they unique. Every fragment with the same name belongs to the same segment.</p>
<p>Every segment fragment causes a nested <a href="#L00D">local scope</a> to be created without ending the existing one. As each fragment ends, so does the nested local scope it created.</p>
<p>Segment fragments may be nested to any depth by directly nesting <b>SEGMENT..ENDSEGMENT</b>  pairs. It is legal for a fragment to nest inside another fragment of the same segment.</p>
<p>Where a nested fragment appears in an output file depends on where it was first created in the source code. A fragment nested inside a fragment with the same name appears directly after that fragment does.</p>
<hr>
<a id="L013"></a>
<h4>ENDSEGMENT</h4>
<h4>Usage</h4>
<blockquote> <b>ENDSEGMENT</b>  <em>[name]</em><br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>name</em> is an optional <a href="#L009">global_name</a></li>
 </ul>
<h4>Alias</h4>
<ul> <li><b>ENDS</b>  <em>[name]</em></li>
 </ul>
<h4>Description</h4>
<p>Marks the end of a <a href="#L012">segment fragment</a>.</p>
<p>If a <em>name</em> is present, it must be the same as the one used with the matching <a href="#L012">SEGMENT</a> pseudo opcode.</p>
<p>If the segment is not nested inside another fragment, <a href="#L029">program counter</a> will have no value at all until the next <a href="#L012">SEGMENT</a> pseudo opcode. If it is, the program counter will instead revert to the value it had when the nesting started.</p>
<hr>
<a id="L014"></a>
<h4>RELORG</h4>
<h4>Usage</h4>
<blockquote> <b>RELORG</b><br> </blockquote>
<h4>Description</h4>
<p>Marks a <a href="#L012">segment</a> as <em>relative origin</em>.</p>
<p>This is the default segment type. If a segment is never given an explicit type, it will become relative origin during the second pass.</p>
<p>Its first memory location will be one <em>after</em> the absolute address that marks the end address of its predecessor. That is, one past the last address actually used by that segment.</p>
<p><b>RELORG</b> :</p>
<ul> <li>is the default segment type of any segment that has no other type</li>
 <li>can be used anywhere in any fragment of a segment, any number of times</li>
 <li>can be used only within segment fragments, never outside them</li>
 <li>marks the entire segment as <em>relative origin</em> if used within any fragment of that segment</li>
 <li>cannot be the first segment of any program</li>
 </ul>
<p>A <b>RELORG</b>  segment can only follow segments of type <a href="#L06C">ABSORG</a>, <b>RELORG</b> , <a href="#L015">ABSEND</a> and <a href="#L017">PADTO</a>. One cannot follow a segment of type <a href="#L016">RELEND</a> or <a href="#L018">PADFROM</a>.</p>
<p>Addresses in <b>RELORG</b>  segments are always relative during the first pass. The absolute addresses of whatever code and data they contain cannot be determined until their final sizes are known. Thus references to locations and labels within them are always <a href="#L02A">forward references</a>.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L140">"RELORG" Pseudo Op</a></li>
 </ul>
<hr>
<a id="L015"></a>
<h4>ABSEND</h4>
<h4>Usage</h4>
<blockquote> <em>[label]</em> <b>ABSEND</b>  <em>address</em><br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>label</em> is an optional legal <a href="#L01D">label</a></li>
 <li><em>address</em> is a <a href="#L009">cpu_addr</a></li>
 </ul>
<h4>Description</h4>
<p>Marks a <a href="#L012">segment</a> as <em>absolute end</em>.</p>
<p>Its last memory location will be one <em>before</em> the address represented by <em>address</em>. That is, at <em>address</em>-1.</p>
<p>If <em>label</em> is present, it will be assigned the value of <em>address</em>. The segment program counter itself is not changed.</p>
<p><b>ABSEND</b> :</p>
<ul> <li>must be used before any code or data is stored in any fragment of a segment</li>
 <li>can be used any number of times in any segment fragment, but in any single segment must have the same <em>address</em> value each time</li>
 <li>can be used only within segment fragments, never outside them</li>
 <li>marks the entire segment as <em>absolute end</em> if used within any fragment of that segment</li>
 </ul>
<p>Every segmented program must have at least one absolute segment. If the only absolute segment is absolute end, it can be preceeded only by <a href="#L016">relative end</a> segments and succeeded only by <a href="#L014">relative origin</a> ones.</p>
<p>Addresses in <b>ABSEND</b>  segments are always relative during the first pass. The absolute addresses of whatever code and data they contain cannot be determined until their final sizes are known. Thus references to locations and labels within them are always <a href="#L02A">forward references</a>.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L141">"ABSEND" and "RELEND" Pseudo Ops</a></li>
 </ul>
<hr>
<a id="L016"></a>
<h4>RELEND</h4>
<h4>Usage</h4>
<blockquote> <b>RELEND</b><br> </blockquote>
<h4>Description</h4>
<p>Marks a <a href="#L012">segment</a> as <em>relative end</em>.</p>
<p>Its last memory location will be one <em>before</em> the absolute address that marks the start of its successor.</p>
<p><b>RELEND</b> :</p>
<ul> <li>must be used before any code or data is stored in any fragment of a segment</li>
 <li>can be used any number of times in any segment fragment</li>
 <li>can be used only within segment fragments, never outside them</li>
 <li>marks the entire segment as <em>relative end</em> if used within any fragment of that segment</li>
 <li>cannot be the last segment of any program</li>
 </ul>
<p>A <b>RELEND</b>  segment can only precede segments of type <a href="#L06C">ABSORG</a>, <b>RELEND</b> , <a href="#L015">ABSEND</a> and <a href="#L018">PADFROM</a>. One cannot precede a segment of type <a href="#L014">RELORG</a> or <a href="#L017">PADTO</a>.</p>
<p>Addresses in <b>RELEND</b>  segments are always relative during the first pass. The absolute addresses of whatever code and data they contain cannot be determined until their final sizes are known. Thus references to locations and labels within them are always <a href="#L02A">forward references</a>.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L141">"ABSEND" and "RELEND" Pseudo Ops</a></li>
 </ul>
<hr>
<a id="L017"></a>
<h4><b>PADTO</b></h4>
<h4>Usage</h4>
<blockquote> <b>PADTO</b>  address <em>[, value]</em><br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>address</em> is a <a href="#L009">cpu_addr</a></li>
 <li><em>value</em> is an optional <a href="#L009">hex_str</a></li>
 </ul>
<h4>Description</h4>
<p>Inserts octets into the object code until the <a href="#L029">program counter</a> is a multiple of <em>address</em>.</p>
<p>That is, if the remainder of dividing the current value of the program counter by <em>address</em> is non-zero, octets are inserted until it is. If the remainder is already zero, <b>PADTO</b>  does nothing.</p>
<p>For example,</p>
<blockquote> <b>PADTO</b>  2<br> </blockquote>
<p>inserts one zero octet into the output if the value of the program counter is odd. Otherwise it does nothing.</p>
<p>Note that if <em>address</em> is larger than the value of the program counter at the time padding starts, it essentially represents an absolute address. This is where the where the first zero remainder will occur.</p>
<p>By default <b>PADTO</b>  inserts zero octets (0x00) into the object code. If <em>value</em> is supplied, its octets are used instead. These are taken from <em>value</em> in the same left-to-right order they appear, regardless of <a href="#L06A">CPU</a> multi-byte orientation or <a href="#L0AD">non-standard byte</a> size.</p>
<p>The size of <em>value</em> does not have to be an integer multiple of the size required to fill out any padding. <b>PADTO</b>  uses only as many octets of <em>value</em> as needed. If there are not enough, <em>value</em> is duplicated as often as required.</p>
<p>In <a href="#L00F">monolithic</a> source, <b>PADTO</b>  may be used any number of times with any <em>value</em>. Each time it is executed immediately. Any padding appears in the <a href="#L056">listing</a> file and object code starting at the current value of the program counter.</p>
<p>In <a href="#L010">segmented</a> source, padding is delayed until address resolution occurs during pass two. If the segment is listed, any padding appears in the <a href="#L062">object section</a>, after the end of the source code. <b>PADTO</b>  segments appear as separate segments in the segment map listing and in the object code.</p>
<p>A <b>PADTO</b>  segment can only follow segments of type <a href="#L06C">ABSORG</a>, <a href="#L014">RELORG</a>, <a href="#L015">ABSEND</a> and <b>PADTO</b> . One cannot follow a segment of type <a href="#L016">RELEND</a> or <a href="#L018">PADFROM</a>, nor can it be the first named segment.</p>
<p>Any particular segment may use this pseudo opcode any number of times, but it must have the same <em>address</em> and <em>value</em> each time. Different segments may use different values for <b>PADTO</b> .</p>
<p>Segments cannot be both padded and <a href="#L019">uninitialized</a>.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L147">Pad To Specific Byte Boundary</a></li>
 </ul>
<hr>
<a id="L018"></a>
<h4><b>PADFROM</b></h4>
<h4>Usage</h4>
<blockquote> <b>PADFROM</b>  address <em>[, value]</em><br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>address</em> is a <a href="#L009">cpu_addr</a></li>
 <li><em>value</em> is an optional <a href="#L009">hex_str</a></li>
 </ul>
<h4>Description</h4>
<p>Inserts octets into the object code, starting at <em>address</em> and continuing until the start of the segment that follows it.</p>
<p>Marks its <a href="#L012">segment</a> as padded.</p>
<p>By default, <b>PADFROM</b>  inserts zero octets (0x00) into the object code. If <em>value</em> is supplied, its octets are used instead. These are taken from <em>value</em> in the same left-to-right order they appear, regardless of <a href="#L06A">CPU</a> multi-byte orientation or <a href="#L0AD">non-standard byte</a> size.</p>
<p>The size of <em>value</em> does not have to be an integer multiple of the size required to fill out any padding. <b>PADFROM</b>  uses only as many octets of <em>value</em> as needed. If there are not enough, <em>value</em> is duplicated as often as required.</p>
<p><b>PADFROM</b>  can <em>only</em> be used in segmented programs. Padding is delayed until address resolution occurs during pass two. If the segment is listed, any padding appears in the <a href="#L062">object section</a>, after the end of the source code. <b>PADFROM</b>  segments appear as separate segments in the segment map listing in the object code.</p>
<p>A <b>PADFROM</b>  segment can precede any segment of type <a href="#L06C">ABSORG</a>, <a href="#L015">ABSEND</a>, <a href="#L016">RELEND</a> or <b>PADFROM</b> . One cannot precede a segment of type <a href="#L014">RELORG</a> or <a href="#L017">PADTO</a>, nor can it be the last named segment.</p>
<p>Any particular segment may use <b>PADFROM</b>  any number of times, but it must have the same <em>address</em> and <em>value</em> each time. Different segments may use different values for <b>PADFROM</b> .</p>
<p>Segments cannot be both padded and <a href="#L019">uninitialized</a>.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L148">Pad From Specific Byte Boundary</a></li>
 </ul>
<hr>
<a id="L019"></a>
<h4><b>UNINITIALIZED</b></h4>
<h4>Usage</h4>
<blockquote> <b>UNINITIALIZED</b><br> </blockquote>
<h4>Alias</h4>
<ul> <li><b>NODATA</b></li>
 </ul>
<h4>Description</h4>
<p>Explicitly flags a <a href="#L012">segment</a> as containing no code or data.</p>
<p>This pseudo opcode can be first used in any fragment of a segment, as long as the segment program counter has not yet changed. It can be used any number of times after that.</p>
<p>Once a segment has been flagged as uninitialized, any attempt to store data in that segment is an error.</p>
<p>Every uninitialized segment has starting and ending addresses and a length, but has no offset value in the output file. It contains no code or data, and will not be output.</p>
<p>The <a href="#L01A">COMMON</a> and <a href="#L076">DS</a> pseudo opcodes can be used in uninitialized segments. They also implicitly flag a segment as <b>UNINITIALIZED</b>  if it has not already been set.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L13E">Uninitialized Segments</a></li>
 </ul>
<hr>
<a id="L01A"></a>
<h4><b>COMMON</b></h4>
<h4>Usage</h4>
<blockquote> <b>COMMON</b><br> </blockquote>
<h4>Description</h4>
<p>Flags an uninitialized <a href="#L012">segment</a> in which all fragments overlap.</p>
<p>Normally, all fragments of a segment follow each other in consecutive order. <b>COMMON</b>  flags that each fragment begins at the segment's start address. That is, all fragments of the segment overlap each other. The size of the segment is the size of its largest fragment.</p>
<p>Implicitly flags a segment as <a href="#L019">UNINITIALIZED</a> if it is not already so.</p>
<p>This pseudo opcode can be first used in any fragment of a segment, as long as the segment <a href="#L029">program counter</a> has not yet changed. It can be used any number of times after that.</p>
<p>Once a segment has been flagged as common, any attempt to store data in that segment is an error.</p>
<p>Every common segment has starting and ending addresses and a length, but has no offset value in the output file. It contains no code or data, and will not be output.</p>
<p>The <b>COMMON</b>  pseudo op is designed to simplify management of "scratch" memory in segmented source code. A single memory block may be re-divided by the <a href="#L076">DS</a> pseudo opcode as convenient. That is, multiple temporary variables with names convenient for whatever routine is using them can occupy the same space (though of course not at the same time).</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L13F">Common Segments</a></li>
 </ul>
<a id="L025"></a>
<a id="L01C"></a><h3>Input File</h3>
<p>HXA accepts standard UTF-8 text files as source code. Each line of a text file is treated as a separate source code line.</p>
<p>A source code line may consist of up to four logical fields:</p>
<p>LABEL&nbsp;&nbsp;OPCODE&nbsp;&nbsp;EXPRESSION&nbsp;&nbsp;COMMENT</p>
<p>These fields are separated from each other by one or more whitespace characters. Each field is optional, but if present must appear in the order shown. The only restriction is that expressions <em>must</em> follow an opcode; they cannot appear alone or directly following a label.</p>
<p>Malformed source lines are an error.</p>
<p>Note that the actual column position of any field within a source code line is not important to HXA. <em>What</em> a field represents is more important than <em>where</em> it is.</p>
<h4>Examples</h4>
<ul> <li>LABEL</li>
 <li>LABEL&nbsp;&nbsp;OPCODE</li>
 <li>LABEL&nbsp;&nbsp;OPCODE&nbsp;&nbsp;EXPRESSION</li>
 <li>LABEL&nbsp;&nbsp;COMMENT</li>
 <li>OPCODE</li>
 <li>OPCODE&nbsp;&nbsp;EXPRESSION</li>
 <li>OPCODE&nbsp;&nbsp;COMMENT</li>
 <li>COMMENT</li>
 </ul>
<hr>
<a id="L01D"></a>
<a id="L01E"></a><h4>Label Field</h4>
<p>Labels in the label field are symbolic names for single values. Labels acquire values either by explicit assignment or implicitly by simply being present. Those labels can then be used in expressions in place of the literal values they represent.</p>
<p>Using symbolic names for values has at least three great advantages over using the values directly:</p>
<ul> <li>a well-chosen name is much easier to remember than an obscure value</li>
 <li>if the value associated with a name is ever changed, it is guaranteed that every use of that name is automatically updated</li>
 <li>if the same value has different meanings in different contexts, then giving that value a different name for each different context helps keep each use of it clear</li>
 </ul>
<p>There are two types of labels, <em>numeric</em> and <em>string</em>, indicating the type of the value associated with them. A string label has a dollar sign ('$', ASCII 0x24) suffix as the last character of its name. A numeric label has no suffix at all.</p>
<p>Labels in the label field generally are normally assigned the current value of the <a href="#L029">program counter</a>. HXA makes this assignment automatically; in most cases a programmer does not know (or need to know) what the actual value of such a label is.</p>
<p>Most labels are of this kind, being symbolic representations of memory address values. If the label is numeric, it can be used directly. If the label is string, the value takes the form of a decimal string representation of the same memory address.</p>
<p>The only exceptions are for the pseudo opcodes <a href="#L078">EQU</a>, <a href="#L079">PLUSEQU</a> and <a href="#L07A">MINUSEQU</a>. The <b>EQU</b>  pseudo opcode assigns the result of evaluated expression on its right to the label on its left. <b>PLUSEQU</b>  and <b>MINUSEQU</b>  add and subtract the evaluated expressions on their right to the <a href="#L023">variable</a> label on their left.</p>
<p>However a label acquires a value, it can then be used in expressions in place of the same literal value.</p>
<a id="L01F"></a>
<h4>Basic Form of Named Labels</h4>
<p>Named labels are <em>not</em> case sensitive, although alphabetic characters of either case may be used.</p>
<p>In basic form, the first character of a named label starts with an uppercase alphabetic ('A' - 'Z', ASCII 0x41-0x5A), a lowercase slphabetic ('a' - 'z', ASCII 0x61-0x7A) or underscore ('_', ASCII 0x5F) character. This can be followed by zero or more alphabetic or numeric ('0' to '9', ASCII 0x30-0x39) or underscore or period ('.', ASCII 0x2E) characters.</p>
<p>Period chacters are restricted. They cannot be the first or last character of a named label, nor can they be consecutive. This means that each one can appear in label names <em>only between</em> two non-period characters.</p>
<p>If a label is of type string, it must have a dollar sign suffix ('$', ASCII 0x24).</p>
<p>For visual and editor distinctiveness, an optional colon (':', ASCII 0x3A) may be the last character of all named labels. Internally, these are stripped off and only non-colon characters are meaningful. The same name with or without a colon suffix can be used interchangeably to represent the same value in both the label and <a href="#L026">expression</a> fields.</p>
<p>Note that a colon on the first field of a source code line forces HXA to recognize the field as a label and <em>not</em> an opcode.</p>
<p>If a new label must be defined to have the same name as an existing <a href="#L080">macro</a>, putting a colon on its end will prevent confusion between them. Note that this does <em>not</em> work the other way. It is not possible to define a macro with the same name as an existing label.</p>
<p>By default, program listings show only the values of <a href="#L020">global</a> labels. To show the value of all labels in a program, use the <b>ALLEQU</b>  flag of the <a href="#L061">LISTON</a> pseudo opcode.</p>
<p>Named labels may be of any length desired. However, in a default <a href="#L056">listing</a> file they will be truncated to the first 18 characters.</p>
<h4>Examples</h4>
<ul> <li>myLabel</li>
 <li>_mylabel$</li>
 <li>my.label</li>
 <li>mylabel$:</li>
 <li>wname</li>
 <li>__XName__$</li>
 <li>y.n.a.m.e</li>
 <li>Z_Name:</li>
 </ul>
<hr>
<a id="L020"></a>
<h4>Global Labels</h4>
<p>Global label names have the same <a href="#L01F">basic form</a> as all named labels.</p>
<p>Global labels, as their name implies, have global scope. The value represented by a global label can be accessed from anywhere in the source code.</p>
<p>Global labels are fixed. Once assigned a value, that value cannot be changed. However, the same value may be assigned to the same global label any number of times.</p>
<p>Global label names must be unique. No two global labels can have the same name.</p>
<p>In general, global label names which match processor instruction mnemonics, assembler pseudo opcodes, or defined macro names should be avoided. Global labels in the first field of source code line which match any of these <em>will not</em> be recognized correctly.</p>
<p>However, a global name with a colon suffix will not match any name except the same global name. This can be used to force HXA to recognize a global name as something that cannot be confused with anything else.</p>
<p>A global label in the label field of a source code line creates a new local <a href="#L00D">scope</a> in the current source file. The current local scope terminates and a new one at the same level begins.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0D1">Global Labels</a></li>
 </ul>
<hr>
<a id="L021"></a>
<h4>Pre-Defined Labels</h4>
<p>Pre-defined labels all have the same form and behavior as <a href="#L020">global</a> labels. However, they begin and end with a double underscore ('__', ASCII 0x5F5F), a form unavailable to programmers. They may be referenced in any legal context, but they cannot be assigned values. They are available for use as soon as HXA begins reading source code.</p>
<p>All versions of HXA define at least three labels. Additional labels may be optionally defined by the HXA variant in use.</p>
<ul> <li><b>__HXA__</b>  : identifies the assembler as one of the HXA assemblers</li>
 <li>the value is <em>TRUE</em></li>
 </ul>
<ul> <li><b>__VER__</b>  : the assembler version number</li>
 <li>the value is 32 bits in binary coded decimal (BCD)</li>
 <li>12 - 31 : major version number</li>
 <li>08 - 11 : minor version number, tenths place</li>
 <li>04 - 07 : minor version number, hundredths place</li>
 <li>00 - 03 : bug fix and/or internal revision with no external change</li>
 </ul>
<h4>Examples</h4>
<ul> <li>1.000 : 0x00001000, the first major release</li>
 <li>0.200 : 0x00000200, an upgrade release</li>
 <li>0.121 : 0x00000121, a bugfix release</li>
 <li>0.100 : 0x00000100, the lowest actually released version number</li>
 <li><a href="hxa_test.htm#L0D7">Pre-Defined Labels</a></li>
 </ul>
<p>It is unlikely that 99,999 major versions will ever be released.</p>
<ul> <li><b>__VER__$</b>  : the assembler version string</li>
 </ul>
<h4>Examples</h4>
<ul> <li>1.000 : 'HXA v1.000'</li>
 <li>0.200 : 'HXA v0.200'</li>
 <li>0.121 : 'HXA v0.121'</li>
 <li>0.100 : 'HXA v0.100'</li>
 <li><a href="hxa_test.htm#L0D7">Pre-Defined Labels</a></li>
 <li><a href="hxa_test.htm#L188">Reserved Names</a></li>
 </ul>
<hr>
<a id="L022"></a>
<h4>Local Labels</h4>
<p>Local labels have the same <a href="#L01F">basic form</a> as all named labels, except the first name character is always the at sign ('&#64;', ASCII 0x40).</p>
<p>Local labels, as their name implies, have local <a href="#L00D">scope</a>. Their values are maintained only within the current local scope.</p>
<p>The value represented by a particular local label cannot be accessed outside of the scope it is created in. Expressions within one local scope cannot successfully "reach out" of it to use the value of any local label in another scope.</p>
<p>Local labels are fixed within their scope. Once assigned a value, that value cannot be changed. However, the same value may be assigned to the same local label in the same local scope any number of times.</p>
<p>Local label names within the same local scope must be unique. Local labels in different local scopes may have the same name.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0D2">Local Labels</a></li>
 </ul>
<hr>
<a id="L023"></a>
<h4>Variable Labels</h4>
<p>Variable labels have the same <a href="#L01F">basic form</a> as all named labels, except the first name character is always the right square bracket (']', ASCII 0x5D).</p>
<p>Variable labels have global scope. The current value represented by one of these labels can be accessed from anywhere in the source code.</p>
<p>Variable labels, as their name implies, are not fixed. The value represented by a variable label can be changed at any time.</p>
<p>Variable label names are by default unique. Any use of a particular variable label name is considered to refer to the same variable label.</p>
<p>References to variable labels normally represent the value they were most recently assigned. If they appear in a <a href="#L056">listing</a> file, it will show only the last value assigned to them.</p>
<p>In expressions, variable labels should usually be used only for backward references. That is, they should appear in a label field before they are used in an expression field. This way they have a known value when first referenced in an expression.</p>
<p>HXA does permit <a href="#L02A">forward reference</a> to variable labels, but this usage is obscure and difficult to use successfully.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0D3">Variable Labels</a></li>
 </ul>
<hr>
<a id="L024"></a>
<h4>Anonymous Labels</h4>
<p>Anonymous labels (sometimes called <em>branch target</em> labels) are <em>not</em> unique. There are only three names: a plus sign ('+', ASCII 0x2B), a minus sign ('-', ASCII 0x2D), and a colon (':', ASCII 0x3A).</p>
<p>Anonymous labels have global scope. They can be referred to from anywhere in the source code.</p>
<p>Anonymous labels are meant to mark object code locations that do not need a named label and relieve a programmer from making one up. Each time an anonymous name is first encountered, HXA will create a new internal name for it. Externally, all anonymous names appeqr the same. Internally, each is unique.</p>
<p>Anonymous labels are fixed. Once its internal name is assigned a value, that value cannot be changed.</p>
<p>A plus sign stands for a <em>forward</em> location in the source code. A minus sign stands for a <em>backward</em> location in the source code. They can be used as a pair, either '<em>+-</em>' or '<em>-+</em>', to stand for a location that can be (but isn't required to be) both.</p>
<p>A colon likewise stands for both types of location. It can always be used wherever an anonymous label is needed. If desired, it can be the only anonymous name ever used in the label field. There is no penalty for doing this, nor for using either plus-minus pair for all anonymous names.</p>
<p>To mark a source location as anonymous, use an anonymous name in the label field. There are no restrictions on how often any of the three names may be used.</p>
<p>Anonymous labels in the label field can be referred to in the expression field of any source code line. The terms <em>forward</em> and <em>backward</em> in this context mean where in the source code these names appear in relation to references to them.</p>
<p>If an anonymous name appears in a label field <em>before</em> the first reference to it in an expression field, each later reference is backward. The name must include either a minus sign or be a colon.</p>
<p>If an anonymous name appears in a label field <em>after</em> the first reference to it in an expression field, every earlier reference is forward. The name must include either a plus sign or be a colon.</p>
<p>Anonymous labels most often appear on a source code line either by themselves or together with a processor instruction mnemonic. Therefore the value of the name is usually the current value of the program counter.</p>
<p>HXA actually permits anonymous labels to be used with any <a href="#L069">pseudo opcodes</a> which accept labels, but this usage is unusual and generates a warning. If an anonymous label really is meant to refer to the location of a pseudo opcode, the warning can be avoided by placing the label on a line by itself and the pseudo opcode on the next following line.</p>
<p>In the expression field, references to anonymous labels are considered references to numeric labels .</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0D4">Branch Target Labels</a></li>
 </ul>
<hr>
<a id="L025"></a><h4>Opcode Field</h4>
<p>Any of these can be used in the Opcode Field of a source line:</p>
<ul> <li>a <a href="#L068">pseudo opcode</a></li>
 <li>a <a href="#L080">macro</a> name</li>
 <li>a processor opcode (<em>aka</em> instruction mnemonic)</li>
 </ul>
<p>They are checked in this order. This means, for example, that a macro name which matches a processor opcode will "hide" that opcode.</p>
<hr>
<a id="L026"></a>
<a id="L027"></a><h4>Expression Field</h4>
<p>HXA supports both <em>numeric</em> and <em>string</em> expressions.</p>
<p>Legal expressions consist of at least one operand and zero or more <a href="#L052">operators</a>. Operands and operators may be separated by whitespace for clarity.</p>
<a id="L028"></a><h4>Operands</h4>
<p>HXA is not limited in the range of integer numeric values it can accept or produce. Expressions may create any integer value required.</p>
<p>However, any value that is intended to be <a href="#L056">listed</a>, or stored in an object file, cannot exceed the range of a 32-bit integer. That is, decimal [-4294967296, 4294967295] or hexadecimal [-0x10000000, 0xFFFFFFFF].</p>
<h4>Numeric Labels</h4>
<p><a href="#L020">Global</a>, <a href="#L022">local</a> and <a href="#L023">variable</a> numeric labels may be used wherever a numeric value is expected. When referenced, the value of the label is used during evaluation.</p>
<p>References to <a href="#L024">anonymous</a> labels in expressions are slightly different. These consist of a prefix colon (':', ASCII 0x3A) character immediately followed by one or more plus ('+', ASCII 2B) or minus ('-', ASCII 0x2d) signs. Sequences of plus signs designate forward references, while sequences of minus signs designate backward references.</p>
<p>The number of plus or minus signs indicate which anonymous label is being referred to. For sequences of plus signs, HXA counts each succeeding label which is either a colon or contains a plus sign. For sequences of minus signs, HXA counts each preceding label which is either a colon or contains a minus sign.</p>
<p>For example, in an expression '<em>:+</em>' refers to the very next forward anonymous label from the current position. Then '<em>:++</em>' refers to the second forward, '<em>:+++</em>' to the third forward, and so on. The expression '<em>:-</em>' refers to the most recent preceding anonymous target label, '<em>:--</em>' to the one before that, and so on.</p>
<p>HXA is not confused by anonymous references of any length or distance. However, programmers may find that beyond the nearest three or so in either direction, they become difficult to follow in source code.</p>
<p>With the colon prefix, anonymous references can be used in any numeric expression (although they may need to separated from an immediately following plus or minus operator by whitespace). If an anonymous reference is the only term in an expression (ie., it appears alone without any other operators or operands), then the colon prefix is optional and may be omitted.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0D5">All Label Forms</a></li>
 </ul>
<h4>String Labels</h4>
<p><a href="#L020">Global</a>, <a href="#L022">local</a> and <a href="#L023">variable</a> string labels may be used wherever a string value is expected. When referenced, the string value of the label is used during evaluation.</p>
<p>String labels may also be used in some circumstances where a numeric value is expected. In these cases a string value is subject to an implied comparison against the null string before any numeric operator is applied. The result of the comparision is either zero (string was null) or one (string was <em>not</em> null).</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0D6">String Labels</a></li>
 </ul>
<hr>
<a id="L029"></a>
<h4>Program Counter</h4>
<p>The <em>program counter</em> is used to determine the proper addresses of assembled object code and data. It has no default value. References to it are invalid before it has one.</p>
<p>In <a href="#L00F">monolithic</a> programs, there is only one program counter.</p>
<ul> <li>it must be explicitly set by an <a href="#L06C">ABSORG</a> pseudo opcode, somewhere between a <a href="#L06A">CPU</a> pseudo opcode and the first source code line that generates code or data</li>
 <li>it can be reset any number of times to any legal address value</li>
 </ul>
<p>In <a href="#L010">segmented</a> programs, each segment has its own program counter:</p>
<ul> <li>at least one segment must explicitly be made absolute by either <a href="#L06C">ABSORG</a> or <a href="#L015">ABSEND</a>, but is optional for all others</li>
 <li>it can be set only within segment fragments, never outside them</li>
 <li>cannot be set after the first source code line that generates code or data in that segment (the segment will instead be <a href="#L014">relative origin</a>)</li>
 <li>can be set any number of times in any segment, but must have the same address value each time</li>
 </ul>
<p>In either case, the current value of the program counter is represented in expressions by either an asterisk ('&ast;', ASCII 0x2A) or a dollar sign ('$', ASCII 0x24). It is an unsigned value between zero and the maximum the <a href="#L06A">CPU</a> in use allows (plus one, though no data may be stored at this last address).</p>
<p>Every source code line that generates code or data updates the value of the program counter by the size of that code or data. Every time the value of the program counter changes, it is checked against the legal range of values it may assume for the current processor.</p>
<p>The program counter value may be used wherever a numeric value is expected.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0D8">Program Counter Reference</a></li>
 </ul>
<hr>
<a id="L02A"></a>
<h4>Forward Reference</h4>
<p>A symbol is <em>forward referenced</em> when it is used as an operand in an expression, but its actual value is not known at the time it is first encountered.</p>
<p>In <a href="#L00F">monolithic</a> programs, only <a href="#L01D">labels</a> have this property. It is assumed that sooner or later the label will appear in the label field and thereby acquire a known value. If a label never does, an error will occur on the second pass each time it is referenced in an expression.</p>
<p>In <a href="#L010">segmented</a> programs, during the first pass every segment that is <em>not</em> <a href="#L06C">absolute origin</a> has only unknown values for both its labels and its <a href="#L029">program counter</a>. Only after the first pass is complete will all unknown values become known and fixed.</p>
<p>HXA allows forward reference in any construct which ultimately generates code or data of a known size, such as cpu instruction mnemonics or <a href="#L06E">BIT--</a> pseudo opcodes. HXA saves any partially evaluated expression and completes evaluation during the second pass. At this point all segment program counters have been made absolute and the value of all labels are known.</p>
<p>HXA forbids forward reference whenever the value of an expression must be known during the first pass. These situations include conditional pseudo opcodes such as <a href="#L08D">IF</a>. Here HXA must make a decision when such an expression is first encountered.</p>
<p>Other pseudo opcodes, such as <a href="#L073">STRING</a>, advance the program counter by an amount that must be known during the first pass, so they too do not allow forward reference.</p>
<hr>
<a id="L02B"></a>
<h4>Numeric Literals</h4>
<p>HXA recognizes literal integer numbers in any of <b>C</b> , <a href="#L0A7">Intel</a> or <a href="#L0A9">Motorola</a> formats. In general, programmers should use whichever format they are comfortable with and which will be recognizable to future source code readers.</p>
<p>In most places, this document will use the <b>C</b>  hexadecimal numeric format. A number is assumed to be decimal unless it is prefixed by <em>0b</em> (binary) or <em>0x</em> (hexadecimal).</p>
<p>In all formats, hexadecimal numbers use the first six alphabetic characters <b>A</b>  through <b>F</b>  to stand for the numbers ten through fifteen. The case of the characters does not matter (nor does it for any radix prefix or suffix).</p>
<p>Note that although the '0b' binary prefix is widely recognized, it is not actually part of the <b>C</b>  standard.</p>
<p>Numeric literals may be used wherever a numeric value is expected.</p>
<h4>Example</h4>
<p>The decimal number 192 in <b>C</b>  format:</p>
<ul> <li>binary : 0b1000000</li>
 <li>decimal : 192</li>
 <li>hexadecimal : 0xC0</li>
 </ul>
<a id="L02C"></a>
<h4>Character Literals</h4>
<p>A character literal is a single character code delimited by single quote marks (', ASCII 0x27). A single quote mark may itself be included in a character literal by escaping it with a preceding backslash (\', ASCII Ox5C2C).</p>
<p>A character code may be specified by either its printable Unicode representation or an <a href="#L00C">escape sequence</a>. The numeric value of a printable character is normally the same as its position in the Unicode collating sequence.</p>
<p>If the value of a character code according to the current <a href="#L077">character set translation</a> is desired instead, it can be obtained using the <a href="#L051">XLATE()</a> function.</p>
<p>Character literals may be used wherever a numeric value is expected.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0CE">Character Literals</a></li>
 <li><a href="hxa_test.htm#L0D0">XLATE() and XLATE</a></li>
 </ul>
<hr>
<a id="L02D"></a>
<h4>String Literals</h4>
<p>A string literal is a sequence of zero or more character literals delimited by double quote marks (", ASCII 0x22). A double quote mark may itself be included in a string literal by escaping it with a preceding backslash (\", ASCII 0x5C22).</p>
<p>Each character literal may be specified by either its printable Unicode representation or an <a href="#L00C">escape sequence</a>. The numeric value of each printable character is normally its position in the Unicode collating sequence.</p>
<p>String literals may be used wherever a string value is expected.</p>
<p>String literals may also be used in some circumstances where a numeric value is expected. In these cases strings are converted to numeric values by an implied comparison against the null string before any numeric operator is applied. The result of the comparision is either zero (string is null) or one (string is <em>not</em> null).</p>
<p>Note that <a href="#L077">character set translation</a> occurs only when a string is output to object code. Operations on strings, such as concatenation, comparison and pattern matching, occur earlier and are thus not affected.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0CF">String Literals</a></li>
 </ul>
<hr>
<a id="L02E"></a>
<h4>Regular Expression Literals</h4>
<p>Regular expressions provide a compact and flexible way to specify multiple partial or exact matches to a string. They are provided by HXA mainly as an aid to <a href="#L080">macro</a> creation.</p>
<p>A regular expression pattern literal is a sequence of one or more character codes delimited by forward slashes ('/', ASCII 0x2F) characters. The final forward slash may be optionally followed by a lower case 'i' (ASCII 0x69) to make any match case-insensitive.</p>
<p>Only pattern match operators apply to regular expressions.</p>
<p>A full tutorial in the use of regular expression patterns is beyond the scope of this document. Briefly, a regular expression pattern consists of <em>normal characters</em>, which match those characters, and <em>meta-characters</em>, which match character types, groups or positions. Most of the power of regular expressions is provided by meta-characters singly or in combination with others.</p>
<p>Note that any <a href="#L00C">escape sequences</a> in a regular expression literal are evaluated by both HXA and Python before a pattern match is attempted. If the literal meaning of a metachar is desired, it must doubly <a href="#L00C">escaped</a> to be recognized correctly.</p>
<table><caption>Partial List of Recognized Meta-Characters</caption> <thead> <tr><th>To Match</th><th>Notation</th><th>"abc" Matches</th><th>"abc" Does NOT Match</th></tr> </thead><tbody> <tr><td>any single character</td><td>.</td><td>/a.c/</td><td>/xy./</td></tr> <tr><td>zero or more occurances of a regular expression</td><td>&ast;</td><td>/ax&ast;/</td><td>/axy&ast;/</td></tr> <tr><td>one or more occurances of a regular expression</td><td>+</td><td>/ab+/</td><td>/ax+/</td></tr> <tr><td>zero or one occurance of a regular expression</td><td>?</td><td>/abcd?/</td><td>/abcd?e/</td></tr> <tr><td>at start of string</td><td>^</td><td>/^ab/</td><td>/^abcd/</td></tr> <tr><td>at end of string</td><td>$</td><td>/bc$/</td><td>/cd$/</td></tr> <tr><td>either of two regular expressions</td><td>|</td><td>/abc|def/</td><td>/def|xyz/</td></tr> <tr><td>any character in a set</td><td>[&nbsp;]</td><td>/[cde]/</td><td>/[xyz]/</td></tr> <tr><td>any character NOT in a set</td><td>[^&nbsp;]</td><td>/[^ghi]/</td><td>/[^abc]/</td></tr> </tbody></table>
<p>For a fuller explanation, consult any AWK/GAWK/NAWK reference.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0DD">Regular Expression Operators</a></li>
 </ul>
<hr>
<a id="L02F"></a><h4>Functions</h4>
<p>Function take the form of <a href="#L020">global</a> labels followed by a pair of parentheses ('(', ASCII 0x28 and ')', ASCII 0x29).</p>
<p>There may be zero, one or more expressions between the parentheses. These are the <em>arguments</em> of the functions. If there are more than one, they are separated by comma (',', ASCII 0x2C) characters.</p>
<p>Functions return a string value if their name has a dollar sign ('$', ASCII 0x24) suffix. Otherwise, they return a numeric value.</p>
<ul> <li><a href="#L030">ABS()</a> : absolute value of number</li>
 </ul>
<ul> <li><a href="#L031">CHR$()</a> : Unicode string of length one</li>
 <li><a href="#L032">CPU$()</a> : name of the current CPU</li>
 </ul>
<ul> <li><a href="#L033">DEFINED()</a> : is macro name defined ?; <em>alias</em> ISMACRO()</li>
 <li><a href="#L034">DIR$()</a> : current path</li>
 </ul>
<ul> <li><a href="#L035">EMPTY()</a> : is the user stack empty ?</li>
 </ul>
<ul> <li><a href="#L036">FILE$()</a> : current file name</li>
 <li><a href="#L037">FORWARD()</a> : does a numeric expression contain a forward reference ?</li>
 </ul>
<ul> <li><a href="#L038">INDEX()</a> : position of first string match, from left end</li>
 <li><a href="#L039">INDEXR()</a> : position of first string match, from right end</li>
 </ul>
<ul> <li><a href="#L03A">LABEL()</a> : is global name defined ?; <em>alias</em> ISLABEL()</li>
 <li><a href="#L03B">LEN()</a> : the number of characters in a string</li>
 </ul>
<ul> <li><a href="#L03C">MATCH$()</a> : extract a substring of a string by pattern match</li>
 <li><a href="#L03D">MESG$()</a> : full text at a message table index</li>
 <li><a href="#L03E">MID$()</a> : extract a substring of a string by string match</li>
 </ul>
<ul> <li><a href="#L03F">ORD()</a> : numeric value of Unicode character</li>
 </ul>
<ul> <li><a href="#L040">PEEK$()</a> : look at but do not remove a string on the user stack</li>
 <li><a href="#L041">POP$()</a> : remove the topmost string on the user stack</li>
 </ul>
<ul> <li><a href="#L042">RND()</a> : the next pseudo-random number</li>
 <li><a href="#L043">ROOTFILE$()</a> : name of root file</li>
 </ul>
<ul> <li><a href="#L044">SEED()</a> : initialize the pseudo-random number generator</li>
 <li><a href="#L045">SEGBEG()</a> : absolute start address of a segment</li>
 <li><a href="#L046">SEGEND()</a> : absolute end address plus one of a segment</li>
 <li><a href="#L047">SEGLEN()</a> : length of a segment</li>
 <li><a href="#L048">SEGOFF()</a> : segment offset in binary object file</li>
 <li><a href="#L049">SGN()</a> : sign of number</li>
 <li><a href="#L04A">STR$()</a> : convert a numeric expression to a decimal string</li>
 </ul>
<ul> <li><a href="#L04B">TIME$()</a> : the current date and time</li>
 <li><a href="#L04C">TOLOWER$()</a> : convert uppercase characters to lowercase</li>
 <li><a href="#L04D">TOUPPER$()</a> : convert lowercase characters to uppercase</li>
 </ul>
<ul> <li><a href="#L04E">VAL()</a> : convert a string expression to a numeric integer</li>
 <li><a href="#L04F">VER()</a> : HXA version number</li>
 <li><a href="#L050">VER$()</a> : HXA version string</li>
 </ul>
<ul> <li><a href="#L051">XLATE()</a> : mapped Unicode value</li>
 </ul>
<hr>
<a id="L030"></a>
<h4><b>ABS()</b></h4>
<h4>Usage</h4>
<blockquote> <b>ABS</b> ( number )<br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>number</em> is a <a href="#L009">numeric_expr</a></li>
 </ul>
<h4>Description</h4>
<p><b>ABS()</b>  returns the absolute value of <em>number</em>.</p>
<h4>Example</h4>
<ul> <li><a href="hxa_test.htm#L16C">ABS()</a></li>
 </ul>
<hr>
<a id="L031"></a>
<h4><b>CHR$()</b></h4>
<h4>Usage</h4>
<blockquote> <b>CHR$</b> ( value )<br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>value</em> is a <a href="#L009">numeric_expr</a> in the Unicode range [0x000000, 0x10FFFF]</li>
 </ul>
<h4>Description</h4>
<p><b>CHR$()</b>  returns a string of length one whose single character has Unicode <em>value</em>. Note that although the character length is always one, the octet length may be up to four.</p>
<p>If <em>value</em> is outside the Unicode range, the character returned is a question mark ('?', ASCII 0x3F).</p>
<p><b>CHR$()</b>  is not affected by <a href="#L077">character set translation</a>.</p>
<p><b>CHR$()</b>  is the inverse of <a href="#L03F">ORD()</a>.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L163">CHR$() and ORD()</a></li>
 </ul>
<hr>
<a id="L032"></a>
<h4><b>CPU$()</b></h4>
<h4>Usage</h4>
<blockquote> <b>CPU$()</b><br> </blockquote>
<h4>Description</h4>
<p><b>CPU$()</b>  takes no arguments and returns the name of the current <a href="#L06A">CPU</a>.</p>
<p>If no processor has been specified yet, <b>CPU$()</b>  returns the null string.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L166">CPU$()</a></li>
 </ul>
<hr>
<a id="L033"></a>
<h4><b>DEFINED()</b></h4>
<h4>Usage</h4>
<blockquote> <b>DEFINED</b> ( name )<br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>name</em> is a <a href="#L080">macro</a> name, or a <a href="#L009">string_expr$</a> that evaluates to a macro name</li>
 </ul>
<h4>Description</h4>
<p><b>DEFINED()</b>  returns logical <em>TRUE</em> if <em>name</em> is a currently defined <a href="#L080">macro</a> name, else logical <em>FALSE</em></p>
<p>A non-fatal error occurs if <em>name</em> does not evaluate to the form of a macro name. The expression containing <b>DEFINED()</b>  is treated as incompletely evaluated.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0E8">DEFINED() and UNDEF</a></li>
 <li><a href="hxa_test.htm#L16B">ISMACRO()</a></li>
 </ul>
<hr>
<a id="L034"></a>
<h4><b>DIR$()</b></h4>
<h4>Usage</h4>
<blockquote> <b>DIR$()</b><br> </blockquote>
<h4>Description</h4>
<p><b>DIR$()</b>  takes no arguments and returns the base path of the file currently being read. The path ends in a directory. It does not have a trailing path separator.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L108">Read Exclusion</a></li>
 </ul>
<hr>
<a id="L035"></a>
<h4><b>EMPTY()</b></h4>
<h4>Usage</h4>
<blockquote> <b>EMPTY()</b><br> </blockquote>
<h4>Description</h4>
<p><b>EMPTY()</b>  takes no arguments and returns <em>TRUE</em> if the user stack is empty, otherwise <em>FALSE</em>.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L189">User Stack</a></li>
 </ul>
<hr>
<a id="L036"></a>
<h4><b>FILE$()</b></h4>
<h4>Usage</h4>
<blockquote> <b>FILE$()</b><br> </blockquote>
<h4>Description</h4>
<p><b>FILE$()</b>  take no arguments and returns the base name of the file currently being read. The name may have an extension. It does not have a leading path separator.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L108">Read Exclusion</a></li>
 </ul>
<hr>
<a id="L037"></a>
<h4><b>FORWARD()</b></h4>
<h4>Usage</h4>
<blockquote> <b>FORWARD</b> ( expression$ )<br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>expression$</em> is a <a href="#L009">const_expr$</a></li>
 </ul>
<p><b>FORWARD()</b>  returns logical <em>TRUE</em> if <em>expression$</em>, parsed and evaluated as a numeric expression, contains at least one <a href="#L02A">forward reference</a>. Otherwise it returns logical <em>FALSE</em>.</p>
<p>A non-fatal error occurs if <em>expression$</em> does not represent a legal numeric expression. The expression containing <b>FORWARD()</b>  is treated as incompletely evaluated.</p>
<p>Because a label by itself is a legal expression, <b>FORWARD()</b>  can be used to determine if that label is in the symbol table. <b>FORWARD()</b>  returns <em>FALSE</em> if it is, <em>TRUE</em> if it is not.</p>
<p>Used in the manner, <b>FORWARD()</b>  is similar to <a href="#L03A">LABEL()</a>, but returns the opposite sense.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L162">FORWARD()</a></li>
 </ul>
<hr>
<a id="L038"></a>
<h4><b>INDEX()</b></h4>
<h4>Usage</h4>
<blockquote> <b>INDEX</b> ( haystack$, needle$ <em>[, start]</em> )<br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>haystack$</em> is a <a href="#L009">string_expr$</a></li>
 <li><em>needle$</em> is a <a href="#L009">string_expr$</a></li>
 <li><em>start</em> is an optional one-based <a href="#L009">numeric_expr</a></li>
 </ul>
<h4>Description</h4>
<p><b>INDEX()</b>  returns the leftmost one-based starting index of <em>needle$</em> in <em>haystack$</em> .</p>
<p>The result is zero if:</p>
<ul> <li>either <em>haystack$</em> or <em>needle$</em> is the null string</li>
 <li><em>needle$</em> does not occur in <em>haystack$</em></li>
 <li><em>start</em> is zero or has an absolute value greater than the length of <em>haystack$</em></li>
 </ul>
<p>If <em>start</em> is not present, the search begins at index one (the first, or leftmost, character of <em>haystack$</em>). If it is, searching begins at that character position.</p>
<p>If <em>start</em> is positive, it is counted from the left end of <em>haystack$</em> toward its right. If <em>start</em> is negative, it is counted from the right end of <em>haystack$</em> toward its left.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L15C">INDEX()</a></li>
 </ul>
<hr>
<a id="L039"></a>
<h4><b>INDEXR()</b></h4>
<h4>Usage</h4>
<blockquote> <b>INDEXR</b> ( haystack$, needle$ <em>[, start]</em> )<br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>haystack$</em> is a <a href="#L009">string_expr$</a></li>
 <li><em>needle$</em> is a <a href="#L009">string_expr$</a></li>
 <li><em>start</em> is an optional one-based <a href="#L009">numeric_expr</a></li>
 </ul>
<h4>Description</h4>
<p><b>INDEXR()</b>  returns the rightmost one-based starting index of <em>needle$</em> in <em>haystack$</em> .</p>
<p>The result is zero if:</p>
<ul> <li>either <em>haystack$</em> or <em>needle$</em> is the null string</li>
 <li><em>needle$</em> does not occur in <em>haystack$</em></li>
 <li><em>start</em> is zero or has an absolute value greater than the length of <em>haystack$</em></li>
 </ul>
<p>If <em>start</em> is not present, the search begins at index LEN(<em>haystack$</em>) (the last, or rightmost, character of <em>haystack$</em>). If it is, searching begins at that character position.</p>
<p>If <em>start</em> is positive, it is counted from the left end of the <em>haystack$</em> toward its right. If <em>start</em> is negative, it is counted from the right end of the <em>haystack$</em> toward its left.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L160">INDEXR()</a></li>
 </ul>
<hr>
<a id="L03A"></a>
<h4><b>LABEL()</b></h4>
<h4>Usage</h4>
<blockquote> <b>LABEL</b> ( name )<br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>name</em> is a <a href="#L020">global</a> label name, or a <a href="#L009">string_expr$</a> which evaluates to a global label name</li>
 </ul>
<h4>Description</h4>
<p><b>LABEL()</b>  returns logical <em>TRUE</em> if <em>name</em> is a global name currently present in the symbol table, otherwise logical <em>FALSE</em>.</p>
<p>A non-fatal error occurs if <em>name</em> does not evaluate to the form of a global name. The expression containing <b>LABEL()</b>  is treated as incompletely evaluated.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L16A">LABEL()</a></li>
 </ul>
<hr>
<a id="L03B"></a>
<h4><b>LEN()</b></h4>
<h4>Usage</h4>
<blockquote> <b>LEN</b> ( string$ )<br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>string$</em> is a <a href="#L009">string_expr$</a></li>
 </ul>
<h4>Description</h4>
<p><b>LEN()</b>  returns the number of Unicode characters in <em>string$</em>.</p>
<h4>Example</h4>
<ul> <li><a href="hxa_test.htm#L15B">LEN()</a></li>
 </ul>
<hr>
<a id="L03C"></a>
<h4><b>MATCH$()</b></h4>
<h4>Usage</h4>
<blockquote> <b>MATCH$</b> ( haystack$, needle <em>[, start]</em> )<br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>haystack$</em> is a <a href="#L009">string_expr$</a></li>
 <li><em>needle</em> is a <a href="#L02E">regular expression</a></li>
 <li><em>start</em> is an optional one-based <a href="#L009">numeric_expr</a></li>
 </ul>
<h4>Description</h4>
<p><b>MATCH$()</b>  returns the leftmost substring of <em>haystack$</em> that matches the regular expression pattern <em>needle</em>.</p>
<p>The result is the null string if:</p>
<ul> <li><em>haystack$</em> is the null string</li>
 <li><em>needle</em> is not a regular expression or does not occur in <em>haystack$</em></li>
 <li><em>start</em> is zero or has an absolute value greater than the length of <em>string$</em></li>
 </ul>
<p>If <em>start</em> is not present, the search begins at index one (the first, or leftmost, character of <em>haystack$</em> ). If it is, searching begins at that character position.</p>
<p>If <em>start</em> is positive, it is counted from the left end of <em>haystack$</em> toward its right. If <em>start</em> is negative, it is counted from the right end of <em>haystack$</em> toward its left.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L164">MATCH$()</a></li>
 </ul>
<hr>
<a id="L03D"></a>
<h4><b>MESG$()</b></h4>
<h4>Usage</h4>
<blockquote> <b>MESG$</b> ( index$ )<br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>index$</em> is a <a href="#L009">string_expr$</a></li>
 </ul>
<h4>Description</h4>
<p><b>MESG$()</b>  returns the full text associated with the key <em>index$</em> from HXA's internal table of <a href="hxa_source.htm#L1B8">assembler messages</a>.</p>
<p>If <em>index$</em> does not match the key of any printable message, the text associated with the <em>BadMsg</em> key is returned.</p>
<hr>
<a id="L03E"></a>
<h4><b>MID$()</b></h4>
<h4>Usage</h4>
<blockquote> <b>MID$</b> ( string$, start <em>[, count]</em> )<br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>string$</em> is a <a href="#L009">string_expr$</a></li>
 <li><em>start</em> is a one-based <a href="#L009">numeric_expr</a></li>
 <li><em>count</em> is an optional <a href="#L009">numeric_expr</a></li>
 </ul>
<h4>Description</h4>
<p><b>MID$()</b>  returns a substring of <em>string$</em>.</p>
<p>The result is the null string if:</p>
<ul> <li><em>string$</em> is the null string</li>
 <li><em>start</em> is zero or has an absolute value greater than the length of <em>string$</em></li>
 <li><em>count</em> is less than one</li>
 </ul>
<p>Otherwise slicing begins at the <em>start</em> character position. If <em>start</em> is positive, it is counted from the left end of <em>string$</em> toward its right. If <em>start</em> is negative, it is counted from the right end of <em>string$</em> toward its left.</p>
<p>If <em>count</em> is not present, it is assumed to have a value greater than the number of characters in <em>string</em> .</p>
<p>The result is a string beginning at <em>start</em>  and consisting of either the next <em>count</em> characters of <em>string</em> or all is remaining characters, whichever is shorter.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L15D">MID$()</a></li>
 </ul>
<hr>
<a id="L03F"></a>
<h4><b>ORD()</b></h4>
<h4>Usage</h4>
<blockquote> <b>ORD</b> ( string$ <em>[, position]</em> )<br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>string$</em> is a <a href="#L009">string_expr$</a></li>
 <li><em>position</em> is an optional one-based <a href="#L009">numeric_expr</a></li>
 </ul>
<h4>Description</h4>
<p><b>ORD()</b>  returns the Unicode value of a character in <em>string$</em>.</p>
<p>The result is zero if:</p>
<ul> <li><em>string</em> is the null string</li>
 <li><em>position</em> is zero or its absolute value is greater than the length of <em>string$</em></li>
 </ul>
<p>If <em>position</em> is not present, the first (leftmost) character of <em>string$</em> is used. If it is, the character at that index in <em>string$</em> is used.</p>
<p>If <em>position</em> is positive, the index is counted from the left end of <em>string$</em> toward its right. If <em>position</em> is negative, the index is counted from the right end of <em>string$</em> toward its left.</p>
<p><b>ORD()</b>  is not affected by <a href="#L077">character set translation</a>.</p>
<p><b>ORD()</b>  is the inverse of <a href="#L031">CHR$()</a>.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L163">CHR$() and ORD()</a></li>
 </ul>
<hr>
<a id="L040"></a>
<h4><b>PEEK$()</b></h4>
<h4>Usage</h4>
<blockquote> <b>PEEK$</b> ( <em>[position]</em> )<br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>position</em> is an optional one-based <a href="#L009">const_expr</a></li>
 </ul>
<h4>Description</h4>
<p><b>PEEK$()</b>  returns a copy of a string from the user stack without removing it.</p>
<p>The result is the null string if:</p>
<ul> <li>the user stack is empty</li>
 <li><em>position</em> is outside the size of the user stack</li>
 </ul>
<p>The topmost string on the user stack has a <em>position</em> of one, the string "under" the topmost has an index of two, and so one. The bottom most string (ie., the first string pushed on) has a <em>position</em> equal to the number of strings on the stack.</p>
<p>If <em>position</em> is not present, <b>PEEK$()</b>  returns the topmost string on the stack (ie., the string most recently pushed on). If it is, a copy of the string at that location is returned. If <em>position</em> is less than one or greater than the length of the stack, an error will happen and the null string returned.</p>
<h4>Example</h4>
<ul> <li><a href="hxa_test.htm#L189">User Stack</a></li>
 </ul>
<hr>
<a id="L041"></a>
<h4><b>POP$()</b></h4>
<h4>Usage</h4>
<blockquote> <b>POP$()</b><br> </blockquote>
<h4>Description</h4>
<p><b>POP$()</b>  takes no arguments and returns the topmost string on the user stack (ie., the one most recently pushed on). That string is removed from the user stack, leaving it one entry shorter.</p>
<p>The result is the null string if:</p>
<ul> <li>the user stack is empty</li>
 </ul>
<h4>Example</h4>
<ul> <li><a href="hxa_test.htm#L189">User Stack</a></li>
 </ul>
<hr>
<a id="L042"></a>
<h4><b>RND()</b></h4>
<h4>Usage</h4>
<blockquote> <b>RND</b> ( limit1 <em>[, limit2]</em> )<br> </blockquote>
<h4>Parameters</h4>
<ul> <li>both <em>limit1</em> and the optional <em>limit2</em> are integers of any value</li>
 </ul>
<h4>Description</h4>
<p><b>RND()</b>  takes one or two arguments and returns a pseudo-random integer in the range [<em>limit1</em>, <em>limit2</em>].</p>
<p>If <em>limit2</em> is not present, its value defaults to zero. The returned value will be between zero and <em>limit1</em>.</p>
<h4>Example</h4>
<ul> <li><a href="hxa_test.htm#L16F">SEED() and RND()</a></li>
 </ul>
<hr>
<a id="L043"></a>
<h4><b>ROOTFILE$()</b></h4>
<h4>Usage</h4>
<blockquote> <b>ROOTFILE$()</b><br> </blockquote>
<h4>Description</h4>
<p><b>ROOTFILE$()</b>  takes no arguments and returns the base name of the <a href="#L007">root file</a>. That is, the name of the source file named on the command line when HXA was first invoked.</p>
<h4>Example</h4>
<ul> <li><a href="hxa_test.htm#L16D">ROOTFILE$()</a></li>
 </ul>
<hr>
<a id="L044"></a>
<h4><b>SEED()</b></h4>
<h4>Usage</h4>
<blockquote> <b>SEED</b> ( <em>[value]</em> )<br> </blockquote>
<h4>Parameters</h4>
<ul> <li>the optional <em>value</em> is an integer of any value</li>
 </ul>
<h4>Description</h4>
<p><b>SEED()</b>  initializes the pseudo-random number generator and returns the seed value it used.</p>
<p>If <em>value</em> is not present, an integer in the range [0, 2147483648] will be generated by internal means (often based on the system clock). That integer will be used as the seed value.</p>
<p>Each time the same seed value is used, the same sequence of pseudo-random numbers will be generated by <a href="#L042">RND()</a>. This provides a means of repeating any sequence, any number of times.</p>
<h4>Example</h4>
<ul> <li><a href="hxa_test.htm#L16F">SEED() and RND()</a></li>
 </ul>
<hr>
<a id="L045"></a>
<h4><b>SEGBEG()</b></h4>
<h4>Usage</h4>
<blockquote> <b>SEGBEG</b> ( name )<br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>name</em> is a <a href="#L01F">numeric global</a> name, or a <a href="#L009">string_expr$</a> that evaluates to a numeric global name</li>
 </ul>
<h4>Description</h4>
<p><b>SEGBEG()</b>  returns the absolute start address of segment <em>name</em>. That is, the address of the first byte used by segment <em>name</em>.</p>
<p><em>Name</em> may be a forward reference to a segment which has not yet been encountered.</p>
<p>A non-fatal error occurs if <em>name</em> is a string expression which does not evaluate to the form of a segment name. The expression containing <em>name</em> is treated as incompletely evaluated.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L165">SEGBEG(), SEGEND(), SEGLEN() and SEGOFF()</a></li>
 </ul>
<hr>
<a id="L046"></a>
<h4><b>SEGEND()</b></h4>
<h4>Usage</h4>
<blockquote> <b>SEGEND</b> ( name )<br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>name</em> is a <a href="#L01F">numeric global</a> name, or a <a href="#L009">string_expr$</a> that evaluates to a numeric global name</li>
 </ul>
<h4>Description</h4>
<p><b>SEGEND()</b>  returns the absolute end address + 1 of segment <em>name</em>. That is, the address just after the last byte used by segment <em>name</em>.</p>
<p><em>Name</em> may be a forward reference to a segment which has not yet been encountered.</p>
<p>A non-fatal error occurs if <em>name</em> is a string expression which does not evaluate to the form of a segment name. The expression containing <em>name</em> is treated as incompletely evaluated.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L165">SEGBEG(), SEGEND(), SEGLEN() and SEGOFF()</a></li>
 </ul>
<hr>
<a id="L047"></a>
<h4><b>SEGLEN()</b></h4>
<h4>Usage</h4>
<blockquote> <b>SEGLEN</b> ( name )<br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>name</em> is a <a href="#L01F">numeric global</a> name, or a <a href="#L009">string_expr$</a> that evaluates to a numeric global name</li>
 </ul>
<h4>Description</h4>
<p><b>SEGLEN()</b>  returns the length of segment <em>name</em>. That is, the value <b>SEGEND</b> (<em>name</em>) - <b>SEGBEG</b> (<em>name</em>).</p>
<p><em>Name</em> may be a forward reference to a segment which has not yet been encountered.</p>
<p>A non-fatal error occurs if <em>name</em> is a string expression which does not evaluate to the form of a segment name. The expression containing <em>name</em> is treated as incompletely evaluated.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L165">SEGBEG(), SEGEND(), SEGLEN() and SEGOFF()</a></li>
 </ul>
<hr>
<a id="L048"></a>
<h4><b>SEGOFF()</b></h4>
<h4>Usage</h4>
<ul> <li><b>SEGOFF</b> ( name )</li>
 </ul>
<h4>Parameters</h4>
<ul> <li><em>name</em> is a <a href="#L01F">numeric global</a> name, or a <a href="#L009">string_expr$</a> that evaluates to a numeric global name</li>
 </ul>
<h4>Description</h4>
<p><b>SEGOFF()</b>  returns the zero-based byte offset of segment <em>name</em> from the start of the binary output file that segment is part of (the file does not actually have to be output). That is, the sum of the lengths of all data-containing segments before segment <em>name</em> in the output sequence.</p>
<p>It is an error to use <b>SEGOFF()</b>  on uninitialized segments. They do not appear in output files and thus have no meaningful offset value.</p>
<p><em>Name</em> may be a forward reference to a segment which has not yet been encountered.</p>
<p>A non-fatal error occurs if <em>name</em> is a string expression which does not evaluate to the form of a segment name. The expression containing <em>name</em> is treated as incompletely evaluated.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L165">SEGBEG(), SEGEND(), SEGLEN() and SEGOFF()</a></li>
 </ul>
<hr>
<a id="L049"></a>
<h4><b>SGN()</b></h4>
<h4>Usage</h4>
<blockquote> <b>SGN</b> ( number )<br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>number</em> is a <a href="#L009">numeric_expr</a></li>
 </ul>
<h4>Description</h4>
<p><b>SGN()</b>  returns one (1) if <em>number</em> is greater than zero, minus one (-1) if it is less than zero, or zero (0).</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L16E">SGN()</a></li>
 </ul>
<hr>
<a id="L04A"></a>
<h4><b>STR$()</b></h4>
<h4>Usage</h4>
<blockquote> <b>STR$</b> ( number )<br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>number</em> is a <a href="#L009">numeric_expr</a></li>
 </ul>
<h4>Description</h4>
<p><b>STR$()</b>  returns an ASCII decimal string representing the result of evaluating <em>number</em>.</p>
<p>If the result will fit in a size known beforehand, <em>number</em> may contain a <a href="#L02A">forward reference</a>.</p>
<h4>Example</h4>
<ul> <li><a href="hxa_test.htm#L15F">STR$()</a></li>
 </ul>
<hr>
<a id="L04B"></a>
<h4><b>TIME$()</b></h4>
<h4>Usage</h4>
<blockquote> <b>TIME$()</b><br> </blockquote>
<h4>Description</h4>
<p><b>TIME$()</b>  takes no arguments and returns a string describing the current date and time in the form:</p>
<blockquote> "WeekDay&nbsp;&nbsp;Month&nbsp;&nbsp;MonthDay&nbsp;&nbsp;Hour:Min:Sec&nbsp;&nbsp;Year"<br> </blockquote>
<h4>Examples</h4>
<ul> <li>"Sat Feb 5 18:30:45 2011"</li>
 <li><a href="hxa_test.htm#L167">TIME$()</a></li>
 </ul>
<hr>
<a id="L04C"></a>
<h4><b>TOLOWER$()</b></h4>
<h4>Usage</h4>
<blockquote> <b>TOLOWER</b> ( string$ )<br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>string$</em> is a <a href="#L009">const_expr$</a></li>
 </ul>
<h4>Description</h4>
<p><b>TOLOWER()</b>  returns <em>string$</em>, except any uppercase characters are converted to lowercase</p>
<h4>Example</h4>
<ul> <li><a href="hxa_test.htm#L161">TOLOWER$() and TOUPPER$()</a></li>
 </ul>
<hr>
<a id="L04D"></a>
<h4><b>TOUPPER$()</b></h4>
<h4>Usage</h4>
<blockquote> <b>TOUPPER</b> ( string$ )<br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>string$</em> is a <a href="#L009">const_expr$</a></li>
 </ul>
<h4>Description</h4>
<p><b>TOUPPER()</b>  returns <em>string$</em>, except any uppercase characters are converted to lowercase</p>
<h4>Example</h4>
<ul> <li><a href="hxa_test.htm#L161">TOLOWER$() and TOUPPER$()</a></li>
 </ul>
<hr>
<a id="L04E"></a>
<h4><b>VAL()</b></h4>
<h4>Usage</h4>
<blockquote> <b>VAL</b> ( expression$ )<br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>expression$</em> is a <a href="#L009">string_expr$</a> which represents a numeric expression</li>
 </ul>
<h4>Description</h4>
<p><b>VAL()</b>  returns the result of evaluating <em>expression$</em> as a numeric expression.</p>
<p>A non-fatal error occurs if <em>expression$</em> does not represent a legal numeric expression. The expression containing <b>VAL()</b>  is treated as incompletely evaluated.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L15E">VAL()</a></li>
 </ul>
<hr>
<a id="L04F"></a>
<h4><b>VER()</b></h4>
<h4>Usage</h4>
<blockquote> <b>VER()</b><br> </blockquote>
<h4>Description</h4>
<p><b>VER()</b>  take no arguments and returns the <a href="#L021">pre-defined</a> numeric value of the <b>__VER__</b>  symbol</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L15A">VER() and VER$()</a></li>
 </ul>
<hr>
<a id="L050"></a>
<h4><b>VER$()</b></h4>
<h4>Usage</h4>
<blockquote> <b>VER$()</b><br> </blockquote>
<h4>Description</h4>
<p><b>VER()</b>  take no arguments and returns the <a href="#L021">pre-defined</a> string value of the <b>__VER__$</b>  symbol</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L15A">VER() and VER$()</a></li>
 </ul>
<hr>
<a id="L051"></a>
<h4><b>XLATE()</b></h4>
<h4>Usage</h4>
<blockquote> <b>XLATE</b> ( <em>char_code</em> )<br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>char_code</em> is an  <a href="#L009">numeric_expr</a> in the legal range of a Unicode character, [0x000000, 0x10FFFF]</li>
 </ul>
<h4>Description</h4>
<p>Returns the numeric value currently mapped to the Unicode character at index <em>char_code</em>. This is typically expressed as a printable Unicode character, but any legal numeric expression is acceptable.</p>
<p>Unicode character codes can be mapped to arbitrary Unicode values using the <a href="#L077">XLATE</a> pseudo opcode. In essence they are <em>aliased</em> to alternative values. <b>XLATE()</b>  recovers the alias value of a <a href="#L077">character set translation</a>.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0D0">XLATE() and XLATE</a></li>
 </ul>
<hr>
<a id="L052"></a><h4>Operators</h4>
<p>HXA provides operators which work with numeric, string and regular expression operands. Results can be numeric or string, as logical operator results are always either zero (<em>FALSE</em>) or one (<em>TRUE</em>).</p>
<p>Expression evaluation is by standard algebraic rules.</p>
<ul> <li>each operator has an associated precedence which determines the order in which operators are applied to operands</li>
 <li>higher precedence operators execute before those of lower precedence</li>
 <li>consecutive unary operators of equal precedence evaluate right-to-left</li>
 <li>consecutive binary operators of equal precedence evaluate left-to-right</li>
 <li>operators inside pairs of parentheses evaluate before those outside</li>
 <li>sets of parentheses nest</li>
 </ul>
<p>Although some assembly languages use pairs of parentheses to indicate address indirection, this does not usually cause HXA any difficulty. When used as address indirection indicators, parentheses normally surround the entire expression of interest. The value of an entire expression surrounded by parentheses is no different than the value of the same expression <em>not</em> surrounded by parentheses, so no special treatment is required.</p>
<h4>Operator Precedence</h4>
<p>Relative precedence is the same as the <b>C/C++</b>  family of languages wherever operators are the same.</p>
<table> <caption>Relative Operator Precedence</caption> <thead> <tr><th>Precedence</th><th>Operator</th><th>Name</th><th>Type</th><th>Notation</th><th>Result</th></tr> </thead><tbody> <tr><td colspan="6">&nbsp;</td></tr> <tr><td>14</td><td>(&nbsp;)</td><td>function call</td><td>binary</td><td><em>name</em>(&nbsp;<em>[exp[[, exp]..]]</em>&nbsp;)</td><td>string or numeric</td></tr> <tr><td colspan="6">&nbsp;</td></tr> <tr><td>13</td><td>-</td><td>negation</td><td>unary</td><td>-<em>num</em></td><td>numeric</td></tr> <tr><td>&nbsp;</td><td>+</td><td>absolute value</td><td>unary</td><td>+<em>num</em></td><td>numeric</td></tr> <tr><td>&nbsp;</td><td>!</td><td>logical NOT</td><td>unary</td><td>!<em>opr</em></td><td>logical</td></tr> <tr><td>&nbsp;</td><td>~</td><td>bitwise NOT</td><td>unary</td><td>~<em>num</em></td><td>numeric</td></tr> <tr><td>&nbsp;</td><td>&lt;</td><td>least significant byte</td><td>unary</td><td>&lt;<em>num</em></td><td>numeric</td></tr> <tr><td>&nbsp;</td><td>&gt;</td><td>most significant byte</td><td>unary</td><td>&gt;<em>num</em></td><td>numeric</td></tr> <tr><td>&nbsp;</td><td>^</td><td>most significant word</td><td>unary</td><td>^<em>num</em></td><td>numeric</td></tr> <tr><td colspan="6">&nbsp;</td></tr> <tr><td>12</td><td>&ast;</td><td>multiply</td><td>binary</td><td><em>opr</em> &ast; <em>num</em></td><td>string or numeric</td></tr> <tr><td>&nbsp;</td><td>/</td><td>divide</td><td>binary</td><td><em>num</em> / <em>num</em></td><td>numeric</td></tr> <tr><td>&nbsp;</td><td>%</td><td>modulus</td><td>binary</td><td><em>num</em> % <em>num</em></td><td>numeric</td></tr> <tr><td colspan="6">&nbsp;</td></tr> <tr><td>11</td><td>+</td><td>add</td><td>binary</td><td><em>opr</em> + <em>opr</em></td><td>string or numeric</td></tr> <tr><td>&nbsp;</td><td>-</td><td>subtract</td><td>binary</td><td><em>num</em> - <em>num</em></td><td>numeric</td></tr> <tr><td colspan="6">&nbsp;</td></tr> <tr><td>10</td><td>&lt;&lt;</td><td>left shift</td><td>binary</td><td><em>num</em> &lt;&lt; <em>num</em></td><td>numeric</td></tr> <tr><td>&nbsp;</td><td>&gt;&gt;</td><td>right shift</td><td>binary</td><td><em>num</em> &gt;&gt; <em>num</em></td><td>numeric</td></tr> <tr><td colspan="6">&nbsp;</td></tr> <tr><td>9</td><td>&lt;</td><td>less than</td><td>binary</td><td><em>opr</em> &lt; <em>opr</em></td><td>logical</td></tr> <tr><td>&nbsp;</td><td>&gt;</td><td>greater than</td><td>binary</td><td><em>opr</em> &gt; <em>opr</em></td><td>logical</td></tr> <tr><td>&nbsp;</td><td>&lt;=</td><td>less or equal</td><td>binary</td><td><em>opr</em> &lt;= <em>opr</em></td><td>logical</td></tr> <tr><td>&nbsp;</td><td>&gt;</td><td>greater or equal</td><td>binary</td><td><em>opr</em> &gt;= <em>opr</em></td><td>logical</td></tr> <tr><td colspan="6">&nbsp;</td></tr> <tr><td>8</td><td>==</td><td>equal</td><td>binary</td><td><em>opr</em> == <em>opr</em></td><td>logical</td></tr> <tr><td>&nbsp;<td>!=</td><td>NOT equal</td><td>binary</td><td><em>opr</em> != <em>opr</em></td><td>logical</td></tr> <tr><td colspan="6">&nbsp;</td></tr> <tr><td>7</td><td>~</td><td>pattern match</td><td>binary</td><td><em>str</em> ~ <em>rgx</em></td><td>logical</td></tr> <tr><td>&nbsp;</td><td>!~</td><td>pattern NOT match</td><td>binary</td><td><em>str</em> !~ <em>rgx</em></td><td>logical</td></tr> <tr><td colspan="6">&nbsp;</td></tr> <tr><td>6</td><td>&amp;</td><td>bitwise AND</td><td>binary</td><td><em>num</em> &amp; <em>num</em></td><td>numeric</td></tr> <tr><td colspan="6">&nbsp;</td></tr> <tr><td>5</td><td>^</td><td>bitwise exclusive OR</td><td>binary</td><td><em>num</em> ^ <em>num</em></td><td>numeric</td></tr> <tr><td colspan="6">&nbsp;</td></tr> <tr><td>4</td><td>|</td><td>bitwise inclusive OR</td><td>binary</td><td><em>num</em> | <em>num</em></td><td>numeric</td></tr> <tr><td colspan="6">&nbsp;</td></tr> <tr><td>3</td><td>&amp;&amp;</td><td>logical AND</td><td>binary</td><td><em>opr</em> &amp;&amp; <em>opr</em></td><td>logical</td></tr> <tr><td colspan="6">&nbsp;</td></tr> <tr><td>2</td><td>||</td><td>logical OR</td><td>binary</td><td><em>opr</em> || <em>opr</em></td><td>logical</td></tr> <tr><td colspan="6">&nbsp;</td></tr> <tr><td>1</td><td>? :</td><td>conditional</td><td>ternary</td><td><em>exp</em> ? <em>exp</em> : <em>exp</em></td><td>string or numeric</td></tr> </tbody> </table>
<ul> <li><em>num</em> is a numeric operand</li>
 <li><em>str</em> is a string operand</li>
 <li><em>opr</em> can be a <em>num</em> or a <em>str</em></li>
 <li><em>rgx</em> is a regular expression literal</li>
 <li><em>exp</em> is an expression</li>
 </ul>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0E1">Expression Evaluation</a></li>
 </ul>
<hr>
<h4>Unary Operators</h4>
<p>Consecutive unary operators of equal precedence are evaluated right-to-left, rather than left-to-right.</p>
<p>The unary plus operator yields the absolute value of its operand.</p>
<p>The "bit extract" operators ('&lt;', '&gt;' and '^') are essentially shorthand for a right shift (to move the bits of interest to the least significant bit positions) followed by a bitwise AND (to set the bits not of interest to zero). The resultant value is a full 32 bits long (and usually a positive integer).</p>
<p>The "bit extract" operators are affected by <a href="#L0AE">non-standard byte sizes</a>. The '&lt;' operator always refers to the least significant byte, '&gt;' to the next significant byte, and '^' to the most significant word. These concepts change when the size of a <em>byte</em> changes.</p>
<p>If unary operators are applied to string operands, the strings are implicitly compared to the null string before the operator is applied. The final result is numeric.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0DA">Unary Operators</a></li>
 </ul>
<hr>
<h4>Multiplication</h4>
<p>Strings as well as numbers can be multiplied. String multiplication is essentially <em>duplication</em>. String multiplication is <em>not</em> commutative; the string operand must be on the left and the numeric operand on the right.</p>
<p>If the numeric value is one or greater, the result will be string of that number of copies of the original string. For values less than one, the result is a null string. Attempts to store null strings in object code will result in warnings.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0DB">Numeric Binary Operators</a></li>
 <li><a href="hxa_test.htm#L0DC">String Binary Operators</a></li>
 </ul>
<hr>
<h4>Division and Modulus</h4>
<p>HXA performs floored integer division. The quotient of the dividend and divisor is rounded down to the nearest integer.</p>
<p>When the modulus operator is used, the remainder will have the same sign as the divisor.</p>
<p>A value of zero for the divisor will cause an error. Assembly will ultimately fail but the current pass will continue.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0DB">Numeric Binary Operators</a></li>
 </ul>
<hr>
<h4>Addition</h4>
<p>Strings as well as numbers can be added. String addition is essentially <em>concatenation</em>. The result will be a string where the string on the righthand side of the operator has been joined to the end of the one on the left.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0DB">Numeric Binary Operators</a></li>
 <li><a href="hxa_test.htm#L0DC">String Binary Operators</a></li>
 </ul>
<hr>
<h4>Left and Right Shift</h4>
<p>The numeric expression must have a value in the range [0, 32].</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0DB">Numeric Binary Operators</a></li>
 </ul>
<hr>
<h4>Pattern Match</h4>
<p>The pattern match operators are <em>not</em> commutative. The string operand must appear to the left of the operator and the regular expression pattern to the right.</p>
<p>Strings may be assigned to a string <a href="#L01D">label</a> by the <a href="#L078">EQU</a> pseudo opcode. A string containing a properly formed regular expression can be used on the right side of a pattern match.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0DD">Regular Expression Operators</a></li>
 </ul>
<hr>
<h4>Logical AND and OR</h4>
<p>Since the result of these operator is always logical, types can be mixed on either side of the operator. That is, the expression on either side can be either numeric or string. They do not have to match. A numeric expression is <em>TRUE</em> if not zero. A string expression is <em>TRUE</em> if non-null.</p>
<p>These operators <em>short-circuit</em>, whenever possible skipping over the expression on the right side of the operator. That is, they do not evaluate the right side if the final result can be determined solely from the expression on the left.</p>
<p>In the case of '&amp;&amp;', if the left hand side is <em>FALSE</em>, nothing on the right side can ever change the result to <em>TRUE</em>. Similarly for '||', if the left hand side is <em>TRUE</em>, nothing on the right side can ever change the result to <em>FALSE</em>.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0DB">Numeric Binary Operators</a></li>
 <li><a href="hxa_test.htm#L0DF">Logical Short Circuit</a></li>
 </ul>
<hr>
<h4>Ternary Conditional</h4>
<p>The ternary conditional has three parts in the order: the <em>conditional</em> expression, the <em>TRUE</em> expression and the <em>FALSE</em> expression. Although it is one operator, it is written as two characters, a question mark ('?', ASCII 0x3F) and colon (':', ASCII 0x3A):</p>
<blockquote> <em>conditional</em> ? <b>TRUE : FALSE</b><br> </blockquote>
<p>Each expression may be numeric, string or a pattern match. The only restriction here is that the <em>TRUE</em> and <em>FALSE</em> expressions must have the same type.</p>
<p>Ternary conditionals can appear consecutively in an overall expression:</p>
<blockquote> <em>conditional0 ? TRUE0 : FALSE0 ? TRUE1 : FALSE1</em><br> </blockquote>
<p>This is interpreted by HXA as:</p>
<blockquote> <em>conditional0 ? TRUE0 : ( conditional1 ? TRUE1 : FALSE1 )</em><br> </blockquote>
<p>In other words, <em>FALSE0</em> serves as <em>conditional1</em> for <em>TRUE1</em> and <em>FALSE1</em>.</p>
<p>Parentheses can help make it clear what the association is, but are not strictly necessary here.</p>
<p>Ternary conditionals can also appear nested in an overall expression:</p>
<blockquote> <em>conditional0 ? conditional1 ? TRUE1 : FALSE1 : FALSE0</em><br> </blockquote>
<p>This makes no sense to HXA unless explicitly parenthesized:</p>
<blockquote> <em>conditional0 ? ( conditional1 ? TRUE1 : FALSE1 ) : FALSE0</em><br> </blockquote>
<p>Consecutive and nested ternary conditionals can be difficult to follow if several conditionals appear in the same expression. It is therefore recommended not to do such things in the first place.</p>
<p>If it does ever becomes necessary to parenthesize multiple ternary conditionals, there are some rules of thumb. Remember that ternary conditionals bind as tightly as they can, right to left.</p>
<p>First find the rightmost '?'  and ':' characters and then the <em>conditional</em>, <em>TRUE</em> and <em>FALSE</em> expressions they mark. Surround these three expressions with parentheses. This is the first ternary.</p>
<p>Then find the next '?' character to the left.</p>
<p>If the first ternary is consecutive to this one, then a ':' will immediately preceed it, between the second '?' character and the first ternary. The first ternary is essentially the <em>FALSE</em> branch of the second ternary. Put an open parenthesis at the start of the <em>conditional</em> expression left of the new '?' character. Put a close parenthesis just after the first ternary.</p>
<p>If the first ternary conditional is instead nested by the second, then as a whole it will be the <em>TRUE</em> branch of the second. The ':' character associated with the second '?' will appear just after the first ternary. Put an open parenthesis at the start of the <em>conditional</em> expression associated with the new '?' character. Put a close parenthesis just after the <em>FALSE</em> expression associated with the second ':' character.</p>
<p>Continue in this way until there are no more '?' characters to be found. Then the entire expression is parenthesized.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0E0">Ternary Conditional</a></li>
 </ul>
<hr>
<h4>Undetected Errors</h4>
<p>In some cases an expression may contain an error which might not be detected by HXA. Undetected errors may be of two general kinds, <em>parse</em> and <em>unevaluable</em>.</p>
<p>A parse error occurs when an expression is malformed. In some cases HXA may not detect this because no parse is attempted. For example, in <em>FALSE</em> <a href="#L08D">IF</a> conditional branches, HXA does not attempt to parse any expression following a nested <b>IF</b>  or <a href="#L08F">ELSEIF</a> pseudo opcode. No result of any evaluation of these can change the larger <em>FALSE</em> branch to <em>TRUE</em>.</p>
<p>An unevaluable error occurs when an expression parses properly but can never be fully evaluated. Perhaps it contains an unresolvable <a href="#L02A">forward reference</a>, or maybe a division by zero. In some cases HXA may not detect this because evaluation is never attempted. The logical operators AND and OR, as well as the ternary conditional operator, can cause part of the expression they appear in to be skipped over during evaluation. HXA does not determine whether or not skipped-over parts can be evaluated.</p>
<hr>
<a id="L053"></a><h4>Comment Field</h4>
<p>Comments are source text that is not meant to be assembled. Instead their purpose is only to explain or describe source text that <em>is</em> meant to be assembled.</p>
<p>Comments are ignored during assembly and have no effect on the object code produced. However, they will appear in the default settings of <a href="#L056">listing</a> files.</p>
<p>The whole source line is a comment if the first non-whitespace character is either a semi-colon (';', ASCII 0x3B) or the character pair double forward slash ('//', ASCII 0x2F2F).</p>
<p>The whole source line is also a comment if the first non-whitespace character is either a sharp ('#', ASCII 0x23) or an asterisk ('&ast;', ASCII 0x2A), followed by whitespace.</p>
<p>If any source line field is followed by whitespace and then any of the characters ';', '#' or '//', those characters mark the start of a comment.</p>
<p>The first appearance of any of these markers is the start of a comment. Everything from the start of a comment to the end of the source line is ignored.</p>
<p>Note that an <a href="#L00C">escaped</a> comment marker in a <a href="#L02C">character</a>, <a href="#L073">string</a> and <a href="#L02E">regular expression</a> literal will <em>not</em> start a comment.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0B3">Comments</a></li>
 </ul>
<a id="L054"></a><h3>Output Files</h3>
<h4>Usage</h4>
<h4>--FILE</h4>
<blockquote> <b>ERRFILE</b>  <em>[[path][filename[.ext]]]</em><br> <b>LISTFILE</b>  <em>[[path][filename[.ext]]]</em><br> </blockquote>
<blockquote> <b>OBJFILE</b>  <em>[[path][filename[.ext]]]</em><br> <b>RAWFILE</b>  <em>[[path][filename[.ext]]]</em><br> <b>HEXFILE</b>  <em>[[path][filename[.ext]]]</em><br> <b>SRECFILE</b>  <em>[[path][filename[.ext]]]</em><br> </blockquote>
<h4>--BYSEG</h4>
<blockquote> <b>OBJBYSEG</b>  <em>[[path][filename[.ext]]]</em><br> <b>RAWBYSEG</b>  <em>[[path][filename[.ext]]]</em><br> <b>HEXBYSEG</b>  <em>[[path][filename[.ext]]]</em><br> <b>SRECBYSEG</b>  <em>[[path][filename[.ext]]]</em><br> </blockquote>
<h4>---BYBLK</h4>
<blockquote> <b>OBJBYBLK</b>  <em>[[path][filename[.ext]]]</em><br> <b>RAWBYBLK</b>  <em>[[path][filename[.ext]]]</em><br> <b>HEXBYBLK</b>  <em>[[path][filename[.ext]]]</em><br> <b>SRECBYBLK</b>  <em>[[path][filename[.ext]]]</em><br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>[[path][filename[.ext]]]</em> is an optional <a href="#L009">path_name</a></li>
 </ul>
<h4>Description</h4>
<p>By default HXA produces no output except status and error messages. These are sent only to <em>stdout</em> (normally the display console).</p>
<p>Any or all of these pseudo opcodes can be used to produce one or more output files. They may all be used more than once, but each use of the same pseudo opcode must specify the same filename.</p>
<ul> <li>if no <em>filename</em> is provided, a default filename (based on the name of the <a href="#L007">root file</a>) with a default extension will be created</li>
 <li>if only a <em>path</em> is provided (ie., it ends with a directory name), the same default filename as above will be added to it</li>
 <li>if a <em>filename</em> is provided without an <em>ext</em>, a default extension will be added</li>
 <li>if a <em>filename</em> without a <em>path</em> is provided, the file will be placed in the same directory as the root file</li>
 </ul>
<p>A <em>filename.ext</em> more than 32 characters long will cause a warning, but is not prohibited.</p>
<p>Characters legal in filenames vary between operating systems. Using a character not reasonably certain to be portable across operating systems will cause a warning, but is likewise not prohibited.</p>
<p>Characters which will cause a warning include most non-alphanumeric, whitespace, and control characters. Characters which will <em>not</em> cause a warning include:</p>
<ul> <li>code point 0x23 ('#', ASCII sharp)</li>
 <li>code point 0x2D ('-', ASCII hypen)</li>
 <li>code point 0x2E ('.', ASCII period)</li>
 <li>all code points in the range 0x30 to 0x39 (ASCII numerics)</li>
 <li>all code points in the range 0x41 to 0x5A (ASCII uppercase alphabetics)</li>
 <li>code point 0x5F, ('_', ASCII underscore)</li>
 <li>all code points in the range 0x61 to 0x7A (ASCII lowercase alphabetics)</li>
 <li>all code points in the range 0xA1 to 0xFF</li>
 </ul>
<p>Note that the sharp character ('#', ASCII 0x23) causes HXA to treat the filename as a <a href="#L05B">template</a>.</p>
<hr>
<h4>--FILE Types</h4>
<hr>
<a id="L055"></a>
<h4><b>ERRFILE</b></h4>
<p>At the end of assembly, all <a href="#L093">ECHO</a>, warning and error messages are written to the specified text file. If none of these were produced, there will be no error file, even if one is specified.</p>
<p>The default extension is <b>ERR</b> .</p>
<p>By default, an error file shows:</p>
<ul> <li>a header showing the assembler name, instruction set, <a href="#L007">root file</a>, program type, and file creation time and date</li>
 <li>the pass number, before any warnings or errors from that pass</li>
 <li>the error type and the source file being read when the error was detected</li>
 <li>what the assembler was doing when the error was detected</li>
 <li>the text of the source line in which the error was detected</li>
 <li>what the reason for the error was</li>
 </ul>
<p>Except for the header, this is the same information that is sent by default to <em>stdout</em> during assembly. An error file just collects all the error messages in one place for later perusal.</p>
<p>Note that if an error occurs during an expansion of any kind, stack unwinding may repeat some line types of the message with new information until the error is reached.</p>
<p>Warning messages alone will not halt HXA. They will not prevent the production of any other files.</p>
<p>Error messages will cause HXA to end assembly at the end of the current pass, or immediately if the error is fatal. No other files will be produced.</p>
<hr>
<a id="L056"></a>
<h4><b>LISTFILE</b></h4>
<p>After a successful assembly, creates an text file containing both the source code and a hexadecimal representation of the object code.</p>
<p>The default extension is <b>LST</b> .</p>
<p>By default, a listing file shows:</p>
<ul> <li>a header showing the assembler name, instruction set, <a href="#L007">root file</a>, program type, and file creation time and date</li>
 <li>the source and object code of every source line which produced object code</li>
 <li>the source code of every non-expansion line which did <em>not</em> produce object code</li>
 <li>the names, values and reference counts of all <a href="#L020">global</a> labels, in alphabetic name order</li>
 <li>the names and reference counts of all <a href="#L07F">macros</a> defined, in alphabetic name order</li>
 <li>if the program is <a href="#L010">segmented</a>, a list of information about all named segments, in the order they were created</li>
 </ul>
<p>By default, a listing file does <em>not</em> show:</p>
<ul> <li>the source code of any macro expansion line which did <em>not</em> produce object code</li>
 <li>any source code found in untaken conditional branches</li>
 <li>any cross-reference of global labels or macro names or both</li>
 <li>any assembly statistics</li>
 </ul>
<p>These defaults, and several others, can be turned on or off using the pseudo opcodes <a href="#L061">LISTON</a> and <a href="#L061">LISTOFF</a>.</p>
<hr>
<a id="L057"></a>
<h4><b>OBJFILE, OBJBYSEG, OBJBYBLK</b></h4>
<p>Create absolute binary output files.</p>
<p>The default extension is <b>OBJ</b> .</p>
<p>The output file contains the result of every line of source code that produced object code, without additions or subtractions.</p>
<p>If the source code represents an executable program, the object file will also be executable.</p>
<p><b>OBJBYSEG</b>  and <b>OBJBYBLK</b>  can be used anywhere, but only have an effect in <a href="#L010">segmented</a> programs. Once used, every subsequent use must have the same <em>[[path][filename[.ext]]]</em>.</p>
<p>They also output only those segments which contain object data.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L136">Object Output (By Segments, Default Names)</a></li>
 <li><a href="hxa_test.htm#L137">Object Output (By Segments, "####." Template)</a></li>
 <li><a href="hxa_test.htm#L138">Object Output (By Blocks, Default Names)</a></li>
 <li><a href="hxa_test.htm#L139">Object Output (By Blocks, ".###" Template)</a></li>
 </ul>
<hr>
<a id="L058"></a>
<h4><b>RAWFILE, RAWBYSEG, RAWBYBLK</b></h4>
<p>Produce ASCII text files representing the absolute object code as two hexadecimal characters for each 8-bit octet of object. There is no addtional information of any kind: no record types, addresses, counts or check sums.</p>
<p>The default extension is <b>RAW</b> .</p>
<p><b>RAWBYSEG</b>  and <b>RAWBYBLK</b>  can be used anywhere, but only have an effect in <a href="#L010">segmented</a> programs. Once used, every subsequent use must have the same <em>[[path][filename[.ext]]]</em>.</p>
<p>They also output only those segments which contain object data.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L13A">Raw Hex Output (By Segments, Default Names)</a></li>
 <li><a href="hxa_test.htm#L13B">Raw Hex Output (By Segments, "##." Template)</a></li>
 <li><a href="hxa_test.htm#L13C">Raw Hex Output (By Blocks, Default Names)</a></li>
 <li><a href="hxa_test.htm#L13D">Raw Hex Output (By Blocks, ".###" Template)</a></li>
 </ul>
<hr>
<a id="L059"></a>
<h4><b>HEXFILE, HEXBYSEG, HEXBYBLK</b></h4>
<p>Produce ASCII text files representing the absolute object code in <a href="#L0A8">Intel Hexadecimal Object</a> file format.</p>
<p>The default file extension is <b>HEX</b> .</p>
<p><b>HEXBYSEG</b>  and <b>HEXBYBLK</b>  can be used anywhere, but only have an effect in <a href="#L010">segmented</a> programs. Once used, every subsequent use must have the same <em>[[path][filename[.ext]]]</em>.</p>
<p>They also output only those segments which contain object data.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L129">Intel Hexfile Output (Single File)</a></li>
 <li><a href="hxa_test.htm#L12A">Intel Hexfile Output (By Segments, Default Names)</a></li>
 <li><a href="hxa_test.htm#L12B">Intel Hexfile Output (By Segments, "###" Template)</a></li>
 <li><a href="hxa_test.htm#L12D">Intel Hexfile Output (By Blocks, Default Names)</a></li>
 <li><a href="hxa_test.htm#L12E">Intel Hexfile Output (By Blocks, ".###" Template)</a></li>
 <li><a href="hxa_test.htm#L12F">Intel Hexfile Output (By Blocks, Overlapping)</a></li>
 </ul>
<hr>
<a id="L05A"></a>
<h4><b>SRECFILE, SRECBYSEG, SRECBYBLK</b></h4>
<p>Produce ASCII text files representing the absolute object code in <a href="#L0AA">Motorola SRecord Object</a> file format.</p>
<p>The default file extension is <b>S19</b> , <b>S28</b>  or <b>S37</b> , depending on whether the processor specified by <a href="#L06A">CPU</a> has an address width of up to 16-, 24- or 32-bits, respectively.</p>
<p><b>SRECBYSEG</b>  and <b>SRECBYBLK</b>  can be used anywhere, but only have an effect in <a href="#L010">segmented</a> programs. Once used, every subsequent use must have the same <em>[[path][filename[.ext]]]</em>.</p>
<p>The first (header) record in each file produced by these pseudo opcodes will contain the <a href="#L007">root file</a> name (unless this record is suppressed).</p>
<p>They also output only those segments which contain object data.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L130">Motorola Hexfile Output (Single File)</a></li>
 <li><a href="hxa_test.htm#L131">Motorola Hexfile Output (By Segments, Default Names)</a></li>
 <li><a href="hxa_test.htm#L132">Motorola Hexfile Output (By Segments, "###." Template)</a></li>
 <li><a href="hxa_test.htm#L133">Motorola Hexfile Output (Default Names, No Header)</a></li>
 <li><a href="hxa_test.htm#L134">Motorola Hexfile Output (By Blocks, Default Names)</a></li>
 <li><a href="hxa_test.htm#L135">Motorola Hexfile Output (By Blocks, ".###" Template)</a></li>
 </ul>
<hr>
<a id="L05B"></a>
<h4>--BYSEG and --BYBLK Types</h4>
<p>When segments of a program are output either individually or as connected blocks, the default naming method for each segment or block is to insert a segment name after <em>filename</em> and before the <em>.ext</em> for that file type.</p>
<blockquote> <em>filename.ext</em> becomes <em>filename_segname1.ext, filename_segname2.ext,</em> etc.<br> </blockquote>
<p>The extensions themselves are same as the default extensions of the corresponding <b>--FILE</b>  types. The segment name is the same as the current segment if <b>--BYSEG</b> , or the name of the first segment in a block if <b>--BYBLK</b> :</p>
<p>However, if <em>filename</em> or <em>ext</em> contains a run of one or more sharp characters ('#', ASCII 0x23), the name is treated as a <em>template</em> name. Runs of sharp characters will be replaced by a numeric value based on segment numbers:</p>
<blockquote> <em>filename###.ext</em> becomes <em>filename001.ext, filename002.ext,</em> etc.<br> </blockquote>
<ul> <li>for <b>--FILE</b> , the number is always one (1)</li>
 <li>for <b>--BYSEG</b> , the number is the current segment number</li>
 <li>for <b>--BYBLK</b> , the number is the first segment number in each block</li>
 </ul>
<p>A '#' character cannot appear:</p>
<ul> <li>anywhere in a <em>path</em></li>
 <li>as the first character of <em>filename</em></li>
 <li>separated from another sharp character by one or more non-sharp characters</li>
 </ul>
<hr>
<a id="L05C"></a>
<h4><b>OBJBYSEG, RAWBYSEG, HEXBYSEG, SRECBYSEG</b></h4>
<p>Produce one output file for every segment of a program that contains object data. Segments that do not contain object data are not output.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L13A">Raw Hex Output (By Segments, Default Names)</a></li>
 <li><a href="hxa_test.htm#L13B">Raw Hex Output (By Segments, "##." Template)</a></li>
 </ul>
<hr>
<a id="L05D"></a>
<h4><b>OBJBYBLK, RAWBYBLK, HEXBYBLK, SRECBYBLK</b></h4>
<p>Produce one output file for every continuous sequence of segments that contain object data. Segments that do not contain object data are not output.</p>
<p>A new output file is started each time there is a non-continuous address jump between one segment and its physical successor.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L13C">Raw Hex Output (By Blocks, Default Names)</a></li>
 <li><a href="hxa_test.htm#L13D">Raw Hex Output (By Blocks, ".###" Template)</a></li>
 </ul>
<hr>
<a id="L05E"></a>
<h4><b>INCLUDE</b></h4>
<h4>Usage</h4>
<blockquote> <b>INCLUDE</b>  <em>[path]</em>filename<em>[.ext]</em><br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>[path]filename[.ext]</em> is a <a href="#L009">path_name</a></li>
 </ul>
<h4>Description</h4>
<p>Causes HXA to begin reading source lines from <em>filename</em>.</p>
<p>A <em>filename</em> is required, but <em>path</em> and <em>.ext</em> are optional.</p>
<p>It is assumed <em>filename</em> is a UTF-8 text file of source code lines for the <a href="#L06A">CPU</a> specified. From the point of view of the assembler, it as if those lines had always been there.</p>
<p>When all lines of <em>filename</em> have been read, the assembler resumes reading from the file that contained the <b>INCLUDE</b> .</p>
<p>Because HXA accepts only one filename on its command line, multiple source files can be assembled together <em>only</em> by using this pseudo opcode within that file.</p>
<p>Include files have their own <a href="#L00D">local scope</a>. <a href="#L022">Local</a> labels defined in this scope will not conflict with the same name in other scopes.</p>
<p>Include files may be nested to <a href="#L09F">MAXDEPTH</a>.</p>
<p>File inclusion is <em>not</em> possible within <a href="#L080">MACRO</a>, <a href="#L084">REPEAT</a> or <a href="#L086">WHILE</a> block expansions. They can happen within <a href="#L08D">IF</a> blocks, though these also count against <b>MAXDEPTH</b> .</p>
<p>Any <em>filename</em> may be included more than once. This will cause a warning at the second and later inclusions, but is not prohibited. However, if <em>filename</em> has already been marked <a href="#L060">READONCE</a>, any inclusion afterwards will be silently ignored.</p>
<h4>Example</h4>
<ul> <li><a href="hxa_test.htm#L103">File Inclusion</a></li>
 </ul>
<hr>
<a id="L05F"></a>
<h4><b>INCBIN</b></h4>
<h4>Usage</h4>
<blockquote> <b>INCBIN</b>  <em>[path]</em>filename<em>[.ext] [, offset [, size]]</em><br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>[path]filename[.ext]</em> is a <a href="#L009">path_name</a></li>
 <li><em>offset</em> is an optional zero-based <a href="#L009">const_expr</a></li>
 <li><em>size</em> is an optional <a href="#L009">const_expr</a></li>
 </ul>
<h4>Description</h4>
<p>Causes HXA to include binary octets from <em>filename</em> into the object code.</p>
<p>A <em>filename</em> is required, but <em>path</em> and <em>.ext</em> are optional.</p>
<p>The binary data that <em>filename</em> contains is not processed. Its octets are directly incorporated into the object code without further interpretation.</p>
<p>If <em>offset</em> is not present, HXA reads all of <em>filename</em> from its start.</p>
<p>Octets in the file are numbered zero to the size of the file minus one. If <em>offset</em>:</p>
<ul> <li>has an absolute value greater than the size of the file minus one, HXA will <em>not</em> read <em>filename</em></li>
 <li>is zero or positive, HXA will read <em>filename</em> from that point</li>
 <li>is negative, HXA will subtract its absolute value from the size of <em>filename</em> and read from that point</li>
 </ul>
<p>If <em>size</em> is not present, HXA reads octets from wherever it starts to the end of <em>filename</em>.</p>
<p>If <em>size</em> is present, it represents the maximum number of octets to read. A value of zero or less is a flag interpreted to mean "read the remainder of <em>filename</em> after <em>offset</em>".</p>
<p>If there <em>size</em> octets do not remain in <em>filename</em> after <em>offset</em> has been applied, a warning will be issued. Only as many octets as actually available will be read.</p>
<p>Note that a <em>size</em> cannot be specified unless an <em>offset</em> has been specified first. A value of zero for <em>offset</em> and non-zero for <em>size</em> means "read the first <em>size</em> octets of <em>filename</em>".</p>
<h4>Example</h4>
<blockquote> <a href="hxa_test.htm#L10C">Binary Inclusion</a><br> </blockquote>
<hr>
<a id="L060"></a>
<h4><b>READONCE</b></h4>
<h4>Usage</h4>
<blockquote> <b>READONCE</b><br> </blockquote>
<h4>Description</h4>
<p>Tags the current source file to prevent any other source file from from <a href="#L05E">including</a> it.</p>
<p>Instead, any attempt is silently ignored. Processing simply continues with the next line of the file that attempted to include it.</p>
<p>The intent is to prevent a source file from being included more than once during an assembly.</p>
<p>This pseudo opcode can be used anywhere in a source file, any number of times. However, in general it is best to use <b>READONCE</b>  in a source file <em>before</em> it tries to include any other file. Otherwise warnings may occur if the current file has already been included by any other file.</p>
<h4>Example</h4>
<blockquote> <a href="hxa_test.htm#L108">Read Exclusion</a><br> </blockquote>
<hr>
<a id="L061"></a>
<h4><b>LISTON, LISTOFF</b></h4>
<h4>Usage</h4>
<blockquote> <b>LISTON</b>  <em>[flagname [[, flagname] ..]]</em><br> </blockquote>
<blockquote> <b>LISTOFF</b>  <em>[flagname [[, flagname] ..]]</em><br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>flagname</em> is an optional <a href="#L009">opt_str</a></li>
 </ul>
<h4>Description</h4>
<p><b>LISTON</b>  enables, and <b>LISTOFF</b>  disables, various options used by HXA to create a <a href="#L056">listfile</a>.</p>
<p>These pseudo opcodes can appear any number of times in the source code file(s). Note that when a listing begins, the listing flags are in the state set by their last use in the source code.</p>
<p>If no flag is specified, they both default to setting the <b>OBJECT</b>  flag.</p>
<p>If a flag is not recognized, it is ignored.</p>
<p>A listing file has up to five major sections:</p>
<ul> <li>Object</li>
 <li>Labels</li>
 <li>Cross-Reference</li>
 <li>Segments Map</li>
 <li>Statistics</li>
 </ul>
<hr>
<a id="L062"></a>
<h4>Object Section</h4>
<p>The Object section lists all or part of the source code, together with a hexadecimal representation of the object code.</p>
<p>The <b>OBJECT</b>  flag controls whether or not there is an object section at all. By default it is <em>ON</em>, and an object section will be produced.</p>
<p>The <b>OBJECT</b>  flag can be turned off at any point in the source code. There will be no listing of source or object until it is turned <em>ON</em> again. If it is <em>OFF</em> at the end of assembly, then no object section will be produced.</p>
<p>The <b>OBJECT</b>  flag is at the top of a hierarchy of object section listing flags. If any of them are <em>OFF</em> at any point, no flag of a lesser priority has any effect until the higher flag is turned <em>ON</em> again.</p>
<h4>Object Listing Control Flags and Default Settings (In order of priority):</h4>
<ul> <li><b>OBJECT</b>  : ON : All source lines</li>
 <li><b>SOURCE</b>   : ON : Source lines which do not produce object code</li>
 <li><b>INCLUDES</b>  : ON : Contents of <a href="#L05E">INCLUDE</a> files</li>
 <li><b>MACROS</b>  : OFF : Every line of macro expansions</li>
 <li><b>UNTAKEN</b>  : OFF : Untaken conditional branches</li>
 </ul>
<h4>Origin of Source Code Lines</h4>
<p>Source code lines are tagged with a prefix character indicating where they came from:</p>
<ul> <li>'&nbsp;' : ASCII 0x20 : from the <a href="#L007">root file</a></li>
 <li>'^' : ASCII 0x5E : from macro expansion in the root file</li>
 <li>'+' : ASCII 0x2B : from an <b>INCLUDE</b>  file</li>
 <li>'>' : ASCII 0x3E : from macro expansion in an <b>INCLUDE</b>  file</li>
 </ul>
<hr>
<h4>Labels Section</h4>
<p>The Labels section lists some or all of the symbols defined during assembly, together with their reference counts and values.</p>
<p>The <b>LABELS</b>  flag controls whether or not there is a labels section at all. By default it is <em>ON</em>, and a labels section will be produced. All <a href="#L020">global</a> labels will be listed in alphabetic order, along with their reference counts and their values. All <a href="#L080">macro</a> names will be listed in alphabetic order, along with their expansion counts.</p>
<p>The <b>LABELS</b>  flag can be turned off at any point in the source code. If it is <em>OFF</em> at the end of assembly, then no labels section will be produced.</p>
<p>The <b>LABELS</b>  flag is the master labels section flag. If it is <em>ON</em> at the end of assembly, three other flags can have an effect.</p>
<h4>Labels Listing Control Flags and Default Settings:</h4>
<ul> <li><b>LABELS</b>  : ON : Global labels in alphabetic order</li>
 <li><b>LBLVAL</b>  : OFF : Global labels in numeric order</li>
 <li><b>AUTOS</b>  : OFF : Local, variable and anonymous labels in alphabetic order</li>
 <li><b>MACNAMES</b>  : ON : Macro names in alphabetic order</li>
 </ul>
<hr>
<h4>Cross-Reference Section</h4>
<p>The cross-reference section lists events, line numbers and source files related to <a href="#L020">global</a> labels and <a href="#L080">macro</a> names.</p>
<p>The <b>XREF</b> , <b>XMACRO</b>  and <b>XGLOBAL</b>  flags control whether or not a cross-reference section is produced. By default all of them are <em>OFF</em>, and no cross-reference section will be produced. If any of them are <em>ON</em> at the end of assembly, a cross-reference section will be produced.</p>
<p>All of these flags may be turned <em>ON </em>and <em>OFF</em> as often as desired.</p>
<p>Whenever any of them are <em>ON</em>, data is collected that will be used to create this section. Every global label and macro name defined or referenced while a flag is <em>ON</em> can be listed in the cross-reference section.</p>
<p>Global labels and macro names can be separately cross-referenced. If both types are enabled, global labels will be listed first. Names are organized alphabetically in each section.</p>
<p>In each section of a cross-reference, the first line of each section lists the global label or macro name. Following this are one or more detail lines. Each detail line lists:</p>
<ul> <li>the event type (for globals: equate, reference; for macros: definition, expansion, undefinition)</li>
 <li>the listing file line number of the event (only if the <b>LINENUMS</b>  listing flag is <em>ON</em>)</li>
 <li>the source file line number of the event</li>
 <li>the source file name (if it is not the <a href="#L007">root file</a>)</li>
 </ul>
<p>Groups of identical detail lines may be reported as one detail line followed by a line indicating how many times it repeats.</p>
<h4>Cross-Reference Flags</h4>
<ul> <li><b>XREF</b>  : OFF : Cross-reference both global labels and macro names</li>
 <li><b>XMACRO</b>  : OFF : Cross-reference just macro names</li>
 <li><b>XGLOBAL</b>  : OFF : Cross-reference just global labels</li>
 </ul>
<hr>
<h4>Segments Section</h4>
<p>The state of the <b>SEGMENTS</b>  flag controls whether or not a segment map is produced. The default is <em>ON</em> if the program is <a href="#L010">segmented</a>, <em>OFF</em> if it is <a href="#L00F">monolithic</a>.</p>
<p>If this flag is <em>ON</em> at the end of assembly, a segment map will be produced.</p>
<p>This section lists the segments in the same order they first appear in the source code.</p>
<p>Each segment will be listed by name and number. Its type, starting address, ending address, and size will follow. If the segment contains object code, its offset from the start of the object file will also be shown. If instead it is <a href="#L019">uninitialized</a> and contains no object code, no offset will be shown because it will not appear in any output file.</p>
<hr>
<h4>Statistics Section</h4>
<p>The statistics section lists miscellaneous data concerning the current assembly.</p>
<p>The state of the <b>STATS</b>  flag controls whether or not a statistics section is produced. The default state is <em>OFF</em>, and no statistics section will be produced.</p>
<p>If the <b>STATS</b>  flag is <em>ON</em> when assembly ends, HXA currently reports:</p>
<ul> <li>the number and type (ie., source or expansion) of source lines assembled</li>
 <li>the time taken to read the source lines (pass one)</li>
 <li>the lines read per second</li>
 <li>the number of 32-bit data values created during the first pass</li>
 <li>the time taken to resolve any forward references and then range check the final data values (pass two)</li>
 <li>the resolutions per second</li>
 <li>the total time taken for both passes</li>
 <li>the object byte size</li>
 </ul>
<hr>
<h4>Other Listing Control Flags</h4>
<ul> <li><b>ALLEQU</b>  : OFF : Value of <a href="#L078">EQU</a> assignments to <a href="#L022">local</a>, <a href="#L023">variable</a> and <a href="#L024">anonymous</a> labels as well as global ones</li>
 <li><b>LINENUMS</b>  : OFF : Consecutively number every line of a <a href="#L056">listfile</a></li>
 <li><b>LINEWRAP</b>  : ON : Text which exceeds the allowed line width is "wrapped" to successive lines as often as needed until completely printed. If this flag is <em>OFF</em> at the end of assembly, every line is truncated at no more than the allowed line width</li>
 <li><b>PADDING</b>  : ON : The contents of <a href="#L017">PADTO</a> and <a href="#L018">PADFROM</a> segments are listed at the end of the <b>OBJECT</b>  section. If this flag is <em>OFF</em> at the end of assembly, padded segments will not be listed except in the <b>SEGMENTS</b>  section.</li>
 </ul>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L14A">Listing</a></li>
 <li><a href="hxa_test.htm#L157">Cross-Reference</a></li>
 </ul>
<hr>
<a id="L063"></a>
<h4><b>PAGESIZE</b></h4>
<h4>Usage</h4>
<blockquote> <b>PAGESIZE</b>  page_width <em>[, page_height]</em><br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>page_width</em> is a <a href="#L009">const_expr</a> in the range [0, 255] inclusive</li>
 <li><em>page_height</em> is an optional <a href="#L009">const_expr</a> in the range [0, 255] inclusive</li>
 </ul>
<h4>Description</h4>
<p>Controls the width and length of a page in a <a href="#L056">listfile</a>.</p>
<p><em>Page_width</em> controls the page width, the total number of characters that can fit across a page.</p>
<p>Its default value of zero (0) is interpreted as meaning a page of infinite width. Every output line is printed in its entirety without wrapping or truncation.</p>
<p>A non-zero value means no more than that number of characters will fit between the left and right margins. If there are more, the line will be wrapped to the next line (LINEWRAP is <em>ON</em>, the default) or truncated there (LINEWRAP is <em>OFF</em>).</p>
<p>The optional <em>page_height</em> controls the page length, the total number of lines that can fit on a page.</p>
<p>Its default value of zero (0) is interpreted as meaning a page of infinite length. Every output line is printed one after another with no page breaks.</p>
<p>A non-zero value means a page break will occur every time the number of lines on a page cannot fit between the top and bottom margins.</p>
<p><b>PAGESIZE</b>  may be used as many times as desired, but must have the same value(s) each time. Use of an illegal value causes an error and the affected parameter retains its current value (although because of the error no listing will occur).</p>
<p>The default values of zero (0) for both parameters are suitable for "printing" to list files meant to be loaded into a text editor. They may not be in other circumstances.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L151">Pagination</a></li>
 </ul>
<hr>
<a id="L064"></a>
<h4><b>PAGE</b></h4>
<h4>Usage</h4>
<blockquote> <b>PAGE</b><br> </blockquote>
<h4>Description</h4>
<p>Unconditionally execute a form feed in a <a href="#L056">listfile</a>.</p>
<p>Enough blanks lines are printed to fill the rest of the current listing page. The next printed line will appear at the top margin of the next page.</p>
<p><b>PAGE</b>  has no effect during either assembly pass, in <a href="#L063">unpaginated</a> listing files or in unlisted portions of the source code.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L156">Formfeed</a></li>
 </ul>
<hr>
<a id="L065"></a>
<h4><b>MARGINS</b></h4>
<h4>Usage</h4>
<blockquote> <b>MARGINS</b>  top, lft <em>[, bot [, rgt]]</em><br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>top</em> is a <a href="#L009">const_expr</a> in the range [0, 254] inclusive</li>
 <li><em>lft</em> is a <a href="#L009">const_expr</a> in the range [0, 254] inclusive</li>
 <li><em>bot</em> is an optional <a href="#L009">const_expr</a> in the range [0, 254] inclusive</li>
 <li><em>rgt</em> is an optional <a href="#L009">const_expr</a> in the range [0, 254] inclusive</li>
 </ul>
<h4>Description</h4>
<p>Sets the number of characters to leave blank at the left and right edges of each page in a <a href="#L056">listfile</a>. Optionally sets the number of lines to leave blank at the top and bottom edges.</p>
<p>The default value for all four parameters is zero (0).</p>
<p>If <a href="#L063">PAGESIZE</a> specifies a non-zero width, by default lines printed will have no space at the left edge.</p>
<p>If <em>lft</em> is non-zero, that many blank characters will be printed before each line.</p>
<p>If <em>rgt</em> is non-zero, characters will not be printed beyond the page width minus <em>rgt</em>. Instead, lines will be broken at the greater of the rightmost comma (',', ASCII 0x2C) or space ('&nbsp;', ASCII 0x20). If neither applies, the printing will stop at the page width minus <em>rgt</em>.</p>
<p>The left and right margins combined cannot be greater than the page width.</p>
<p>If <b>PAGESIZE</b>  specifies a non-zero height, by default lines will be printed flush with the top and bottom of each page.</p>
<p>If <em>top</em> is non-zero, that many blank lines will be printed at the top of each page.</p>
<p>If <em>bot</em> is non-zero, that many blank lines will be left at the bottom of each page.</p>
<p>The top and bottom margins combined cannot be greater than the page height.</p>
<p><b>MARGINS</b>  may be used as many times as desired, but must have the same value(s) each time. Use of an illegal value causes an error and the affected parameter retains its current value (although because of the error no listing will occur).</p>
<p>The default of zero (0) for all four parameters are suitable for "printing" to list files meant to be loaded into a text editor. They may not be in other circumstances.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L150">Change Left Margin</a></li>
 <li><a href="hxa_test.htm#L151">Pagination</a></li>
 </ul>
<hr>
<a id="L066"></a>
<h4><b>LINESPACE</b></h4>
<h4>Usage</h4>
<blockquote> <b>LINESPACE</b>  count<br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>count</em> is a <a href="#L009">const_expr</a> in the range [1, 254] inclusive</li>
 </ul>
<h4>Description</h4>
<p>Sets the number of page lines each printed line in a <a href="#L056">listfile</a> uses.</p>
<p>The default and minimum <em>count</em> value is one (1). There are no blank lines between listing lines. Each line is printed one after another.</p>
<p>A <em>count</em> value higher than one inserts <em>count-1</em> blank lines between each printed line.</p>
<p>The maximum allowed value is the maximum page length minus one.</p>
<p>This is not the same as the actual <a href="#L063">page length</a>. In particular, <b>LINESPACE</b>  may have a value greater than the actual page length. This results in each listfile page having only one printed line.</p>
<p><b>LINESPACE</b>  may be used as many times as desired, but must have the same value each time. Use of an illegal value causes an error, and line spacing retains its current value.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L152">Change Line Spacing</a></li>
 </ul>
<hr>
<a id="L067"></a>
<h4><b>TITLE</b></h4>
<h4>Usage</h4>
<blockquote> <b>TITLE</b>  <em>[title]</em><br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>title</em> is an optional <a href="#L009">opt_str</a></li>
 </ul>
<h4>Description</h4>
<p>Replace the default header of <a href="#L056">listfile</a> with a string that will appear just once as its first line.</p>
<p>If <em>title</em> is not present, a listing will have no heading at all.</p>
<p><b>TITLE</b>  may be used as many times as desired, but must have the same value (or lack of value) each time.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L153">Change Header</a></li>
 </ul>
<a id="L068"></a>
<a id="L069"></a><h3>Pseudo Opcodes</h3>
<ul> <li><a href="#L06C">ABSORG</a> : set program counter address; <em>aliases</em> : ORG, $=, &ast;=</li>
 <li><a href="#L015">ABSEND</a> : set ending address of a segment</li>
 <li><a href="#L097">ASSERT</a> : trigger an error if a condition is <em>FALSE</em></li>
 <li><a href="#L09D">ASSUME</a> : control an HXA option</li>
 </ul>
<ul> <li><a href="#L06E">BIT08</a> : store 8-bit value into object code; <em>aliases</em> : BYTE, FCB</li>
 <li><a href="#L06E">BIT16</a> : store 16-bit value into object code; <em>aliases</em> : WORD, FDB</li>
 <li><a href="#L06E">BIT24</a> : store 24-bit value into object code</li>
 <li><a href="#L06E">BIT32</a> : store 32-bit value into object code; <em>alias</em> : LONG</li>
 <li><a href="#L06E">BIT08R</a> : store reversed 8-bit value into object code; <em>aliases</em> : REVBYTE, REVFCB</li>
 <li><a href="#L06E">BIT16R</a> : store reversed 16-bit value into object code; <em>aliases</em> : REVWORD, REVFDB</li>
 <li><a href="#L06E">BIT24R</a> : store reversed 24-bit value into object code</li>
 <li><a href="#L06E">BIT32R</a> : store reversed 32-bit value into object code; <em>alias</em> : REVLONG</li>
 </ul>
<ul> <li><a href="#L01A">COMMON</a> : flags that all fragments of a segment start at the same address</li>
 <li><a href="#L06A">CPU</a> : set the processor to assemble object code and data for</li>
 </ul>
<ul> <li><a href="#L076">DS</a> : define uninitialized storage space; <em>aliases</em> : RES, RESERVE, RMB</li>
 </ul>
<ul> <li><a href="#L093">ECHO</a> : programmer-triggered informational message</li>
 <li><a href="#L090">ELSE</a> : unconditionally begin an alternative branch in a conditional block</li>
 <li><a href="#L08F">ELSEIF</a> : conditionally begin an alternative branch in a conditional block; <em>alias</em> : ELIF</li>
 <li><a href="#L06D">END</a> : terminate reading a source file</li>
 <li><a href="#L08E">ENDIF</a> : terminate a conditional block</li>
 <li><a href="#L081">ENDMACRO</a> : terminate a macro definition; <em>alias</em> : ENDM</li>
 <li><a href="#L085">ENDREPEAT</a> : terminate a repeat definition; <em>alias</em> : ENDR</li>
 <li><a href="#L013">ENDSEGMENT</a> : terminate a segment fragment; <em>alias</em> ENDS</li>
 <li><a href="#L087">ENDWHILE</a> : terminate a while definition; <em>alias</em> : ENDW</li>
 <li><a href="#L078">EQU</a> : assign a constant value to a label; <em>alias</em> =</li>
 <li><a href="#L095">ERROR</a> : programmer-triggered error message</li>
 <li><a href="#L055">ERRFILE</a> : a text file containing all echo, warning and error messages produced during assembly</li>
 <li><a href="#L088">EXIT</a> : unconditionally skip to end of block expansion</li>
 <li><a href="#L089">EXITIF</a> : conditionally skip to end of block expansion</li>
 </ul>
<ul> <li><a href="#L096">FATAL</a> : programmer-triggered fatal error message</li>
 <li><a href="#L075">FILL</a> : fill a block with constant data</li>
 <li><a href="#L074">FLOAT</a>: store floating point value(s) into object code</li>
 </ul>
<ul> <li><a href="#L072">HEX</a> : a string of hexadecimal character pairs</li>
 <li><a href="#L059">HEXBYBLK</a> : one or more text files, each representing address-consecutive segments of the object code produced; <em>alias</em> : HEXBYBLOCK</li>
 <li><a href="#L059">HEXBYSEG</a> : one or more text files, each representing a single segment of the object code produced</li>
 <li><a href="#L059">HEXFILE</a> : a single text file representing all of the object code produced</li>
 </ul>
<ul> <li><a href="#L08D">IF</a> : start a conditional block; assemble it if <em>TRUE</em></li>
 <li><a href="#L091">IFDEF</a> : start a conditional block;  assemble it if a label or macro exists</li>
 <li><a href="#L092">IFNDEF</a> : start a conditional block; assemble it if a label or macro does not exist</li>
 <li><a href="#L05F">INCBIN</a> : include a file as uninterpreted binary data</li>
 <li><a href="#L05E">INCLUDE</a> : include a file as assembler source code</li>
 </ul>
<ul> <li><a href="#L066">LINESPACE</a> : number of lines required by each printed line of a list file</li>
 <li><a href="#L056">LISTFILE</a> : a text file representing source code and any asssociated object code produced</li>
 <li><a href="#L061">LISTOFF</a> : disable listing option</li>
 <li><a href="#L061">LISTON</a> : enable listing option</li>
 </ul>
<ul> <li><a href="#L080">MACRO</a> : start a macro definition; <em>alias</em> : MAC</li>
 <li><a href="#L065">MARGINS</a> : set the page margins in a listing file</li>
 <li><a href="#L09F">MAXDEPTH</a> : set the maximum local scope nesting depth allowed</li>
 <li><a href="#L0A1">MAXERR</a> : set the maximum number of error messages allowed</li>
 <li><a href="#L0A0">MAXLOOP</a> : set the maximum number of consecutive <b>REPEAT</b>  or <b>WHILE</b>  expansions allowed</li>
 <li><a href="#L0A3">MAXPUTBACK</a> : set the maximum number of consecutive <b>PUTBACK</b>  or <b>PUTBACKS</b>  lines allowed</li>
 <li><a href="#L0A4">MAXSEG</a> : set the maximum number of program segments allowed</li>
 <li><a href="#L0A5">MAXSTACK</a> : set the maximum number of strings on the user stack allowed</li>
 <li><a href="#L0A2">MAXWARN</a> : set the maximum number of warning messages allowed</li>
 <li><a href="#L09C">MESGTEXT</a> : assign arbitary text to a built-in message index</li>
 <li><a href="#L07A">MINUSEQU</a> : subtract a numeric value from a variable label; <em>alias</em> : -=</li>
 </ul>
<ul> <li><a href="#L057">OBJBYBLK</a> : one or more binary files, each containing consecutive segments of object code produced; <em>alias</em> : OBJBYBLOCK</li>
 <li><a href="#L057">OBJBYSEG</a> : one or more binary files, each containing a single segment of object code produced</li>
 <li><a href="#L057">OBJFILE</a> : a single binary file containing all the object code produced</li>
 </ul>
<ul> <li><a href="#L018">PADFROM</a> : insert octets until the start of the next segment</li>
 <li><a href="#L017">PADTO</a> : insert octets until the program counter is a multiple of an address</li>
 <li><a href="#L064">PAGE</a> : print a formfeed to a listing file</li>
 <li><a href="#L063">PAGESIZE</a> : set the width and height of a page in a listing file</li>
 <li><a href="#L079">PLUSEQU</a> : add a string or numeric value to a variable label; <em>alias</em> : +=</li>
 <li><a href="#L09A">PSALIAS</a> : refer to a built-in pseudo opcode by a different name</li>
 <li><a href="#L09B">PSNULL</a> : ignore incompatible pseudo opcode when porting source code to HXA</li>
 <li><a href="#L07E">PUSHS</a> : push evaluated string onto the user stack</li>
 <li><a href="#L08A">PUTBACK</a> : push un-evaluated argument back onto the input stream as-is; <em>alias</em> : ONEXPAND</li>
 <li><a href="#L08B">PUTBACKS</a> : push evaluated argument back onto the input stream; <em>alias</em> : PUTSTR</li>
 </ul>
<ul> <li><a href="#L058">RAWBYBLK</a> : one or more text files, each containing consecutive segments of object code produced</li>
 <li><a href="#L058">RAWBYSEG</a> : one or more text files, each containing a single segment of object code produced</li>
 <li><a href="#L058">RAWFILE</a> : a single text file containing all the object code produced as hexadecimal character pairs</li>
 <li><a href="#L06F">RBIT08</a> : store signed relative 8-bit value into object code; <em>alias</em> RBYTE</li>
 <li><a href="#L06F">RBIT16</a> : store signed relative 16-bit value into object code; <em>alias</em> : RWORD</li>
 <li><a href="#L06F">RBIT24</a> : store signed relative 24-bit value into object code</li>
 <li><a href="#L06F">RBIT32</a> : store signed relative 32-bit value into object code; <em>alias</em> : RLONG</li>
 <li><a href="#L06F">RBIT08R</a> : store reversed signed relative 8-bit value into object code; <em>alias</em> : RREVBYTE</li>
 <li><a href="#L06F">RBIT16R</a> : store reversed signed relative 16-bit value into object code; <em>alias</em> : RREVWORD</li>
 <li><a href="#L06F">RBIT24R</a> : store reversed signed relative 24-bit value into object code</li>
 <li><a href="#L06F">RBIT32R</a> : store reversed signed relative 32-bit value into object code; <em>alias</em> : RREVLONG</li>
 <li><a href="#L060">READONCE</a> : prevent future inclusion of a file</li>
 <li><a href="#L016">RELEND</a> : mark a segment as relative end</li>
 <li><a href="#L014">RELORG</a> : mark a segment as relative start</li>
 <li><a href="#L084">REPEAT</a> : start a repeat definition</li>
 </ul>
<ul> <li><a href="#L070">SBIT08</a> : store signed 8-bit value into object code; <em>alias</em> SBYTE</li>
 <li><a href="#L070">SBIT16</a> : store signed 16-bit value into object code; <em>alias</em> : SWORD</li>
 <li><a href="#L070">SBIT24</a> : store signed 24-bit value into object code</li>
 <li><a href="#L070">SBIT32</a> : store signed 32-bit value into object code; <em>alias</em> : SLONG</li>
 <li><a href="#L070">SBIT08R</a> : store reversed signed 8-bit value into object code; <em>alias</em> : SREVBYTE</li>
 <li><a href="#L070">SBIT16R</a> : store reversed signed 16-bit value into object code; <em>alias</em> : SREVWORD</li>
 <li><a href="#L070">SBIT24R</a> : store reversed signed 24-bit value into object code</li>
 <li><a href="#L070">SBIT32R</a> : store reversed signed 32-bit value into object code; <em>alias</em> : SREVLONG</li>
 <li><a href="#L012">SEGMENT</a> : start a segment fragment</li>
 <li><a href="#L07D">SHOWTIMER</a> : write the named timer's value to <em>stdout</em> and error file</li>
 <li><a href="#L05A">SRECBYBLK</a> : one or more text files, each containing consecutive segments of object code produced; <em>alias</em> : SRECBYBLOCK</li>
 <li><a href="#L05A">SRECBYSEG</a> : one or more text files, each containing a single segment of object code produced</li>
 <li><a href="#L05A">SRECFILE</a> : a single text file containing all the object code produced</li>
 <li><a href="#L07B">STARTTIMER</a> : start a named internal clock running</li>
 <li><a href="#L07C">STOPTIMER</a> : stop a named internal clock running</li>
 <li><a href="#L073">STRING</a> : store character(s) into object code; <em>aliases</em> : STR, FCC</li>
 <li><a href="#L073">STRINGR</a> : store character(s) into object code in reverse order; <em>aliases</em> : REVSTR, REVFCC</li>
 </ul>
<ul> <li><a href="#L067">TITLE</a> : replace the default listing header with a custom header</li>
 </ul>
<ul> <li><a href="#L071">UBIT08</a> : store unsigned 8-bit value into object code; <em>alias</em> UBYTE</li>
 <li><a href="#L071">UBIT16</a> : store unsigned 16-bit value into object code; <em>alias</em> : UWORD</li>
 <li><a href="#L071">UBIT24</a> : store unsigned 24-bit value into object code</li>
 <li><a href="#L071">UBIT32</a> : store unsigned 32-bit value into object code; <em>alias</em> : ULONG</li>
 <li><a href="#L071">UBIT08R</a> : store reversed unsigned 8-bit value into object code; <em>alias</em> : UREVBYTE</li>
 <li><a href="#L071">UBIT16R</a> : store reversed unsigned 16-bit value into object code; <em>alias</em> : UREVWORD</li>
 <li><a href="#L071">UBIT24R</a> : store reversed unsigned 24-bit value into object code</li>
 <li><a href="#L071">UBIT32R</a> : store reversed unsigned 32-bit value into object code; <em>alias</em> : UREVLONG</li>
 <li><a href="#L083">UNDEF</a> : delete a macro definition</li>
 <li><a href="#L019">UNINITIALIZED</a> : explicitly flag a segment as containing no object code or data; <em>alias</em> : NODATA</li>
 <li><a href="#L011">USESEGMENTS</a> : explicitly flag that the source code describes a segmented program</li>
 </ul>
<ul> <li><a href="#L094">WARN</a> : programmer-triggered warning message</li>
 <li><a href="#L098">WARNOFF</a> : disable console display of warning messages; <em>alias</em> : NOWARN</li>
 <li><a href="#L098">WARNON</a> : enable console display of warning messages</li>
 <li><a href="#L086">WHILE</a> : start a while defintion</li>
 </ul>
<ul> <li><a href="#L077">XLATE</a> : alias Unicode character code values</li>
 </ul>
<hr>
<a id="L06A"></a>
<h4><b>CPU</b></h4>
<h4>Usage</h4>
<blockquote> <b>CPU</b>  <em>name</em><br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>name</em> is an <a href="#L009">opt_str</a></li>
 </ul>
<h4>Description</h4>
<p>Specifies the central processor to assemble code for.</p>
<p>At startup, HXA dynamically loads a Python module that can process one or more CPU instruction sets. However, by default it does not know which CPU to assemble code for.</p>
<p>A CPU the handler can process <em>must</em> be specified before the first instruction mnemonic or <a href="#L068">pseudo opcode</a> that changes the <a href="#L029">program counter</a> (in particular, <a href="#L06C">ABSORG</a>).</p>
<p><b>CPU</b>  can be used any number of times, but <em>name</em> must be the same each time.</p>
<h4>Examples</h4>
<p><a href="hxa_test.htm#L0B6">Set CPU</a></p>
<hr>
<a id="L06B"></a>
<h4>CPU Descriptor</h4>
<p>All variants of HXA require a CPU descriptor to produce object files. Descriptors tell the non-processor specific portions of HXA how to "understand" them. They tell HXA:</p>
<ul> <li>the width of the <a href="#L029">program counter</a> (8 to 32 bits)</li>
 <li>the native multi-octet orientation ( least- or most- significant octet first)</li>
 <li>the number of bits in a byte (8, 16 or 32 bits; the smallest addressable unit; optional, defaults to eight)</li>
 </ul>
<p>The width of the program counter sets the allowable address range, from zero to 2^width - 1. The multi-octet order determines how object code and data are written to files. The number of bits in a byte determines which <a href="#L06E">BIT--</a> pseudo ops (and their aliases) are available.</p>
<p>The general format of a descriptor is</p>
<ul> <li><b>T_PCWidth_ByteOrder</b>  <em>[ByteSize]</em></li>
 </ul>
<h4>Examples</h4>
<ul> <li><b>T_08_L08</b>  : 8-bit program counter, least significant octet first, 8-bit byte</li>
 <li><b>T_12_M</b>  :  12-bit program counter, most significant octet first, 8-bit byte</li>
 <li><b>T_16_L</b>  : 16-bit program counter, least significant octet first, 8-bit byte</li>
 <li><b>T_24_M16</b>  : 24-bit program counter, most significant octet first, 16-bit byte</li>
 <li><b>T_32_M32</b>  : 32-bit program counter, most significant octet first, 32-bit byte</li>
 </ul>
<p>Note that the imaginary T_XX "family" of processors used to test the generalized version of HXA are really all just CPU descriptors. While it has no specific CPU instruction set, by using a descriptor to describe everything else, it can successfully output all its test files.</p>
<p>This version can also use descriptors to implement real and imaginary instruction sets entirely with <a href="#L07F">macros</a>. These will be slower than the equivalents implemented as native code, but they will work identically.</p>
<hr>
<a id="L06C"></a>
<h4><b>ABSORG</b></h4>
<h4>Usage</h4>
<blockquote> [<em>label</em>] <b>ABSORG</b>  <em>address</em><br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>label</em> is an optional legal <a href="#L01D">label</a></li>
 <li><em>address</em> is a <a href="#L009">cpu_addr</a></li>
 </ul>
<h4>Aliases</h4>
<ul> <li>[<em>label</em>] <b>ORG</b>  <em>address</em></li>
 <li>[<em>label</em>] <b>&ast;=</b>  <em>address</em></li>
 <li>[<em>label</em>] <b>$=</b>  <em>address</em></li>
 </ul>
<h4>Description</h4>
<p>Assigns <em>address</em> to the <a href="#L029">program counter</a> and (if present) to <em>label</em>.</p>
<p>Since <b>ABSORG</b>  itself changes the program counter, it must come <em>after</em> a <a href="#L06A">CPU</a> has been specified but <em>before</em> any processor instruction or pseudo opcode that can change it.</p>
<p>In <a href="#L00F">monolithic</a> programs, there is only one program counter. <b>ABSORG</b> :</p>
<ul> <li>can be used to reset the program counter any number of times to any legal address value</li>
 </ul>
<p>In <a href="#L010">segmented</a> programs, each segment has its own program counter. <b>ABSORG</b> :</p>
<ul> <li>must be used before any code or data is stored in a segment or any fragment of it</li>
 <li>can be used any number of times in any segment fragment</li>
 <li>in any single segment must have the same <em>address</em> value each time, although only the first use actually sets the program counter</li>
 <li>can be used only within segment fragments, never outside them</li>
 <li>marks the entire segment as <em>absolute origin</em> if used within any fragment of that segment</li>
 </ul>
<p>Every segmented program must have at least one absolute segment. If the only absolute segment is absolute origin, it can be preceded only by <a href="#L016">relative end</a> segments and succeeded only by <a href="#L014">relative origin</a> ones.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0B7">Set Program Counter</a> (monolithic programs)</li>
 <li><a href="hxa_test.htm#L121">Basic Definition</a> (segmented programs)</li>
 </ul>
<hr>
<a id="L06D"></a>
<h4><b>END</b></h4>
<h4>Usage</h4>
<blockquote> <em>[label]</em> <b>END</b>  <em>[startaddr]</em><br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>label</em> is a optional legal <a href="#L01D">label</a> (<a href="#L00F">monolithic</a> programs only)</li>
 <li><em>startaddr</em> is an optional <a href="#L009">cpu_addr</a></li>
 </ul>
<h4>Description</h4>
<p>Terminates processing of the <a href="#L007">root file</a>.</p>
<p><b>END</b>  halts pass one of HXA and begins pass two. All text in the root file following the line it appears on is ignored.</p>
<p>The use of <b>END</b>  is optional. If it is not used, HXA will read all source text to the last line of the root file before beginning pass two.</p>
<p><b>END</b>  cannot be used except in the root file. If it used within an <a href="#L05E">INCLUDE</a> file, a warning will be issued. HXA will stop reading from it, and resume reading from the including file.</p>
<p><b>END</b>  cannot be used within <a href="#L08D">IF</a>, <a href="#L080">MACRO</a>, <a href="#L084">REPEAT</a> or <a href="#L086">WHILE</a> blocks. If it is, HXA will issue a fatal error due to stack corruption.</p>
<p>In source code organized as <a href="#L00F">monolithic</a>, <b>END</b>  can be labeled. If the current file is the root file, any <em>label</em> is assigned the current value of the <a href="#L029">program counter</a>. In files that are not the root file, any <em>label</em> is ignored.</p>
<p>In source code organized as <a href="#L010">segmented</a>, <b>END</b>  can only be used outside of any segment fragment. It cannot be used in any segment fragment, nor can it be labeled.</p>
<p><b>END</b>  can always have a <em>startaddr</em>. If present, it is assumed to represent a start address to be written to an <a href="#L0A7">Intel</a> or <a href="#L0A9">Motorola</a> hexadecimal output file. It is always evaluated and range-checked, whether or not it is actually ever written out.</p>
<h4>Examples:</h4>
<p><a href="hxa_test.htm#L0C3">Pass Termination</a></p>
<hr>
<a id="L06E"></a>
<h4>BIT--, BIT--R</h4>
<h4>Usage</h4>
<blockquote> <em>[label]</em> <b>BIT--</b>  num_expr <em>[[, num_expr]..]</em><br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>label</em> is an optional legal <a href="#L01D">label</a></li>
 <li><em>num_expr</em> is a signed <a href="#L009">numeric_expr</a> in the decimal range [-2^32, 2^32-1]</li>
 </ul>
<h4>Variants</h4>
<ul> <li>BIT08, BIT16, BIT24, BIT32</li>
 <li>BIT08R, BIT16R, BIT24R, BIT32R</li>
 </ul>
<h4>Aliases</h4>
<ul> <li><em>[label]</em> <b>BYTE</b>  num_expr <em>[[, num_expr]..]</em></li>
 <li><em>[label]</em> <b>FCB</b>  num_expr <em>[[, num_expr]..]</em></li>
 <li><em>[label]</em> <b>WORD</b>  num_expr <em>[[, num_expr]..]</em></li>
 <li><em>[label]</em> <b>FDB</b>  num_expr <em>[[, num_expr]..]</em></li>
 <li><em>[label]</em> <b>LONG</b>  num_expr <em>[[, num_expr]..]</em></li>
 <li><em>[label]</em> <b>REVBYTE</b>  num_expr <em>[[, num_expr]..]</em></li>
 <li><em>[label]</em> <b>REVFCB</b>  num_expr <em>[[, num_expr]..]</em></li>
 <li><em>[label]</em> <b>REVWORD</b>  num_expr <em>[[, num_expr]..]</em></li>
 <li><em>[label]</em> <b>REVFDB</b>  num_expr <em>[[, num_expr]..]</em></li>
 <li><em>[label]</em> <b>REVLONG</b>  num_expr <em>[[, num_expr]..]</em></li>
 </ul>
<h4>Description</h4>
<p>The <b>BIT--</b>  and <b>BIT--R</b>  pseudo opcodes store all or part of <em>num_expr</em> into the object code. If a <em>label</em> is present, it is given the current value of the <a href="#L029">program counter</a>.</p>
<ul> <li><b>BIT08-</b>  : store the least significant 8 bits</li>
 <li><b>BIT16-</b>  : store the least significant 16 bits</li>
 <li><b>BIT24-</b>  : store the least significant 24 bits</li>
 <li><b>BIT32-</b>  : store the entire 32 bits</li>
 </ul>
<p>Bits not stored are ignored, so <em>num_expr</em> can have a value larger than the storage space allotted will hold.</p>
<p>By default, storage of multi-byte values is in native <a href="#L06A">CPU</a> order, either least significant byte (LSB) first or most significant byte (MSB) first. The <b>--R</b>  suffix reverses the native order of stored bytes, so <b>BIT32R</b>  used on an LSB first CPU will store the MSB first in the object code.</p>
<p>The <b>BIT--</b>  and <b>BIT--R</b>  pseudo opcodes require at least one numeric expression argument. Each separate expression is treated a separate 32-bit value to be stored according to the specific rules of the pseudo opcode.</p>
<p>Note that some assemblers allow mixed string and numeric expressions to follow <em>BYTE</em> (or its equivalent). HXA does not permit this for <b>BIT--</b>  or <b>BIT--R</b> , but does for <a href="#L073">STRING</a> and <a href="#L073">STRINGR</a>.</p>
<p>The available <b>BIT--</b>  and <b>BIT--R</b>  pseudo ops are affected by <a href="#L0AD">non-standard byte</a> sizes.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0CC">Numeric Data Definition</a></li>
 <li><a href="hxa_test.htm#L184">Numbers and BIT--</a></li>
 </ul>
<hr>
<a id="L06F"></a>
<h4>RBIT--, RBIT--R</h4>
<h4>Usage</h4>
<blockquote> <em>[label]</em> <b>RBIT--</b>  num_expr <em>[[, num_expr]..]</em><br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>label</em> is an optional legal <a href="#L01D">label</a></li>
 <li><em>num_expr</em> is a signed <a href="#L009">numeric_expr</a></li>
 </ul>
<h4>Variants</h4>
<ul> <li>RBIT08, RBIT16, RBIT24, RBIT32</li>
 <li>RBIT08R, RBIT16R, RBIT24R, RBIT32R</li>
 </ul>
<h4>Aliases</h4>
<ul> <li><em>[label]</em> <b>RBYTE</b>  num_expr <em>[[, num_expr]..]</em></li>
 <li><em>[label]</em> <b>RWORD</b>  num_expr <em>[[, num_expr]..]</em></li>
 <li><em>[label]</em> <b>RLONG</b>  num_expr <em>[[, num_expr]..]</em></li>
 <li><em>[label]</em> <b>RREVBYTE</b>  num_expr <em>[[, num_expr]..]</em></li>
 <li><em>[label]</em> <b>RREVWORD</b>  num_expr <em>[[, num_expr]..]</em></li>
 <li><em>[label]</em> <b>RREVLONG</b>  num_expr <em>[[, num_expr]..]</em></li>
 </ul>
<h4>Description</h4>
<p>The <b>RBIT--</b>  and <b>RBIT--R</b>  pseudo opcodes store <em>num_expr</em> as a <em>signed offset</em> relative to the <a href="#L029">program counter</a> into the object code.</p>
<ul> <li><b>RBIT08-</b>  : store the least significant 8 bits; must be in the decimal range [-2^7, 2^7-1]</li>
 <li><b>RBIT16-</b>  : store the least significant 16 bits; must be in the decimal range [-2^15, 2^15-1]</li>
 <li><b>RBIT24-</b>  : store the least significant 24 bits; must be in the decimal range [-2^23, 2^23-1]</li>
 <li><b>RBIT32-</b>  : store the entire 32 bits; must be in the decimal range [-2^31, 2^31-1]</li>
 </ul>
<p>Whatever the storage size, <em>num_expr</em> is checked against the allowable range for that size. If it does not fit, HXA reports an error.</p>
<p>The <em>signed offset</em> value is calculated as:</p>
<blockquote> signed_offset = <em>num_expr - (program_counter + data_size )</em><br> </blockquote>
<p>where:</p>
<ul> <li><em>Num_expr</em> is a signed integer value</li>
 <li><em>Program_counter</em> is the value of the <a href="#L029">program counter</a> at the first byte of the stored data</li>
 <li><em>Data_size</em> is the number of octets of data stored (the same as the number of bits divided by eight)</li>
 </ul>
<p>In other words, the value of <em>program counter + data_size</em> (ie., the location immediately following the stored data) is subtracted from <em>num_expr</em> to create the actual value stored. If the value is outside the legal range of the <a href="#L06A">CPU</a>, HXA reports an error.</p>
<p>By default storage of multi-byte values is in native CPU order, either least significant byte (LSB) first or most significant byte (MSB) first. The <b>--R</b>  suffix reverses the native order of stored bytes, so <b>RBIT32R</b>  used on an LSB first CPU will store the MSB first in the object code.</p>
<p>The <b>RBIT--</b>  and <b>RBIT--R</b>  pseudo opcodes require at least one numeric expression argument. Each separate expression is treated a separate value to be stored according to the specific rules of the pseudo opcode.</p>
<p>Note that some assemblers allow mixed string and numeric expressions to follow <em>BYTE</em> (or equivalent) pseudo opcodes. HXA does not permit this for <b>RBIT--</b>  or <b>RBIT--R</b> , but does for <a href="#L073">STRING</a> and <a href="#L073">STRINGR</a>.</p>
<p>The available <b>RBIT--</b>  and <b>RBIT--R</b>  pseudo ops are affected by <a href="#L0AD">non-standard byte</a> sizes.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0D9">Program Counter Relative Numeric Data Definition</a></li>
 </ul>
<hr>
<a id="L070"></a>
<h4>SBIT--, SBIT--R</h4>
<h4>Usage</h4>
<blockquote> <em>[label]</em> <b>SBIT--</b>  num_expr <em>[[, num_expr]..]</em><br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>label</em> is an optional legal <a href="#L01D">label</a></li>
 <li><em>num_expr</em> is a signed <a href="#L009">numeric_expr</a></li>
 </ul>
<h4>Variants</h4>
<ul> <li>SBIT08, SBIT16, SBIT24, SBIT32</li>
 <li>SBIT08R, SBIT16R, SBIT24R, SBIT32R</li>
 </ul>
<h4>Aliases</h4>
<ul> <li><em>[label]</em> <b>SBYTE</b>  num_expr <em>[[, num_expr]..]</em></li>
 <li><em>[label]</em> <b>SWORD</b>  num_expr <em>[[, num_expr]..]</em></li>
 <li><em>[label]</em> <b>SLONG</b>  num_expr <em>[[, num_expr]..]</em></li>
 <li><em>[label]</em> <b>SREVBYTE</b>  num_expr <em>[[, num_expr]..]</em></li>
 <li><em>[label]</em> <b>SREVWORD</b>  num_expr <em>[[, num_expr]..]</em></li>
 <li><em>[label]</em> <b>SREVLONG</b>  num_expr <em>[[, num_expr]..]</em></li>
 </ul>
<h4>Description</h4>
<p>The <b>SBIT--</b>  and <b>SBIT--R</b>  pseudo opcodes store <em>num_expr</em> into the object code.</p>
<ul> <li><b>SBIT08-</b>  : store the least significant 8 bits; must be in the decimal range [-2^7, 2^7-1]</li>
 <li><b>SBIT16-</b>  : store the least significant 16 bits; must be in the decimal range [-2^15, 2^15-1]</li>
 <li><b>SBIT24-</b>  : store the least significant 24 bits; must be in the decimal range [-2^23, 2^23-1]</li>
 <li><b>SBIT32-</b>  : store the entire 32 bits; must be in the decimal range [-2^31, 2^31-1]</li>
 </ul>
<p>Whatever the storage size, <em>num_expr</em> is checked against the allowable range for that size. If it does not fit, HXA reports an error.</p>
<p>By default storage of multi-byte values is in native <a href="#L06A">CPU</a> order, either least significant byte (LSB) first or most significant byte (MSB) first. The <b>--R</b>  suffix reverses the native order of stored bytes, so <b>SBIT32R</b>  used on an LSB first CPU will store the MSB first in the object code.</p>
<p>The <b>SBIT--</b>  and <b>SBIT--R</b>  pseudo opcodes require at least one numeric expression argument. Each separate expression is treated a separate value to be stored according to the specific rules of the pseudo opcode.</p>
<p>Note that some assemblers allow mixed string and numeric expressions to follow <em>BYTE</em> (or equivalent) pseudo opcodes. HXA does not permit this for <b>SBIT--</b>  or <b>SBIT--R</b> , but does for <a href="#L073">STRING</a> and <a href="#L073">STRINGR</a>.</p>
<p>The available <b>SBIT--</b>  and <b>SBIT--R</b>  pseudo ops are affected by <a href="#L0AD">non-standard byte</a> sizes.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0CD">Ranged Numeric Data Definition</a></li>
 </ul>
<hr>
<a id="L071"></a>
<h4>UBIT--, UBIT--R</h4>
<h4>Usage</h4>
<blockquote> <em>[label]</em> <b>UBIT--</b>  num_expr <em>[[, num_expr]..]</em><br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>label</em> is an optional legal <a href="#L01D">label</a></li>
 <li><em>num_expr</em> is a unsigned <a href="#L009">numeric_expr</a></li>
 </ul>
<h4>Variants</h4>
<ul> <li>UBIT08, UBIT16, UBIT24, UBIT32</li>
 <li>UBIT08R, UBIT16R, UBIT24R, UBIT32R</li>
 </ul>
<h4>Aliases</h4>
<ul> <li><em>[label]</em> <b>UBYTE</b>  num_expr <em>[[, num_expr]..]</em></li>
 <li><em>[label]</em> <b>UWORD</b>  num_expr <em>[[, num_expr]..]</em></li>
 <li><em>[label]</em> <b>ULONG</b>  num_expr <em>[[, num_expr]..]</em></li>
 <li><em>[label]</em> <b>UREVBYTE</b>  num_expr <em>[[, num_expr]..]</em></li>
 <li><em>[label]</em> <b>UREVWORD</b>  num_expr <em>[[, num_expr]..]</em></li>
 <li><em>[label]</em> <b>UREVLONG</b>  num_expr <em>[[, num_expr]..]</em></li>
 </ul>
<h4>Description</h4>
<p>The <b>UBIT--</b>  and <b>UBIT--R</b>  pseudo opcodes store <em>num_expr</em> into the object code.</p>
<ul> <li><b>UBIT08-</b>  : store the least significant 8 bits; must be in the decimal range [0, 2^8-1]</li>
 <li><b>UBIT16-</b>  : store the least significant 16 bits; must be in the decimal range [0, 2^16-1]</li>
 <li><b>UBIT24-</b>  : store the least significant 24 bits; must be in the decimal range  [0, 2^24-1]</li>
 <li><b>UBIT32-</b>  : store the entire 32 bits; must be in the decimal range [0, 2^32-1]</li>
 </ul>
<p>Whatever the storage size, <em>num_expr</em> is checked against the allowable range for that size. If it does not fit, HXA reports an error.</p>
<p>By default storage of multi-byte values is in native <a href="#L06A">CPU</a> order, either least significant byte (LSB) first or most significant byte (MSB) first. The <b>--R</b>  suffix reverses the native order of stored bytes, so <b>UBIT32R</b>  used on an LSB first CPU will store the MSB first in the object code.</p>
<p>The <b>UBIT--</b>  and <b>UBIT--R</b>  pseudo opcodes require at least one numeric expression argument. Each separate expression is treated a separate value to be stored according to the specific rules of the pseudo opcode.</p>
<p>Note that some assemblers allow mixed string and numeric expressions to follow <em>BYTE</em> (or equivalent) pseudo opcodes. HXA does not permit this for <b>UBIT--</b>  or <b>UBIT--R</b> , but does for <a href="#L073">STRING</a> and <a href="#L073">STRINGR</a>.</p>
<p>The available <b>UBIT--</b>  and <b>UBIT--R</b>  pseudo ops are affected by <a href="#L0AD">non-standard byte</a> sizes.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0CD">Ranged Numeric Data Definition</a></li>
 </ul>
<hr>
<a id="L072"></a>
<h4><b>HEX</b></h4>
<h4>Usage</h4>
<blockquote> <em>[label] </em><b>HEX</b>  value <em>[[, value]..]</em><br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>label</em> is an optional legal <a href="#L01D">label</a></li>
 <li><em>value</em> is a <a href="#L009">hex_str</a></li>
 </ul>
<h4>Description</h4>
<p>Stores octets specified by <em>value</em> into the object code.</p>
<p><em>Value</em> must have an even number of hexadecimal characters. Each pair of characters specifies one octet of object code. Octets are stored in the same left-to-right order as they appear in <em>value</em>.</p>
<p><em>Value</em> may be hexadecimal numbers or strings of hexadecimal characters.</p>
<p>There is no limit on the length of a single <em>value</em>. For clarity, more than one <em>value</em> can be specified if separated by commas (',' ASCII 0x2C). Each <em>value</em> will be stored as a separate data item.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L185">HEX</a></li>
 </ul>
<hr>
<a id="L073"></a>
<h4>STRING, STRINGR</h4>
<h4>Usage</h4>
<blockquote> <em>[label]</em> <b>STRING</b>  string$ <em>[[,string$]..]</em><br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>label</em> is an optional legal <a href="#L01D">label</a></li>
 <li><em>string$</em> is a <a href="#L009">const_expr$</a> OR a <a href="#L009">const_expr</a> in the legal Unicode range [0x000000, 0x10FFFE]</li>
 </ul>
<h4>Variants</h4>
<ul> <li>STRING, STRINGR</li>
 </ul>
<h4>Aliases</h4>
<ul> <li><em>[label]</em> <b>STR</b>  string$ <em>[[,string$]..]</em></li>
 <li><em>[label]</em> <b>FCC</b>  string$ <em>[[,string$]..]</em></li>
 <li><em>[label]</em> <b>REVSTR</b>  string$ <em>[[,string$]..]</em></li>
 <li><em>[label]</em> <b>REVFCC</b>  string$ <em>[[,string$]..]</em></li>
 </ul>
<h4>Description</h4>
<p>Store a string of one or more characters as Unicode code points into the object code.</p>
<p><b>STRING</b>  stores characters in the order they are specified, <b>STRINGR</b>  in reverse order. Storage is consecutive starting at the current <a href="#L029">program counter</a> location.</p>
<p>Characters are stored according to the current <a href="#L09D">objstr=</a> assumption. The default assumption is <em>objstr:utf-8</em>. Note that a character may occupy more than one 8-bit octet.</p>
<ul> <li>objstr:ascii : one octet in the range [0x20, 0x7e]</li>
 <li>objstr:latin-1 : one octet in the range [0x20, 0x7e] or [0xA0, 0xFF]</li>
 <li>objstr:utf-8 : one octet in the range [0x20, 0x7e], two octets in the range [0xA0, 0xFF], more octets for all higher code points</li>
 <li>objstr:utf-16 : two octets for every code point, native orientation</li>
 <li>objstr:utf-16be: two octets for every code point, MSB first</li>
 <li>objstr:utf-16le: two octets for every code point. LSB first</li>
 <li>objstr:utf-32 : four octets for every code point, native orientation</li>
 <li>objstr:utf-32be: four octets for every code point, MSB first</li>
 <li>objstr:utf-32le: four octets for every code point. LSB first</li>
 </ul>
<p>If a character's codepoint is not printable in the current assumption, it will be rendered as a hexadecimal <a href="#L00C">escape sequence</a> with a leading '\x' (ASCII 0x5778) prefix.</p>
<p>For <em>objstr:utf-16</em> and <em>objstr:utf-32</em>, printable codepoints will match the byte orientation of the <a href="#L06A">CPU</a>. If the CPU is least-significant byte first, then the output will be <em>objstr:utf-16le</em>, otherwise it will be <em>objstr:utf-16be</em>. Likewise for <em>objstr:utf-32</em>.</p>
<p>Each character is also mapped through the current <a href="#L077">character set translation</a> before being stored.</p>
<p>At least one argument is required. It must be a constant expression with no forward reference, but can be either string or numeric. Numeric arguments are treated as Unicode code points.</p>
<p>If more than one argument is provided, all are concatenated together as one string before storage.</p>
<p>If <b>STRING-</b>  is the null string, HXA issues a warning and no object code is created.</p>
<p>Note that some assemblers allow mixed string and numeric expressions to follow <em>BYTE</em> (or equivalent) pseudo opcodes. HXA does not permit this for <b>BIT--</b>  , but does for <b>STRING-</b> .</p>
<p>Character values in strings are affected by <a href="#L0AD">non-standard byte</a> sizes.</p>
<p>Note that the <b>FCC</b>  and <b>REVFCC</b>  aliases store their output using the current <a href="#L09D">objstr=</a> assumption. They do not inherently limit themselves to ASCII only.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0CF">String Literals</a></li>
 </ul>
<hr>
<a id="L074"></a>
<h4>FLOAT</h4>
<h4>Usage</h4>
<blockquote> <em>[label]</em> <b>FLOAT</b>  decimal <em>[[,decimal]..]</em><br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>label</em> is an optional legal <a href="#L01D">label</a></li>
 <li><em>decimal</em> is an ASCII numeric literal</li>
 </ul>
<h4>Description</h4>
<p>Store one or more floating point values into the object code.</p>
<p>Floating point values are always constants. They may be specified in scientific notation.</p>
<p>Floating point values are never recognized as part of any expression. They are meant only to be a convenient and readable method of specifing the data they represent.</p>
<p>Floating point values are stored according to the current <a href="#L09D">float=</a> assumption. The default assumption is <em>float:ieee-double-be</em>. Each float written to output occupies a fixed amount of storage, ranging from two to eight octets (16 to 64 bits).</p>
<ul> <li>float:ieee-double, ieee-double-be: eight octets (64 bits), sign/exponent/mantissa, MSB to LSB order</li>
 <li>float:ieee-double-le: eight octets (64 bits), mantissa/exponent/sign order, LSB to MSB order</li>
 <li>float:ieee-single, ieee-single-be: four octets (32 bits), sign/exponent/mantissa, MSB to LSB order</li>
 <li>float:ieee-single-le: four octets (32 bits), mantissa/exponent/sign order LSB to MSB order</li>
 <li>float:ieee-half, ieee-half-be: two octets (16 bits), sign/exponent/mantissa MSB/LSB, order</li>
 <li>float:ieee-half-le: two octets (16 bits), mantissa/exponent/sign LSB/MSB order</li>
 <li>float:esm4, esm4-be: five octets (40 bits), exponent/sign/mantissa, MSB to LSB order</li>
 <li>float:esm4-le: five octets (40 bits), mantissa/sign/exponent order, LSB to MSB order</li>
 <li>float:cbm, float:apple2, float:bbc and float:bbc-6502 all alias to float:esm4-be</li>
 <li>float:bbc-z80 aliases to float:esm4-le</li>
 </ul>
<p>HXA converts each input decimal to a floating point value in IEEE-754 double precision form. Floating point values may then be output in any of the supported formats. If the input decimal has a greater precision or range than the output format supports, a silent loss of precision or an out of range error may occur.</p>
<p>The 'ieee-' formats all conform to the IEEE-754 standard, except subnormal values and those which are not decimal literals are <em>not</em> supported. The 'esm4-' formats are made-up names that attempt to cover most implementations of a format commonly used before the IEEE-754 standard existed.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L186">FLOAT</a></li>
 </ul>
<hr>
<a id="L075"></a>
<h4><b>FILL</b></h4>
<h4>Usage</h4>
<blockquote> <em>[label]</em> <b>FILL</b>  size <em>[, value ]</em><br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>label</em> is an optional legal <a href="#L01D">label</a></li>
 <li><em>size</em> is a <a href="#L009">positive_expr</a></li>
 <li><em>value</em> is an optional <a href="#L009">hex_str</a></li>
 </ul>
<h4>Description</h4>
<p>The <b>FILL</b>  pseudo opcode inserts <em>size</em> bytes into the object code.</p>
<p>If the value of <em>size</em> is zero, <b>FILL</b>  is silently ignored. If it forces the <a href="#L029">program counter</a> outside the valid address range of the current <a href="#L06A">CPU</a>, a fatal error occurs.</p>
<p>By default, <b>FILL</b>  inserts zero octets (0x00) into the object code.</p>
<p>If a <em>value</em> is supplied, its octets are used instead. They are taken from <em>value</em> in the same left-to-right order they appear, regardless of <a href="#L06A">CPU</a> byte orientation. <b>FILL</b>  uses only as many octets of <em>value</em> as needed. If more are needed than <em>value</em> supplies, it is duplicated as often as required.</p>
<p><b>FILL</b>  may be used in both <a href="#L00F">monolithic</a> and <a href="#L010">segmented</a> programs wherever the program counter is valid. Filling occurs immediately. Filling appears in the object code starting at the current value of the program counter.</p>
<p>A <a href="#L012">SEGMENT</a> cannot be both filled and uninitialized.</p>
<p><b>FILL</b>  is generally not affected by <a href="#L0AD">non-standard byte</a> sizes. The number of bytes to fill automatically takes into account the byte size, so the description remains valid.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L146">Fill Block With Constant Data</a></li>
 </ul>
<hr>
<a id="L076"></a>
<h4><b>DS</b></h4>
<h4>Usage</h4>
<blockquote> <em>[label]</em> <b>DS</b>  size<br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>label</em> is an optional legal <a href="#L01D">label</a></li>
 <li><em>size</em> is a <a href="#L009">positive_expr</a></li>
 </ul>
<h4>Alias</h4>
<ul> <li><em>[label]</em> <b>RES</b>  size</li>
 <li><em>[label]</em> <b>RESERVE</b>  size</li>
 <li><em>[label]</em> <b>RMB</b>  size</li>
 </ul>
<h4>Description</h4>
<p>The <b>DS</b>  pseudo opcode first assigns the current value of the <a href="#L029">program counter</a> to <em>label</em> (if present). Then it adds <em>size</em> bytes to the program counter. No object code is generated for any address between the original and new values of the program counter.</p>
<p>If the value of <em>size</em> is zero, <b>DS</b>  is silently ignored. If it forces the program counter outside the valid address range of the current <a href="#L06A">CPU</a>, a fatal error occurs.</p>
<p>In <a href="#L010">segmented</a> programs, <b>DS</b>  implicitly flags its segment as <a href="#L019">UNINITIALIZED</a>. <b>DS</b>  cannot be used in segments which already contain data.</p>
<p><b>DS</b>  is especially convenient for allocating variables which are left uninitialized at assembly time.</p>
<p><b>DS</b>  is generally not affected by <a href="#L0AD">non-standard byte</a> sizes. The number of bytes to skip automatically takes into account the byte size, so the description remains valid.</p>
<p>It is not always apparent that even a <a href="#L00F">monolithic</a> HXA program is segmented. This is by design. The mechanics of this are normally transparent to the programmer and do not have to be explicitly managed or cared about.</p>
<p>However, in both monolithic and segmented programs there is a maximum number of segments that can be created before a fatal error occurs. If need be, this limit can be reset using the <a href="#L0A4">MAXSEG</a> pseudo opcode.</p>
<p>In monolithic programs, a new segment is created for every transition from a data area to an uninitialized one, or vice-versa, It may be helpful to group all uses of <b>DS</b>  together in a consecutive series to prevent excessive segmentation in the first place.</p>
<h4>Examples</h4>
<blockquote> <a href="hxa_test.htm#L145">Define Uninitialized Storage</a><br> </blockquote>
<hr>
<a id="L077"></a>
<h4><b>XLATE</b></h4>
<h4>Usage</h4>
<blockquote> <b>xlate</b>  char(s)=val(s) <em>[[char(s)=val(s)]..]</em><br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>char</em> is a <a href="#L009">const_expr</a> in the range of a legal Unicode value, [0x000000, 0x10FFFE]</li>
 <li><em>val</em> is a <a href="#L009">const_expr</a> in the range of a legal Unicode value, [0x000000, 0x10FFFE]</li>
 </ul>
<h4>Description</h4>
<p>Creates a character set translation by mapping <em>val</em> onto <em>char</em> using the <a href="#L00B">equality idiom</a>. In essence, Unicode <em>char</em> values are aliased to Unicode <em>val</em> values.</p>
<p>Character codes can be mapped or re-mapped at any time. There is no prohibition on mapping a character code to itself.</p>
<p>Translation has no effect before output to object files. When <a href="#L073">STRING</a> and <a href="#L073">STRINGR</a> are output, any <em>char</em> value is translated to <em>val</em> in the final output object code.</p>
<p>The <b>XLATE</b>  pseudo opcode only affects string output. If the mapped value of a single character is required instead, it can be obtained using the <a href="#L051">XLATE()</a> function.</p>
<p>There are several forms of both <em>char</em> and <em>val</em>, depending on what needs to be accomplished:</p>
<ul> <li><b>XLATE</b>  <em>code-val</em> : maps <em>val</em> onto <em>char</em></li>
 <li>both <em>char</em> and <em>val</em> may be either single printable Unicode characters or <a href="#L00C">escape sequences</a>.</li>
 </ul>
<ul> <li><b>XLATE</b>  <em>begcode-endcode=val</em> : maps one <em>val</em> onto every character in the range <em>[begcode, endcode]</em></li>
 <li>code ranges are expressed with a dash (-, ASCII 0x2D) between two Unicode character codes</li>
 <li><em>begcode</em> must less or equal to <em>endcode</em> for any mapping to happen</li>
 </ul>
<ul> <li><b>XLATE</b>  <em>begcode-endcode=begval-endval</em> : map the range <em>begval-endval</em> onto <em>begcode-endcode</em></li>
 <li>if the <em>begcode-endcode</em> range is smaller than <em>begval-endval</em>, mapping stops when <em>endcode</em> has been mapped</li>
 <li>if the <em>begcode-endcode</em> range is larger than <em>begval-endval</em>, <em>endval</em> is repeated until <em>endcode</em> has been mapped</li>
 </ul>
<ul> <li><b>XLATE</b>  <em>code=begval-endval</em> : map <em>begval</em> onto <em>code</em></li>
 <li>HXA stops after the first mapping. Legal but equivalent to <em>code=val</em></li>
 </ul>
<p>The original intent  to allow the use of the ASCII character set in programs destined for non-ASCII environments.</p>
<hr>
<a id="L078"></a>
<h4>EQU</h4>
<h4>Usage</h4>
<blockquote> <em>label</em> <b>EQU</b>  <em>expr</em><br> </blockquote>
<blockquote> <em>label$</em> <b>EQU</b>  <em>expr$</em><br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>label</em> is any legal numeric <a href="#L01D">label</a></li>
 <li><em>expr</em> is a <a href="#L009">const_expr</a></li>
 </ul>
<ul> <li><em>label$</em> is any legal string label</li>
 <li><em>expr$</em> is a <a href="#L009">const_expr$</a></li>
 </ul>
<h4>Aliases</h4>
<ul> <li><em>label</em> <b>=</b>  <em>expr</em></li>
 <li><em>label$</em> <b>=</b>  <em>expr$</em></li>
 </ul>
<h4>Description</h4>
<p>Examines the type of the label and evaluates a constant expression matching that type. The result is assigned to the label.</p>
<ul> <li><a href="#L020">global</a> labels can be assigned the same value any number of times</li>
 <li><a href="#L022">local</a> labels can be assigned the same value in the same <a href="#L00D">scope</a> any number of times</li>
 <li><a href="#L023">variable</a> labels can be assigned any value any number of times</li>
 </ul>
<p><a href="#L02E">Regular expression</a> literals can be assigned to string labels and later used in pattern matching expressions.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0E2">Assign Label Value</a></li>
 </ul>
<hr>
<a id="L079"></a>
<h4>PLUSEQU</h4>
<h4>Usage</h4>
<blockquote> l<em>abel</em> <b>PLUSEQU</b>  <em>expr</em><br> </blockquote>
<blockquote> <em>label$</em> <b>PLUSEQU</b>  <em>expr$</em><br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>label</em> is a <a href="#L023">variable</a> numeric label</li>
 <li><em>expr</em> is a <a href="#L009">const_expr</a></li>
 </ul>
<ul> <li><em>label$</em> is a <em>variable</em> string label</li>
 <li><em>expr$</em> is a <a href="#L009">const_expr$</a></li>
 </ul>
<h4>Aliases</h4>
<ul> <li><em>label</em> <b>+=</b>  <em>expr</em></li>
 <li><em>label$</em> <b>+=</b>  <em>expr$</em></li>
 </ul>
<h4>Description</h4>
<p>Examines the type of the label and evaluates a constant expression matching that type. The result is added to the variable label's existing value and then re-assigned to the same label.</p>
<p>Variable labels can be assigned any value any number of times.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0E2">Assign Label Value</a></li>
 </ul>
<hr>
<a id="L07A"></a>
<h4>MINUSEQU</h4>
<h4>Usage</h4>
<ul> <li><em>label</em> <b>MINUSEQU</b>  <em>expr</em></li>
 </ul>
<h4>Parameters</h4>
<ul> <li><em>label</em> is a <a href="#L023">variable</a> numeric label</li>
 <li><em>expr</em> is a <a href="#L009">const_expr</a></li>
 </ul>
<h4>Alias</h4>
<ul> <li><em>label</em> <b>-=</b>  <em>expr</em></li>
 </ul>
<h4>Description</h4>
<p>Subtracts <em>expr</em> from <em>label</em>, then re-assigns that value to <em>label</em>.</p>
<p>Unlike the <a href="#L078">EQU</a> and <a href="#L079">PLUSEQU</a> pseudo ops, <b>MINUSEQ</b>  only works with numeric variable labels.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0E2">Assign Label Value</a></li>
 </ul>
<hr>
<a id="L07B"></a>
<h4><b>STARTTIMER</b></h4>
<h4>Usage</h4>
<blockquote> <b>STARTTIMER</b>  clock$<br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>clock$</em> is a <a href="#L009">global_name</a></li>
 </ul>
<h4>Description</h4>
<p>Starts <em>clock$</em> running.</p>
<p><em>Clock$</em> must be a name not previously used by <b>STARTTIMER</b> . <b>STARTTIMER</b>  can be used only once for any <em>clock$</em> name.</p>
<p>The name must be unique among timers. No two timers can have the same name.</p>
<p><b>STARTTIMER</b>  allows user-access to the same functions HXA uses to measure its own pass times. It can be used to measure the time performance of alternative program constructs.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L183">Timers</a></li>
 </ul>
<hr>
<a id="L07C"></a>
<h4><b>STOPTIMER</b></h4>
<h4>Usage</h4>
<ul> <li><b>STOPTIMER</b>  clock$</li>
 </ul>
<h4>Parameter</h4>
<ul> <li><em>clock$</em> is a <a href="#L009">global_name</a></li>
 </ul>
<h4>Description</h4>
<p>Stops <em>clock$</em> running.</p>
<p><em>Clock$</em> must be a name previously used by <a href="#L07B">STARTTIMER</a>. <b>STOPTIMER</b>  can only be used once for any <em>clock$</em> name.</p>
<p><b>STOPTIMER</b>  allows user-access to the same functions HXA uses to measure its own pass times. It can be used to measure the time performance of alternative program constructs.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L183">Timers</a></li>
 </ul>
<hr>
<a id="L07D"></a>
<h4><b>SHOWTIMER</b></h4>
<h4>Usage</h4>
<blockquote> <b>SHOWTIMER</b>  clock$<br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>clock$</em> is a <a href="#L009">global_name</a></li>
 </ul>
<h4>Description</h4>
<p><b>SHOWTIMER</b>  writes a time value in hours, minutes, seconds and milliseconds (HR:MN:SC:mSC) form to <em>stdout</em> and any <a href="#L055">error file</a>.</p>
<p><em>Clock$</em> must be a name previously used by <a href="#L07B">STARTTIMER</a>. <b>SHOWTIMER</b>  can be used any number of times with any <em>clock$</em> name</p>
<p>If <em>clock$</em> has been stopped by <b>STOPTIMER</b> , <b>SHOWTIMER</b>  displays the difference between <b>STOPTIMER</b>  and <b>STARTTIMER</b> . If not, it shows the difference between the current system time and <b>STARTTIMER</b> .</p>
<p>The time reported is only as accurate as the system timer.</p>
<p><b>SHOWTIMER</b>  allows user-access to the same functions HXA uses to measure its own pass times. It can be used to measure the time performance of alternative program constructs.</p>
<h4>Examples</h4>
<ul> <li>01:23:45:0067</li>
 <li><a href="hxa_test.htm#L183">Timers</a></li>
 </ul>
<hr>
<a id="L07E"></a>
<h4><b>PUSHS</b></h4>
<h4>Usage</h4>
<blockquote> <b>PUSHS</b>  string$ <em>[[, string$]..]</em><br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>string$</em> is a <a href="#L009">const_expr$</a></li>
 </ul>
<h4>Description</h4>
<p>Place a string on top of HXA's string stack, a Last In, First Out (LIFO) structure.</p>
<p>The string stack is empty when HXA begins the first pass. Each string pushed must be retrieved before the first pass ends, so the stack is again empty.</p>
<p>Each <em>string$</em> may be either string or numeric before evaluation. If any result is numeric, it is converted to a one-character Unicode string by the equivalent of <a href="#L031">CHR$()</a>.</p>
<p>If more than one <em>string$</em> is present, they are all concatenated together before being pushed.</p>
<p>Null strings are legal but cause a warning.</p>
<p><b>PUSHS</b>  is the complement of the <a href="#L041">POP$()</a> function.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L189">User Stack</a></li>
 </ul>
<a id="L07F"></a><h3>Macros</h3>
<a id="L080"></a>
<h4><b>MACRO</b></h4>
<h4>Usage</h4>
<blockquote> name <b>MACRO</b><br> </blockquote>
<blockquote> <b>MACRO</b>  name$<br> </blockquote>
<h4>Aliases</h4>
<ul> <li>name <b>MAC</b></li>
 <li><b>MAC</b>  name$</li>
 </ul>
<h4>Parameters</h4>
<ul> <li><em>name</em> is a <a href="#L01F">numeric global</a> name</li>
 <li><em>name$</em> is a <a href="#L009">global_name</a></li>
 </ul>
<h4>Description</h4>
<p>Marks the start of a macro <em>definition</em>.</p>
<p>A <b>macro</b>  is a <em>named</em> group of zero or more source code lines delimited by a matched pair of <b>MACRO</b> ..<a href="#L081">ENDMACRO</a> pseudo opcodes. The grouped source lines are called the <em>body</em> of the macro.</p>
<p>A <b>MACRO..ENDMACRO</b>  pair defines a macro. Once a macro has been defined, use of its name in the <a href="#L025">opcode field</a> of a source code line <em>invokes</em> it, causing its <em>expansion</em>. The effect is to insert the body of the macro into the source code at that point. From HXA's the point of view, it is as if the lines of the body had always been there.</p>
<p>The first Usage form is the most common, but <em>name</em> must have the form of a numeric global label. In the second Usage form, <em>name$</em> can be a string expression.</p>
<p>Either way, macro names must be unique. No two macros can have the same name at the same time, nor can a macro have the same name as an existing <a href="#L01D">label</a> or instruction mnemonic.</p>
<p>Macros are an advanced assembler function. They are not necessary, but can be very helpful. Whenever a programmer uses similar sequences of source code in different places, macros can help make that code clear, compact and correct.</p>
<h4>Macros and Local Scopes</h4>
<p>Every macro expansion causes a nested <a href="#L00D">local scope</a> to be created within the existing one. <a href="#L022">Local</a> labels with the same name as others outside this scope do not conflict with them.</p>
<p>Local scopes can be nested to <a href="#L09F">MAXDEPTH</a> by nesting macro expansions. As each expansion ends, so does the nested local scope it created.</p>
<h4>Macro Nesting</h4>
<p>Macro definitions can be nested in two different ways. First, <b>MACRO..ENDMACRO</b>  pairs may be directly nested during definition. Second, a macro body may contain the name of another macro to be expanded.</p>
<p>Note that these two forms have slightly different expansion behavior. When expanding an outer definition of the first form, the delimiters of any inner definition are simply ignored (note this same principle prevents a macro definition from being recognized within <a href="#L084">REPEAT</a> and <a href="#L086">WHILE</a> blocks). Because only one of the nested macro definitions is expanded at any one time, only one new local scope is created.</p>
<p>Expanding the second form causes a new local scope to be created each time a nested macro is invoked.</p>
<p>While macro blocks cannot be defined within <a href="#L084">REPEAT</a> and <a href="#L086">WHILE</a> blocks, they can be expanded. The bodies of each definition must still remain separate. Blocks cannot cross; they must be wholly contained within each other.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0E4">Macro Definition</a></li>
 </ul>
<hr>
<a id="L081"></a>
<h4>ENDMACRO</h4>
<h4>Usage</h4>
<blockquote> <em>[label]</em> <b>ENDMACRO</b>  <em>[name]</em><br> </blockquote>
<h4>Alias</h4>
<ul> <li><em>[label]</em> <b>ENDM</b>  <em>[name]</em></li>
 </ul>
<h4>Parameters</h4>
<ul> <li><em>label</em> is an optional <a href="#L01D">label</a></li>
 <li><em>name</em> is an optional <a href="#L009">global_name</a></li>
 </ul>
<h4>Description</h4>
<p>Marks the end of a macro <em>definition</em>.</p>
<p>If it is labeled, the label is considered to be <em>within</em> the body of the definition. It will be duplicated each time the macro is invoked and its body expanded. For this reason <a href="#L020">global</a> labels, although technically legal, do not serve well here.</p>
<p>If <b>ENDMACRO</b>  is followed by a <em>name</em>, it must match the name of the <b>MACRO</b>  it is paired with.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0E4">Macro Definition</a></li>
 </ul>
<hr>
<a id="L082"></a><h4>Macro Parameters</h4>
<h4>Usage</h4>
<blockquote> name <b>MACRO</b>  ?param <em>[[, ?param]..]</em><br> </blockquote>
<blockquote> <b>MACRO</b>  name$, ?param <em>[[, ?param]..]</em><br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>name</em> is a <a href="#L01F">numeric global</a> name</li>
 <li><em>name$</em> is a <a href="#L009">global_name</a></li>
 <li><em>?param</em> is a numeric global name, except the first character is always '?' (question mark, ASCII 0x3F)</li>
 </ul>
<h4>Description</h4>
<p>Macros can optionally be (and usually are) defined to accept one or more <em>formal parameters</em>.</p>
<p><b>Formal</b>  parameters appear in macro <em>definitions</em> in the <a href="#L027">expression field</a>. If there is more than one, they are separated by commas. Formal parameter names have the same form as <a href="#L01F">numeric global</a> labels , except their type is indicated by a '?' prefix character. They can be thought of as variables which can be set when a macro is <em>invoked</em>.</p>
<p>Within the body of the macro definition, formal parameters may be freely used in the expression field of any source code line. They can be used in the <a href="#L01E">label field</a> or <a href="#L025">opcode field</a> as well, but in those cases the <a href="#L08A">PUTBACK</a> pseudo opcode must be used to protect them.</p>
<p><b>Actual</b>  arguments of macro invocations appear in the expression field. If there is more than one, they are separated by commas as well. Actual arguments are <em>texts</em> that will replace the corresponding formal parameters in the macro body during this expansion. The text of the first actual argument will replace the first formal parameter wherever it appears in the definition body, the second actual argument will replace the second formal parameter, and so on.</p>
<p>This replacement will occur wherever a formal parameter appears, including within quoted strings. Replacement is performed as a straight text substitution. There is no other interpretation or understanding of the actual arguments. This allows actual arguments to exactly match formal parameter spellings (although in most cases this is bad programming style). Also note that <a href="#L00C">escape sequences</a> in actual arguments are <em>not</em> processed until the expanded line is assembled.</p>
<p>The number of formal parameters and actual arguments must always match. For every formal parameter declared during macro definition, there must be an actual argument supplied during macro invocation.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0E4">Macro Definition</a></li>
 </ul>
<hr>
<h4>Default Actual Arguments</h4>
<h4>Usage</h4>
<blockquote> <em>name</em> <b>MACRO</b>  <em>?param=defaultext [[, ?param=defaultext]..]</em><br> </blockquote>
<blockquote> <b>MACRO</b>  <em>name$, ?param=defaultext [[, ?param=defaultext]..]</em><br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>name</em> is a <a href="#L01F">numeric global</a> name</li>
 <li><em>name$</em> is a <a href="#L009">global_name</a></li>
 <li><em>?param</em> is a numeric global name, except the first character is always '?' (question mark, ASCII 0x3F)</li>
 <li><em>defaultext</em> is a <a href="#L009">string_lit</a></li>
 </ul>
<h4>Description</h4>
<p>Formal parameters may have default arguments. At <em>invocation</em> time, actual arguments do not have to be supplied for these formal parameters. At <em>expansion</em> time, they will instead be replaced by their default arguments.</p>
<p>A default actual argument is declared during macro <em>definition</em> using the <a href="#L00B">equality idiom</a>. Only literal values are recognized here, not string expressions.</p>
<blockquote> ?formalparam = text<br> </blockquote>
<p>A default argument text is generally any consecutive run of non-whitespace characters following the equals sign. It does not have to be enclosed in pairs of quote marks.</p>
<p>If it <em>is</em> enclosed in quote marks, the default text runs from just after the opening quote mark to just before the closing one. In this way, whitespace can be used in the default text.</p>
<p>Because blank sub-fields are not allowed in the expression field, it is not possible to "skip over" default actual arguments. Thus:</p>
<ul> <li>during definition, if a default actual argument is declared for any formal parameter, every formal parameter declared after it must also have a default actual argument</li>
 <li>during invocation, if a default actual argument is substituted for any formal parameter, every formal parameter declared after it will also substitute its default argument</li>
 </ul>
<p>This maintains the requirement that formal parameter and actual argument counts must match.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0EB">Default Macro Arguments</a></li>
 </ul>
<hr>
<h4>Variable and Local Labels as Formal Parameters</h4>
<h4>Usage</h4>
<blockquote> name <b>MACRO</b>  label<em>[=defaultexpr] [[, label[=defaultexpr]]..]</em><br> </blockquote>
<blockquote> <b>MACRO</b>  name$, label<em>[=defaultexpr] [[, label[=defaultexpr]]..]</em><br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>name</em> is a <a href="#L01F">numeric global</a> name</li>
 <li><em>name$</em> is a <a href="#L009">global_name</a></li>
 <li><em>label</em> is <a href="#L022">local</a> or <a href="#L023">variable</a> label</li>
 <li><em>defaultexpr</em> is a <a href="#L009">const_expr</a> (if <em>label</em> is numeric) or a <a href="#L009">const_expr$</a> (if label is string)</li>
 </ul>
<h4>Description</h4>
<p>In addition to named formal parameters, variable and local labels may be used as formal parameters in macro definitions. Like named formal parameters, variable and local label formal parameters may have default actual arguments.</p>
<p>At the start of each macro <em>invocation</em>, the actual argument of each label formal parameter is treated as an expression. It is evaluated and the result assigned to the corresponding label formal parameter.</p>
<p>Note this is different from the way named formal parameters are replaced using uninterpreted text substitution. It is equivalent in every way to an <a href="#L078">EQU</a> pseudo opcode within the body of a macro, using a variable or local formal parameter label as the left-hand side and the actual argument as the right. It is essentially a short-hand method of accomplishing the same task.</p>
<p>When a macro is invoked, variable and local labels used as formal arguments are assigned the results of evaluating the actual arguments. Results are assigned in the same left-to-right order as they appear in the macro definition.</p>
<p>Thus this form of definition:</p>
<blockquote> <b>MACRO</b>  mymacro, ?myarg1, ?myarg2, ?myarg3<br> ]myvar1 EQU ?myarg1<br> &#64;myvar2 EQU ?myarg2<br> ]myvar3$ EQU ?myarg3<br> > [..body..]<br> > <b>ENDMACRO</b><br> </blockquote>
<p>and this form:</p>
<blockquote> <b>MACRO</b>  mymacro, ]myvar1, &#64;myvar2, ]myvar3$<br> > [..body..]<br> > <b>ENDMACRO</b><br> </blockquote>
<p>are completely equivalent.</p>
<p>If the <b>ALLEQU</b>  <a href="#L056">listing</a> flag is <b>ON</b> , macro invocations will display the <b>EQU</b>  values being assigned, next to the invocation itself.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0EE">Assignable Formal Arguments</a></li>
 </ul>
<hr>
<a id="L083"></a>
<h4>UNDEF</h4>
<h4>Usage</h4>
<blockquote> <b>UNDEF</b>  name$ <em>[[, name$]..]</em><br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>name$</em> is a <a href="#L009">global_name</a></li>
 </ul>
<h4>Description</h4>
<p>Deletes <em>name$</em> from the set of macro definitions currently known to HXA.</p>
<p>It is not an error to delete an unknown <em>name$</em>.</p>
<p>Undefined macros may be given a definition at any time.</p>
<h4>Examples</h4>
<p><a href="hxa_test.htm#L0E8">DEFINED() and UNDEF</a></p>
<hr>
<a id="L084"></a>
<h4><b>REPEAT</b></h4>
<h4>Usage</h4>
<blockquote> <em>[label]</em> <b>REPEAT</b>  <em>count</em><br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>label</em> is an optional <a href="#L01D">label</a></li>
 <li><em>count</em> is a <a href="#L009">const_expr</a></li>
 </ul>
<h4>Description</h4>
<p>Marks the start of a repeat <em>definition</em>.</p>
<p>A <em>repeat block</em> is a <em>unnamed</em> group of zero or more source code lines delimited by a matched pair of <b>REPEAT</b> ..<a href="#L085">ENDREPEAT</a> pseudo opcodes. The grouped source lines are called the <em>body</em> of the repeat.</p>
<p>A <b>REPEAT..ENDREPEAT</b>  pair defines an expansion block. Because repeat blocks have no name, they cannot be referred to later. Once its definition is complete, a repeat block is immediately <em>expanded</em>.</p>
<p><em>Count</em> is evaluated once at the beginning of the expansion. If <em>count</em> is greater than zero, the effect is to insert the body of the repeat block into the source code at that point, <em>count</em> number of times. From the point of view of HXA, it is as if the lines of the body had always been there.</p>
<p>If <em>count</em> is less than one, the repeat body is simply skipped and nothing happens. If it exceeds <a href="#L0A0">MAXLOOP</a>, a fatal error will occur.</p>
<p>Repeat blocks are an advanced assembler function. They are not necessary, but can be very helpful. They can make source code clear and compact.</p>
<h4>Repeats and Local Scopes</h4>
<p>Every repeat expansion causes a nested <a href="#L00D">local scope</a> to be created without ending the existing one. No matter how many times its body is duplicated, only one nested local scope is created. As an expansion ends, so does the nested local scope it created.</p>
<p>Local labels with the same name as others outside the new local scope do not conflict with those names. Local scopes can be nested to <a href="#L09F">MAXDEPTH</a> by nesting repeat expansions. As each expansion ends, so does the nested local scope it created.</p>
<h4>Repeat Nesting</h4>
<p><b>REPEAT</b>  definitions can be nested directly in repeat bodies. Inner definitions are ignored until they are expanded by an outer definition.</p>
<p>Repeat blocks may also be used within <a href="#L080">MACRO</a> and <a href="#L086">WHILE</a> blocks, but the bodies of each must remain separate. Blocks cannot cross; they must be wholly contained within each other.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0F1">Repeats</a></li>
 </ul>
<hr>
<a id="L085"></a>
<h4><b>ENDREPEAT</b></h4>
<h4>Usage</h4>
<blockquote> <em>[label]</em> <b>ENDREPEAT</b><br> </blockquote>
<h4>Alias</h4>
<ul> <li><em>[label]</em> <b>ENDR</b></li>
 </ul>
<h4>Parameters</h4>
<ul> <li><em>label</em> is an optional <a href="#L01D">label</a></li>
 </ul>
<h4>Description</h4>
<p>Marks the end of a repeat <em>definition</em>.</p>
<p>If it is labeled, the label is considered to be <em>within</em> the body of the definition. It will be duplicated each time the repeat body is expanded. For this reason <a href="#L020">global</a> labels, although technically legal, do not serve well here.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0F1">Repeats</a></li>
 </ul>
<hr>
<a id="L086"></a>
<h4><b>WHILE</b></h4>
<h4>Usage</h4>
<blockquote> <em>[label]</em> <b>WHILE</b>  <em>condition</em><br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>label</em> is any <a href="#L01D">label</a></li>
 <li><em>condition</em> is a <a href="#L009">conditional_expr</a></li>
 </ul>
<h4>Description</h4>
<p><b>WHILE</b>  marks the start of a while <em>definition</em>.</p>
<p>A <em>while block</em> is a <em>unnamed</em> group of zero or more source code lines delimited by a matched pair of <b>WHILE</b> ..<a href="#L087">ENDWHILE</a> pseudo opcodes. The grouped source lines are called the <em>body</em> of the while.</p>
<p>A <b>WHILE..ENDWHILE</b>  pair defines an expansion block. Because while blocks have no name, they cannot be referred to later. Once its definition is complete, a while block is <em>expanded</em> immediately.</p>
<p><em>Condition</em> is evaluated at the start of each loop. Each time it evaluates as <em>TRUE</em>, the effect is to insert the body of the while block into the source code at that point. From the point of view of HXA, it is as if the lines of the body had always been there.</p>
<p>If the body is duplicated more than <a href="#L0A0">MAXLOOP</a> times, a fatal error will occur.</p>
<p>The first time <em>condition</em> evaluates as <em>FALSE</em>, the body is skipped and assembly continues at the <b>ENDWHILE</b>  marking the end of that block.</p>
<p>While blocks are an advanced assembler function. They are not necessary, but can be very helpful. They are particularly useful when the exact termination condition is not known in advance.</p>
<h4>Whiles and Local Scopes</h4>
<p>Every while expansion causes a nested <a href="#L00D">local scope</a> to be created without ending the existing one. No matter how many times its body is duplicated, only one nested local scope is created. As an expansion ends, so does the nested local scope it created.</p>
<p>Local labels with the same name as others outside the new local scope do not conflict with those names. Local scopes can be nested to <a href="#L09F">MAXDEPTH</a> by nesting while expansions. As each expansion ends, so does the nested local scope it created.</p>
<h4>While Nesting</h4>
<p><b>WHILE</b>  definitions can be nested directly in while bodies. Inner definitions are ignored until they are expanded by an outer definition.</p>
<p>While blocks may also be used within <a href="#L080">MACRO</a> and <a href="#L084">REPEAT</a> blocks, but the bodies of each must remain separate. Blocks cannot cross; they must be wholly contained within each other.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0F7">Whiles</a></li>
 </ul>
<hr>
<a id="L087"></a>
<h4><b>ENDWHILE</b></h4>
<h4>Usage</h4>
<blockquote> <em>[label]</em> <b>ENDWHILE</b><br> </blockquote>
<h4>Alias</h4>
<ul> <li><em>[label]</em> <b>ENDW</b></li>
 </ul>
<h4>Parameters</h4>
<ul> <li><em>label</em> is an optional <a href="#L01D">label</a></li>
 </ul>
<h4>Description</h4>
<p>Marks the end of a while <em>definition</em>.</p>
<p>The body of the definition will be <em>expanded</em> immediately.</p>
<p>If it is labeled, the label is considered to be <em>within</em> the body of the definition. It will be duplicated each time the while body is expanded. For this reason <a href="#L020">global</a> labels, although technically legal, do not serve well here.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0F7">Whiles</a></li>
 </ul>
<hr>
<a id="L088"></a>
<h4><b>EXIT</b></h4>
<h4>Usage</h4>
<blockquote> <b>EXIT</b><br> </blockquote>
<h4>Description</h4>
<p>Unconditionally skip to the end of the nearest enclosing <a href="#L080">MACRO</a>, <a href="#L084">REPEAT</a> or <a href="#L086">WHILE</a> block. Open <a href="#L08D">IF</a> blocks within the enclosing expansion block are ignored (ie., silently closed).</p>
<p>Skipped source lines are not processed. Processing resumes at the line marking the end of the block. Any label attached to that line will be processed.</p>
<p><b>EXIT</b>  is legal only within block expansions. It can be made condtional if inside an <a href="#L08D">IF</a> block which is itself within a macro, repeat or while block.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0E6">EXIT from Macro</a></li>
 <li><a href="hxa_test.htm#L0F4">EXIT from Repeat</a></li>
 <li><a href="hxa_test.htm#L0FA">EXIT from While</a></li>
 </ul>
<hr>
<a id="L089"></a>
<h4><b>EXITIF</b></h4>
<h4>Usage</h4>
<blockquote> <b>EXITIF</b>  <em>condition</em><br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>condition</em> is a <a href="#L009">conditional_expr</a></li>
 </ul>
<h4>Description</h4>
<p>Behaves as <a href="#L088">EXIT</a> does if <em>condition</em> is <em>TRUE</em>. Otherwise does nothing, and assembly continues as normal.</p>
<h4>Examples</h4>
<p><a href="hxa_test.htm#L0E7">EXITIF from Macro</a></p>
<hr>
<a id="L08A"></a>
<h4><b>PUTBACK</b></h4>
<h4>Usage</h4>
<blockquote> <b>PUTBACK</b>  <em>[text]</em><br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>text</em> is an optional <a href="#L009">string_lit</a>, from the first non-whitepace to the last non-whitespace character</li>
 </ul>
<h4>Alias</h4>
<ul> <li><b>ONEXPAND</b>  <em>[text]</em></li>
 </ul>
<h4>Description</h4>
<p>Pushes its argument back onto the input stream without altering it in any way. The pushed back argument becomes the next input line.</p>
<p><b>PUTBACK</b>  can only be used within <a href="#L080">MACRO</a>, <a href="#L084">REPEAT</a> and <a href="#L086">WHILE</a> blocks. In essence this pseudo opcode <em>protects</em> its argument from normal processing while the block it appears in is being defined. When the block is expanded, the leading <b>PUTBACK</b>  is removed and the result is processed normally.</p>
<p>In the case of macros, <b>PUTBACK</b>  can allow the use of formal arguments in both the <a href="#L01E">label field</a> and the <a href="#L025">opcode field</a>. It can also be used to permit <a href="#L02A">forward reference</a> to a macro which has not yet been defined (including recursive macros).</p>
<p>If <b>PUTBACK</b>  has no argument, it does nothing.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0EC">PUTBACK pseudo op</a></li>
 </ul>
<hr>
<a id="L08B"></a>
<h4><b>PUTBACKS</b></h4>
<h4>Usage</h4>
<blockquote> <b>PUTBACKS</b>  expr$ <em>[[, expr$]..]</em><br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>expr$</em> is a <a href="#L009">const_expr$</a></li>
 </ul>
<h4>Alias</h4>
<ul> <li><b>PUTSTR</b>  expr$ <em>[[, expr$]..]</em></li>
 </ul>
<h4>Description</h4>
<p>Concatenates all following expressions into a single string, then pushes that string back onto the input stream. The pushed back string becomes the next input line.</p>
<p><b>PUTBACKS</b>  can only be used within <a href="#L080">MACRO</a>, <a href="#L084">REPEAT</a> and <a href="#L086">WHILE</a> blocks. In essence this pseudo opcode <em>protects</em> its arguments from normal processing while the block it appears in is being defined. When the block is expanded, the leading <b>PUTBACKS</b>  is removed and arguments are processed normally.</p>
<p>In the case of macros, <b>PUTBACKS</b>  can allow the use of formal arguments in both the <a href="#L01E">label field</a> and the <a href="#L025">opcode field</a>. It can also be used to permit <a href="#L02A">forward reference</a> to a macro which has not yet been defined (including recursive macros).</p>
<p><b>PUTBACKS</b>  requires at least one argument. If the result is the null string, a warning will be issued.</p>
<p>This pseudo opcode can be used to dynamically create input lines during assembly.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0ED">PUTBACKS pseudo op</a></li>
 </ul>
<a id="L08C"></a><h3>Conditional Assembly</h3>
<a id="L08D"></a>
<h4><b>IF</b></h4>
<h4>Usage</h4>
<blockquote> <b>IF</b>  <em>condition</em><br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>condition</em> is a <a href="#L009">conditional_expr</a></li>
 </ul>
<h4>Description</h4>
<p>Marks the start of a <em>conditional</em> block.</p>
<p>A conditional block is an unnamed group of zero or more source code lines delimited by a matched pair of <b>IF</b> ..<b>ENDIF</b>  pseudo opcodes. The grouped source lines are called the <em>body</em> of the conditional block.</p>
<p>Within the whole body of the conditional block, there may be one or more alternative branch bodies. The start of each alternative branch is marked by an <a href="#L08F">ELSEIF</a> or <a href="#L090">ELSE</a> pseudo opcode.</p>
<p>The branch body following the first <b>IF</b>  or <b>ELSEIF</b>  whose conditional evaluates as <em>TRUE</em> is processed. If no alternative conditional has evaluated as <em>TRUE</em> and an <b>ELSE</b>  is found, the branch body of the <b>ELSE</b>  is processed. Control then skips to the <b>ENDIF</b>  which marks the end of the conditional block.</p>
<p>Thus, at most only one branch of a conditional block is ever processed.</p>
<p>Conditional assembly blocks may be nested by using another <b>IF</b>  within them. These count against <a href="#L09F">MAXDEPTH</a>, but they do <em>not</em> create new local scopes.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0FD">Conditional Assembly</a></li>
 </ul>
<hr>
<a id="L08E"></a>
<h4><b>ENDIF</b></h4>
<h4>Usage</h4>
<blockquote> <b>ENDIF</b><br> </blockquote>
<h4>Description</h4>
<p>Marks the end of a <a href="#L08D">conditional block</a>.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0FD">Conditional Assembly</a></li>
 </ul>
<hr>
<a id="L08F"></a>
<h4><b>ELSEIF</b></h4>
<h4>Usage</h4>
<blockquote> <b>ELSEIF</b>  <em>condition</em><br> </blockquote>
<h4>Alias</h4>
<ul> <li><b>ELIF</b>  <em>condition</em></li>
 </ul>
<h4>Parameter</h4>
<ul> <li><em>condition</em> is a <a href="#L009">conditional_expr</a></li>
 </ul>
<h4>Description</h4>
<p>Marks the start of an alternative conditional branch in a <a href="#L08D">conditional block</a>.</p>
<p>An <a href="#L08D">IF</a>..<a href="#L08E">ENDIF</a> conditional block may contain any number of <b>ELSEIF</b>  pseudo opcodes. Each one marks the start of a branch body. This branch ends with the next <b>ELSEIF</b> , <a href="#L090">ELSE</a> or <a href="#L08E">ENDIF</a> pseudo opcode in the same block.</p>
<p>At most only one branch of a conditional block is ever processed. The first branch body following an <b>IF</b>  or <b>ELSEIF</b>  which evaluates as <em>TRUE</em> is processed. Control then skips to the <b>ENDIF</b>  which marks the end of the conditional block.</p>
<p>The condition following an <b>ELSEIF</b>  is evaluated only if every preceding <b>IF</b>  and <b>ELSEIF</b>  in the conditional block has evaluated as <em>FALSE</em>. Once a <em>TRUE</em> condition has been found and its body processed, all following conditions are ignored.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0FD">Conditional Assembly</a></li>
 </ul>
<hr>
<a id="L090"></a>
<h4><b>ELSE</b></h4>
<h4>Usage</h4>
<blockquote> <b>ELSE</b><br> </blockquote>
<h4>Description</h4>
<p>Marks the start of an alternative unconditional branch in a <a href="#L08D">conditional block</a>.</p>
<p>The branch body following the first <b>ELSE</b>  encountered is always processed. Control then skips to the <a href="#L08E">ENDIF</a> which marks the end of the conditional block.</p>
<p>It is also legal to end the branch body begun by an <b>ELSE</b>  with an <a href="#L08F">ELSEIF</a> or another <b>ELSE</b>  pseudo opcode. However, HXA will ignore every alternative branch after the first <b>ELSE</b> .</p>
<p>So in practice there is usually only one <b>ELSE</b>  in a conditional block. Normally it controls only the last alternative branch. This branch will be processed only if every preceding <b>IF</b>  and <b>ELSEIF</b>  in the same conditional block has already evaluated as <em>FALSE</em>.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0FD">Conditional Assembly</a></li>
 </ul>
<hr>
<a id="L091"></a>
<h4><b>IFDEF</b></h4>
<h4>Usage</h4>
<blockquote> <b>IFDEF</b>  name<br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>name</em> is a <a href="#L009">global_name</a></li>
 </ul>
<h4>Description</h4>
<p>Marks the start of a <a href="#L08D">conditional block</a>.</p>
<p><b>IFDEF</b>  is an alternative to <a href="#L08D">IF</a>, and can be used anywhere an <b>IF</b>  can be.</p>
<p><b>IFDEF</b>   evaluates as <em>TRUE</em> if <em>name</em> is a known <a href="#L020">global</a> label or a <a href="#L080">macro</a> (ie., in an HXA table). Only the existence of <em>name</em> is important in this context.</p>
<p>If only global names should be checked, use the <a href="#L03A">LABEL()</a> function. If only macro names should be checked, use the <a href="#L033">DEFINED()</a> function.</p>
<p>All variants of HXA support three or more <a href="#L021">pre-defined</a> labels which can be used with this pseudo opcode.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L102">IFDEF and IFNDEF Blocks</a></li>
 </ul>
<hr>
<a id="L092"></a>
<h4><b>IFNDEF</b></h4>
<h4>Usage</h4>
<blockquote> <b>IFNDEF</b>  name<br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>name</em> is a <a href="#L009">global_name</a></li>
 </ul>
<h4>Description</h4>
<p>Marks the start of a <a href="#L08D">conditional block</a>.</p>
<p><b>IFNDEF</b>  is an alternative to <a href="#L08D">IF</a> and can be used anywhere an <b>IF</b>  can be.</p>
<p><b>IFNDEF</b>  evaluates as <em>TRUE</em> if <em>name</em> is a <em>not</em> a known <a href="#L020">global</a> label or a <a href="#L080">macro</a> (ie., is not in an HXA table). Only the non-existence of <em>name</em> is important in this context.</p>
<p>If only global names should be checked, the <a href="#L03A">LABEL()</a> function. If only macro names should be checked, use the <a href="#L033">DEFINED()</a> function.</p>
<p>All variants of HXA support three or more <a href="#L021">pre-defined</a> labels which can be used with this pseudo opcode.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L102">IFDEF and IFNDEF Blocks</a></li>
 </ul>
<a id="L093"></a>
<h4><b>ECHO</b></h4>
<h4>Usage</h4>
<blockquote> <b>ECHO</b>  <em>[mesg]</em><br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>mesg</em> is an optional <a href="#L009">opt_str</a></li>
 </ul>
<h4>Description</h4>
<p>Display an informational message.</p>
<p>If no <em>mesg</em> is provided, a blank line is output.</p>
<p>Echo messages are formatted in exactly the same way as internally-triggered messages. They are both saved and sent to <em>stdout</em>. If an <a href="#L055">error file</a> has specified, they will be written to that file at the end of assembly.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0B9">User Messages</a></li>
 <li><a href="hxa_test.htm#L187">User Messages w/ String Expressions</a></li>
 </ul>
<hr>
<a id="L094"></a>
<h4><b>WARN</b></h4>
<h4>Usage</h4>
<blockquote> <b>WARN</b>  <em>[mesg]</em><br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>mesg</em> is an optional <a href="#L009">opt_str</a></li>
 </ul>
<h4>Description</h4>
<p>Display a warning message.</p>
<p>If no <em>mesg</em> is provided, a default message is used.</p>
<p>Warning messages are formatted in exactly the same way as internally-triggered messages. They are both sent to <em>stdout</em> and saved internally. If an <a href="#L055">error file</a> has specified, they will be written to that file at the end of assembly.</p>
<p>Warnings do not halt assembly by themselves, but will if their cumulative count is sufficient to cause a <a href="#L096">fatal</a> error. The default limit can be changed with the <a href="#L0A2">MAXWARN</a> pseudo op.</p>
<p>The sending of warning messages to <em>stdout</em> can be controlled with <a href="#L098">WARNON</a> and <a href="#L098">WARNOFF</a>. The default status is <b>WARNON</b> .</p>
<p>While there are no hard and fast rules as to when a warning message is appropriate, HXA itself generally does so when a source line:</p>
<ul> <li>contains a minor mistake of no consequence, or</li>
 <li>contains something unusual enough that a more serious mistake might eventually result</li>
 </ul>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0B9">User Messages</a></li>
 <li><a href="hxa_test.htm#L187">User Messages w/ String Expressions</a></li>
 </ul>
<hr>
<a id="L095"></a>
<h4><b>ERROR</b></h4>
<h4>Usage</h4>
<blockquote> <b>ERROR</b>  <em>[mesg]</em><br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>mesg</em> is an optional <a href="#L009">opt_str</a></li>
 </ul>
<h4>Description</h4>
<p>Display an error message.</p>
<p>If no <em>mesg</em> is provided, a default message is used.</p>
<p>Error messages are formatted in exactly the same way as internally-triggered messages. They are both saved and sent to <em>stdout</em>. If an <a href="#L055">error file</a> has specified, they will be written to that file at the end of assembly.</p>
<p>Errors will halt assembly at the end of the current pass, or sooner if their cumulative count is sufficient to cause a <a href="#L096">fatal</a> error. The default limit can be changed with the <a href="#L0A1">MAXERR</a> pseudo op.</p>
<p>While there are no hard and fast rules as to when a error message is appropriate, HXA itself generally does so when a source line:</p>
<ul> <li>cannot be correctly assembled under any circumstances</li>
 </ul>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0B9">User Messages</a></li>
 <li><a href="hxa_test.htm#L187">User Messages w/ String Expressions</a></li>
 </ul>
<hr>
<a id="L096"></a>
<h4><b>FATAL</b></h4>
<h4>Usage</h4>
<blockquote> <b>FATAL</b>  <em>[mesg]</em><br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>mesg</em> is an optional <a href="#L009">opt_str</a></li>
 </ul>
<h4>Description</h4>
<p>Display a fatal error message and immediately halt assembly.</p>
<p>If no <em>mesg</em> is provided, a default message is used.</p>
<p>A fatal error message is formatted in exactly the same way as an internally-triggered message. It is both saved and sent to <em>stdout</em>. If an <a href="#L055">error file</a> has specified, it will be written to that file.</p>
<p>While there are no hard and fast rules as to when a fatal error message is appropriate, HXA itself generally does so when a source line:</p>
<ul> <li>contains an error large enough to cause incorrect assembly of several lines</li>
 </ul>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0B9">User Messages</a></li>
 <li><a href="hxa_test.htm#L187">User Messages w/ String Expressions</a></li>
 </ul>
<hr>
<a id="L097"></a>
<h4><b>ASSERT</b></h4>
<h4>Usage</h4>
<blockquote> <b>ASSERT</b>  <em>condition</em><br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>condition</em> is a <a href="#L009">conditional_expr</a></li>
 </ul>
<h4>Description</h4>
<p>Evaluate <em>condition</em> and trigger an error if it is <em>FALSE</em>. Otherwise, <b>ASSERT</b>  does nothing.</p>
<p>Failed assertions are reported as soon as they are known. If <em>condition</em> cannot be fully evaluated and checked on the first pass, it will be on the second.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0BC">Assert Messages</a></li>
 </ul>
<hr>
<a id="L098"></a>
<h4><b>WARNON, WARNOFF</b></h4>
<h4>Usage</h4>
<blockquote> <b>WARNON</b><br> </blockquote>
<blockquote> <b>WARNOFF</b><br> </blockquote>
<h4>Description</h4>
<p><b>WARNON</b>  enables, and <b>WARNOFF</b>  disables, the sending of warning messages to <em>stdout</em>.</p>
<p>The default state is <b>WARNON</b> .</p>
<p>Warning messages, both internally- and programmer-triggered, are still saved. If an <a href="#L055">error file</a> has been specified, they will be written to that file.</p>
<p>Regardless of how these are set, warning messages will still contribute to the count necessary to trigger a <a href="#L096">fatal</a> error. The default limit can be changed with the <a href="#L0A2">MAXWARN</a> pseudo opcode.</p>
<p>These pseudo opcodes may be used at any time (even consecutively repeated). They remain in effect until the opposite pseudo opcode is used.</p>
<h4>Examples:</h4>
<ul> <li><a href="hxa_test.htm#L0B9">User Messages</a></li>
 </ul>
<a id="L099"></a><h3>User Customization</h3>
<a id="L09A"></a>
<h4><b>PSALIAS</b></h4>
<h4>Usage</h4>
<blockquote> <b>PSALIAS</b>  psop=alias <em>[[, psop=alias]...]</em><br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>psop=alias</em> is an <a href="#L00B">equality idiom</a></li>
 </ul>
<h4>Description</h4>
<p>Assigns user-chosen names to existing <a href="#L069">pseudo opcodes</a>. The alias name can then be used in place of the original name wherever it is legal to do so.</p>
<p>Alias names have the same form as <a href="#L01F">numeric global</a> labels. Aliases must be unique. They cannot be the same as any existing name.</p>
<h4>Example:</h4>
<p><a href="hxa_test.htm#L0C6">Pseudo Op Names</a></p>
<hr>
<a id="L09B"></a>
<h4><b>PSNULL</b></h4>
<h4>Usage</h4>
<ul> <li><em>[text]</em> <b>PSNULL</b>  <em>[text [, text] ... ]</em></li>
 </ul>
<h4>Parameters</h4>
<blockquote> <em>text</em> is any non-whitespace sequence of UTF-8 characters<br> </blockquote>
<h4>Description</h4>
<p>Ignores all text on either side of the pseudo opcode.</p>
<p><b>PSNULL</b>  is meant to ease porting source code to HXA. Such code may contain one or more pseudo opcodes for which HXA has no built-in equivalent. If any can be safely ignored, they may be aliased to <b>PSNULL</b> . This will allow HXA to effectively skip them whenever encountered.</p>
<h4>Example</h4>
<ul> <li><a href="hxa_test.htm#L0C7">Pseudo Op Nullification</a></li>
 </ul>
<hr>
<a id="L09C"></a>
<h4>MESGTEXT</h4>
<h4>Usage</h4>
<blockquote> <b>MESGTEXT</b>  ndx=mesg <em>[[, ndx=mesg] ... ]</em><br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>ndx=message</em> is an <a href="#L00B">equality idiom</a></li>
 </ul>
<h4>Description</h4>
<p>Assigns arbitrary text to an assembler message.</p>
<p>All messages displayed by HXA are created based on an index into a table of <a href="hxa_source.htm#L1B8">assembler messages</a>. HXA's default messages can thus be replaced by user-chosen messages.</p>
<p>The <em>ndx</em> must exactly match an internal HXA message index (ie., the match is case-sensitive).</p>
<p>Note that all unprintable characters of both <em>ndx</em> and  <em>mesg</em> are converted to a printable hexdecimal representation before use.</p>
<h4>Example</h4>
<ul> <li><a href="hxa_test.htm#L0C8">Assembler Messages</a></li>
 </ul>
<hr>
<a id="L09D"></a>
<h4>ASSUME</h4>
<h4>Usage</h4>
<blockquote> <b>ASSUME</b>  flag=value <em>[[, flag=value] ... ]</em><br> </blockquote>
<h4>Parameters</h4>
<ul> <li><em>flag=value</em> is an <a href="#L00B">equality idiom</a></li>
 </ul>
<h4>Description</h4>
<p>Control several optional HXA settings. In effect, substitutes a proliferation of <b>ASSUME</b>  control strings for a proliferation of pseudo opcodes.</p>
<p>Some assumptions are built into HXA. Others are meaningful only to a specific <a href="#L06A">CPU</a> <a href="#L007">handler</a>.</p>
<p>HXA itself recognizes the following flags and their allowed values:</p>
<blockquote> <b>ASSUME</b>  printable=['ascii', 'latin-1', 'utf-8']<br> </blockquote>
<ul> <li>the character set to use for output to <em>stdout</em> and <a href="#L095">error</a> and <a href="#L056">listing</a> files</li>
 <li>default value: 'printable:utf-8'</li>
 <li>can be changed at any time</li>
 </ul>
<blockquote> <b>ASSUME</b>  objstr=['ascii', 'latin-1', 'utf-8', 'utf-16[be][le]', 'utf-32[be][le]']<br> </blockquote>
<ul> <li>the character set to use for output files</li>
 <li>default value: 'objstr:utf-8'</li>
 <li>can be changed at any time</li>
 <li>'utf-16' and 'utf-32' used without a 'be' or 'le' suffix will match the processor's orientation</li>
 </ul>
<blockquote> <b>ASSUME</b>  float=['ieee-double[-be][-le]', 'ieee-single[-be][-le]', 'ieee-half[-be][-le]', 'esm4[-be][-le]']<br> </blockquote>
<ul> <li>the format to use for outputting floating point values</li>
 <li>default value: 'float:ieee-double', IEEE-754 double precision</li>
 <li>can be changed at any time</li>
 <li>'float:ieee-single', IEEE-754 single precision</li>
 <li>'float:ieee-half', IEEE-754 half precision</li>
 <li>'float:esm4', 1 exponent octet with a signed 4 octet mantissa</li>
 <li>'-be' orders octets big end first, '-le' orders octets little end first</li>
 <li>if no ordering specified, defaults to '-be'</li>
 </ul>
<blockquote> <b>ASSUME</b>  hexfile=['flat', 'segmented', 'linear']<br> </blockquote>
<ul> <li><a href="#L0A8">Intel Hex</a> format output files</li>
 <li>default value: 'hexfile:flat'</li>
 <li>must have the same value each time it is used</li>
 </ul>
<blockquote> <b>ASSUME</b>  srecfile=['s19', 's28', 's37', 'noheader', 'noname', 'nocount']<br> </blockquote>
<ul> <li><a href="#L0AA">Motorola SRecord</a> format output files; which record types to supress</li>
 <li>default value: 'srecfile:s19'; header with <a href="#L007">root file</a> name; data record count</li>
 <li>must have the same value each time it is used</li>
 </ul>
<blockquote> <b>ASSUME</b>  hexdatasize=[8, 32]<br> </blockquote>
<ul> <li>number of data bytes per output record in text object files</li>
 <li>minimum eight, maximum 32</li>
 <li>default value: 'hexdatasize:16'</li>
 <li>must have the same value each time it is used</li>
 <li><em>value</em> can be an expression</li>
 <li>the last data record can be partial, as can earlier records if consecutive data bytes do not have continuous addresses</li>
 <li>each "byte" in an output record is normally two characters, but can be up to eight if <a href="#L0AD">non-standard byte</a> sizes are used</li>
 </ul>
<blockquote> <b>ASSUME</b>  bit[08|16|24|32][r]=[0123]<br> </blockquote>
<ul> <li>set output order of 8-bit octets in 32-bit integer values for one family of <a href="#L06E">BIT--</a> pseudo opcodes (<a href="#L0AB">octet extraction</a> order)</li>
 <li>default: the native extraction order of the <a href="#L06A">CPU</a> in use, 0123 for a LSB cpu or 3210 for a MSB cpu</li>
 <li>the same variant must have the same value each time it is used</li>
 </ul>
<p>All assumption <em>flags</em> and <em>values</em> are given to handlers in sequence. If a handler does not deal with an assumption, the next handler in line is called. If no built-in handler deals with an assumption, the processor specific <a href="#L007">handler</a> is called.</p>
<p>The first handler to process an assumption stops further processing. If no handler deals with an assumption, HXA reports an error.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0C9">ASSUME Strings</a></li>
 <li><a href="hxa_test.htm#L172">ASSUME Non-Default Order</a></li>
 </ul>
<a id="L09E"></a><h4>Maximum Limits</h4>
<h4>Usage</h4>
<blockquote> <b>MAX---</b>  count<br> </blockquote>
<h4>Parameter</h4>
<ul> <li><em>count</em> is a <a href="#L009">const_expr</a></li>
 </ul>
<h4>Description</h4>
<p>While executing, HXA tracks how large certain internal counters get. A fatal error will occur if any of them are exceeded.</p>
<p>The <b>MAX---</b>  group of pseudo opcodes allow programmers to change inconvenient default limit values to whatever may be more suitable.</p>
<p>They may be set to any value. Values of zero or less will cause a warning, and then a fatal error the first time they are checked.</p>
<hr>
<a id="L09F"></a>
<h4><b>MAXDEPTH</b></h4>
<h4>Usage</h4>
<blockquote> <b>MAXDEPTH</b>  count<br> </blockquote>
<h4>Description</h4>
<p>Controls the number of nested <a href="#L00D">local scopes</a> allowed to be open at any one time before a fatal error occurs.</p>
<p>The default value is 64.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0F0">Nesting Depth</a></li>
 <li><a href="hxa_test.htm#L101">Deep Nesting</a></li>
 </ul>
<hr>
<a id="L0A0"></a>
<h4><b>MAXLOOP</b></h4>
<h4>Usage</h4>
<blockquote> <b>MAXLOOP</b>  count<br> </blockquote>
<h4>Description</h4>
<p>Controls how many consecutive times the body of a <a href="#L084">REPEAT</a> or <a href="#L086">WHILE</a> loop can be expanded before a fatal error occurs.</p>
<p>Counts apply to individual loops. A nested loop starts a new count for that loop without changing the count of its nesting loop.</p>
<p>The default value is 2048.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L0F6">Repeat Count</a></li>
 <li><a href="hxa_test.htm#L0FC">While Count</a></li>
 </ul>
<hr>
<a id="L0A1"></a>
<h4>MAXERR</h4>
<h4>Usage</h4>
<blockquote> <b>MAXERR</b>  count<br> </blockquote>
<h4>Description</h4>
<p>Controls the number of non-fatal error messages allowed before a fatal error occurs.</p>
<p>The default value is 25.</p>
<h4>Example</h4>
<ul> <li><a href="hxa_test.htm#L0BB">Error Count</a></li>
 </ul>
<hr>
<a id="L0A2"></a>
<h4><b>MAXWARN</b></h4>
<h4>Usage</h4>
<blockquote> <b>MAXWARN</b>  count<br> </blockquote>
<h4>Description</h4>
<p>Controls the number of warning messages allowed before a fatal error occurs.</p>
<p>The default value is 50.</p>
<p>HXA tracks this number even if the sending of warning messages to <em>stdout</em> is disabled by <a href="#L098">WARNOFF</a>.</p>
<h4>Example</h4>
<ul> <li><a href="hxa_test.htm#L0BA">Warn Count</a></li>
 </ul>
<hr>
<a id="L0A3"></a>
<h4><b>MAXPUTBACK</b></h4>
<h4>Usage</h4>
<blockquote> <b>MAXPUTBACK</b>  count<br> </blockquote>
<h4>Description</h4>
<p>Controls the maximum number of consecutive source lines that can be pushed back onto input by <a href="#L08A">PUTBACK</a> or <a href="#L08B">PUTBACKS</a>.</p>
<p>The default value is 128.</p>
<h4>Example</h4>
<ul> <li><a href="hxa_test.htm#L101">Deep Nesting</a></li>
 </ul>
<hr>
<a id="L0A4"></a>
<h4><b>MAXSEG</b></h4>
<h4>Usage</h4>
<blockquote> <b>MAXSEG</b>  count<br> </blockquote>
<h4>Description</h4>
<p>Controls the number of segments allowed before a fatal error occurs.</p>
<p>The default value is 1024.</p>
<h4>Example</h4>
<ul> <li><a href="hxa_test.htm#L128">Segment Count</a></li>
 </ul>
<hr>
<a id="L0A5"></a>
<h4><b>MAXSTACK</b></h4>
<h4>Usage</h4>
<blockquote> <b>MAXSTACK</b>  count<br> </blockquote>
<h4>Discussion</h4>
<p>Controls the maximum depth of the <a href="#L07E">user stack</a> before a fatal error occurs.</p>
<p>The default value is 128.</p>
<h4>Example</h4>
<ul> <li><a href="hxa_test.htm#L189">User Stack</a></li>
 </ul>
<a id="L0A6"></a><h3>Appendices</h3>
<a id="L0A7"></a><h4>Intel</h4>
<h4>Intel Numeric Literal Format</h4>
<p>All numbers in Intel format must begin with a decimal digit. In particular, hexadecimal numbers may <em>not</em> begin with the letters 'A' through 'F'. Use a leading '0' character (numeric zero, ASCII 030H) if necessary (HXA always ignores leading zeros).</p>
<p>Binary, decimal and hexadecimal Intel numbers are specified by a case-insensitive <em>suffix</em>:</p>
<ul> <li><b>B</b>  for binary numbers</li>
 <li><b>D</b>  for decimal numbers (optional)</li>
 <li><b>H</b>  for hexadecimal numbers</li>
 </ul>
<h4>Example</h4>
<p>The decimal number 192:</p>
<ul> <li>binary : 11000000b</li>
 <li>decimal : 192d</li>
 <li>hexadecimal : 0C0h</li>
 </ul>
<hr>
<a id="L0A8"></a>
<h4>Intel Hexadecimal Object File Format</h4>
<p>The Intel Hexadecimal Object file format is an ASCII text representation of an absolute memory image. The specification is based on the 8080 and 80x86 processors with accumulator widths of 8-, 16- and 32-bits.</p>
<p>Each line of the file represents a single record consisting of up to six fields:</p>
<blockquote> <b>Record Mark | Record Length | Load Offset | Record Type | Data Field | Checksum</b>  (EOT)<br> </blockquote>
<p><em>EOT</em> stands for the "End of Text" marker that ends each line of text. The exact marker varies between operating systems.</p>
<p>The fields are defined as:</p>
<ul> <li>Record Mark: - 1 character; always ':' (colon, ASCII 03AH)</li>
 <li>Record Length: - 2 characters; length of Data Field in bytes (max 255, ASCII 'FF', 046046H)</li>
 <li>Load Offset: - 4 characters; offset of Data Field bytes from base Address</li>
 <li>Record Type: - 2 characters; one of six types numbered zero to five (ASCII 030H to 035H)</li>
 <li>Data Field: -  2 &ast; Record Length characters; data bytes of all record types except type one (EOF)</li>
 <li>Checksum: -    2 characters; two's complement of ((byte sum of length+offset+type+data) & 0FFH) (sum + checksum = 0)</li>
 </ul>
<p>The Record Types are defined as:</p>
<ul> <li>0: ASCII 030H, Data Byte, 8-, 16 and 32-bits</li>
 <li>1: ASCII 031H, End of File, 8-, 16 and 32-bits</li>
 <li>2: ASCII 032H, Extended Segment Address, 16- and 32-bit</li>
 <li>3: ASCII 033H, Start Segment Address, 16- and 32-bits</li>
 <li>4: ASCII 034H, Extended Linear Address, 32-bits</li>
 <li>5: ASCII 035H, Start Linear Address, 32-bits</li>
 </ul>
<h4>Notes on the Base Specification Assumptions</h4>
<ul> <li>8-bit "bytes"</li>
 <li>Addresses start at zero (0000H) and do not exceed 16-bits (FFFFH). Thus only Record Types zero and one appear</li>
 </ul>
<h4>Related Resources</h4>
<ul> <li>Intel Hexadecimal Object File Format Specification, Revision A, 01/06/88</li>
 </ul>
<h4>ASSUME and Intel Hexadecimal Files</h4>
<p>The Intel specification requires that records for the 80836 and above processors can be either segmented (real mode) or linear (protected mode). Other processors may support only linear Addresses.</p>
<p>HXA default mode selection is based on the width of the <a href="#L06A">CPU</a> <a href="#L029">program counter</a>:</p>
<ul> <li>flat: up to 16 bits wide</li>
 <li>segmented : greater than 16 but no more than 20 bits wide</li>
 <li>linear: greater than 20 bits wide</li>
 </ul>
<p>HXA does allow the default Address record types in an Intel Hexadecimal Object file to be overridden by using the<b>ASSUME</b>  pseudo opcode:</p>
<ul> <li><b>ASSUME</b>  hexfile=flat : 16-bit Address space, no segmented or linear records allowed</li>
 <li><b>ASSUME</b>  hexfile=segmented : 20-bit Address space, forces segmented Address records</li>
 <li><b>ASSUME</b>  hexfile=linear : 32-bit Address space, forces linear Address records</li>
 </ul>
<p>These may be used at any point in the source file(s). <em>HEXFILE</em> may be used as often as desired, but must always have the same value. If any use after the first differs from it, a warning will be generated and the request ignored.</p>
<p>If <em>HEXFILE</em> is used to force a smaller Address space than what the CPU would normally allow, data already generated is checked to guarantee it all fits within that smaller Address space. If an out-of-range value is discovered, the error is thus reported as belonging to the <em>HEXFILE</em> line which lowered the limit. Any later line that forces an out-of-range Address value is reported normally.</p>
<h4>Non-Standard Byte Sizes</h4>
<p>The Intel Hexadecimal Object Format is modified in a non-standard way if the size of a "byte" (smallest Addressable unit) is 16- or 32-bits.</p>
<p>16-Bit Bytes</p>
<ul> <li>the 'Record Mark' is always ';' (semi-colon, ASCII 03BH)</li>
 <li>the 'Record Length' is always 8-bit octet correct</li>
 <li>the 'Extended Address'(if any) + 'Load Offset' is always byte-correct whatever the "byte" size is</li>
 <li>the number of data characters can be up to 4 &ast; <a href="#L09D">HEXDATASIZE=</a> (up to 128 characters)</li>
 </ul>
<p>32-Bit Bytes</p>
<ul> <li>the 'Record Mark' is always '&lt;' (less than, ASCII 03CH)</li>
 <li>the 'Record Length' is always 8-bit octet correct</li>
 <li>the 'Extended Address'(if any) + 'Load Offset' is always byte-correct whatever the "byte" size is</li>
 <li>the number of data characters can be up to 8 &ast; HEXDATASIZE (up to 256 characters)</li>
 </ul>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L177">16-bit Intel Basic Hex Record</a></li>
 <li><a href="hxa_test.htm#L17E">32-bit Intel Basic Hex Record</a></li>
 </ul>
<hr>
<a id="L0A9"></a><h4>Motorola</h4>
<h4>Motorola Numeric Literal Format</h4>
<p>Binary and hexadecimal Motorola numbers are specified by a <em>prefix</em>:</p>
<ul> <li><b>%</b>  for binary numbers</li>
 <li><b>$</b>  for hexdecimal numbers</li>
 </ul>
<p>A number is assumed to be decimal unless it is prefixed by one of these two symbols.</p>
<h4>Example</h4>
<p>The decimal number 192:</p>
<ul> <li>binary : %11000000</li>
 <li>decimal : 192</li>
 <li>hexadecimal : $C0</li>
 </ul>
<a id="L0AA"></a>
<h4>Motorola SRecord Object File Format</h4>
<p>The Motorola Hexadecimal Object file format is an ASCII text representation of an absolute memory image. The specification is based on processors with accumulator widths of 8-, 16- and 32-bits.</p>
<p>Each line of the file represents a single record consisting of up to six fields:</p>
<blockquote> <b>Record Mark | Record Type | Record Length | Absolute Addr | Data Field | Checksum</b>  (EOT)<br> </blockquote>
<p><em>EOT</em> stands for the "End of Text" marker that ends each line of text. The exact marker varies between operating systems.</p>
<p>The fields are defined as:</p>
<ul> <li>Record Mark: - 1 character; always 'S' (ASCII $83)</li>
 <li>Record Type: - 1 character; one of nine types numbered zero to nine (ASCII $30 to $39)</li>
 <li>Record Length: - 2 characters; length of following three fields; 8-bit octet count</li>
 <li>Absolute Addr:  - 4, 6 or 8 characters; absolute load Address of this record</li>
 <li>Data Field: -  2 &ast; Data Bytes characters; only for Record Types One to Three</li>
 <li>Checksum: -    2 characters; one's complement of ($FF - ((len(Absolute Addr + Data Field + 1) + sum(Data Field)) & $FF)</li>
 </ul>
<p>The Record Types are defined as:</p>
<ul> <li>0: ASCII $30, Header, data is the first <a href="#L09D">hexdatasize=</a>-1 characters of the <a href="#L007">root file</a> name, terminated by a $00 octet</li>
 <li>1: ASCII $31, Absolute Address is 16-bits, 4 characters</li>
 <li>2: ASCII $32, Absolute Address is 24-bits, 6 characters</li>
 <li>3: ASCII $33, Absolute Address is 32-bits, 8 characters</li>
 <li>4: ASCII $34, <em>not defined or used</em></li>
 <li>5: ASCII $35, Record Count, 16-bits, 4 characters, chosen if less than 65,536 data records are output</li>
 <li>6: ASCII $36, Record Count, 24-bits, 6 characters, chosen if at least 65,536 data records are output</li>
 <li>7: ASCII $37, 32-bit Absolute Start Address, and terminate Type 3 records</li>
 <li>8: ASCII $38, 24-bit Absolute Start Address, and terminate Type 2 records</li>
 <li>9: ASCII $39, 16-bit Absolute Start Address, and terminate Type 1 records</li>
 </ul>
<h4>Notes on the Base Specification Assumptions</h4>
<ul> <li>8-bit "bytes"</li>
 <li>Addresses start at zero (0000H) and do not exceed 16-bits (FFFFH). Thus the familiar "S19" file extension</li>
 </ul>
<h4>ASSUME and Motorola SRecord  Files</h4>
<p>HXA default mode selection is based on the width of the <a href="#L06A">CPU</a> <a href="#L029">program counter</a>:</p>
<ul> <li>'S19' : up to 16 bits wide</li>
 <li>'S28' : greater than 16 but no more than 24 bits wide</li>
 <li>'S37' : greater than 24 bits wide</li>
 </ul>
<p>HXA allows the default Address record types in a Motorola SRecord Object file to be overridden by using the <b>ASSUME</b>  pseudo opcode:</p>
<ul> <li><b>ASSUME</b>  srecfile=['S19', 'S28', 'S37'] : 16-, 24-, or 32-bit Address space, respectively</li>
 </ul>
<p>These may be used at any point in the source file(s). <em>SRECFILE</em> may be used as often as desired, but any option chosen must always be the same. If any use after the first differs from the first, a warning will be generated and the request ignored.</p>
<p>If <em>SRECFILE</em> is used to force a smaller Address space than what the <a href="#L06A">CPU</a> would normally allow, data already generated is checked to guarantee it all fits within that smaller Address space. If an out-of-range value is discovered, the error is thus reported as belonging to the <em>SRECFILE</em> line which lowered the limit. Any later line that forces an out-of-range Address value is reported normally.</p>
<p>There are three more assumptions recognized by HXA:</p>
<ul> <li><b>ASSUME</b>  srecfile=noheader : suppresses the output of any 'S0' record</li>
 <li><b>ASSUME</b>  srecfile=noname : allows an 'S0' record but no name data will be output; only the trailing $00 octet will appear</li>
 <li><b>ASSUME</b>  srecfile=nocount : suppresses the output of any 'S5' or 'S6' records</li>
 </ul>
<p>HXA outputs Motorola SRecords in numeric order of type. HXA defaults to outputting an 'S0' record which includes the name of the <a href="#L007">root file</a>, and an 'S5' or 'S6' data record count.</p>
<h4>Non-Standard Byte Sizes</h4>
<p>The Motorola SRecord Object Format is modified in a non-standard way if the size of a "byte" (smallest Addressable unit) is 16- or 32-bits.</p>
<p>16-Bit Bytes</p>
<ul> <li>the 'Record Mark' is always 'T' (ASCII $84)</li>
 <li>the 'Record Length' is always 8-bit octet correct</li>
 <li>the 'Absolute Address' is always byte-correct whatever the "byte" size is</li>
 <li>the number of data characters can be up to 4 &ast; <a href="#L09D">HEXDATASIZE=</a> (up to 128 characters)</li>
 <li>the default file extension is 'T28'</li>
 </ul>
<p>32-Bit Bytes</p>
<ul> <li>the 'Record Mark' is always 'U' (ASCII $85)</li>
 <li>the 'Record Length' is always 8-bit octet correct</li>
 <li>the 'Absolute Address' is always byte-correct whatever the "byte" size is</li>
 <li>the number of data characters can be up to 8 &ast; HEXDATASIZE (up to 256 characters)</li>
 <li>the default file extension is 'U37'</li>
 </ul>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L176">16-bit Motorola Basic TRecord</a></li>
 <li><a href="hxa_test.htm#L17D">32-bit Motorola Basic URecord</a></li>
 </ul>
<hr>
<a id="L0AB"></a>
<a id="L0AC"></a><h4>Octet Extraction Order</h4>
<p>While evaluated integer results may have any value, during file output HXA considers only the low 32-bits of each. Which bits get extracted is based on the <a href="#L06E">BIT--</a> pseudo opcodes associated with them.</p>
<p>Consider the 32-bit value 0x33221100. Then the first (highest) octet is 0x33, the second is 0x22, the third is 0x11, and the fourth (lowest) is 0x00. Internally, HXA extracts these low octet to high.</p>
<p>For a most-significant byte first (MSB) processor, the default extraction sequence for each family is:</p>
<ul> <li>BIT08- : 0x00</li>
 <li>BIT16- : 0x11 0x00</li>
 <li>BIT24- : 0x22 0x11 0x00</li>
 <li>BIT32- : 0x33 0x22 0x11 0x00</li>
 </ul>
<p>For a least-significant byte first (LSB) processor, the default extraction sequence for each family is:</p>
<ul> <li>BIT08- : 0x00</li>
 <li>BIT16- : 0x00 0x11</li>
 <li>BIT24- : 0x00 0x11 0x22</li>
 <li>BIT32- : 0x00 0x11 0x22 0x33</li>
 </ul>
<p>In most cases the programmer needs to do nothing. If a "byte" is a standard eight bits, then all the <b>BIT--</b>  pseudo opcodes will be available. All HXA needs to know is if the CPU in use is least- or most-significant byte first, which affects storage order (not extraction order).</p>
<h4>Examples</h4>
<ul> <li><b>ASSUME</b>  bit32=0123 : default 32-bit extraction sequence</li>
 <li><b>ASSUME</b>  BIT08=2 : extract the third octet rather than the fourth</li>
 <li><b>ASSUME</b>  BIT16R=01 : extract two octets in LSB 16-bit order</li>
 <li><b>ASSUME</b>  BIT32=1032 : extract four octets in MSB 16-bit order, LSB 16-bit first</li>
 <li><a href="hxa_test.htm#L172">Assume Non-Default Order</a></li>
 </ul>
<h4>Notes</h4>
<ul> <li>the opcode specified must be a <b>BIT--</b>  pseudo opcode, but the whole family of related BIT--, RBIT--, SBIT-- and UBIT-- pseudo opcodes are affected as well</li>
 <li>the number of argument octets must match the number in the family affected (eg., <b>BIT32R</b>  requires four octet numbers, <b>BIT08</b>  just one)</li>
 <li>argument octet numbers themselves must all be from the set 0..3 and can appear only once in a set</li>
 </ul>
<hr>
<a id="L0AD"></a>
<a id="L0AE"></a><h4>Non-Standard BYTE Sizes</h4>
<p>The most common contemporary size of a processor's smallest Addressable unit is eight bits, also commonly known as a "byte". However, this is not the only possible size. Historically many processors have used other minimum Addressable unit sizes.</p>
<p>For convenience we'll continue to call the minimum Addressable unit of any processor a <em>byte</em>. If we want to particularly distinguish an 8-bit byte we will refer to an <em>octet</em>.</p>
<p>HXA can handle processor "byte" sizes of 8-, 16- and 32-bits. Which size to use is specified by the <a href="#L06B">CPU descriptor</a> during initialization.</p>
<p>The main documentation generally assumes a "byte" is equivalent to an "octet". Here we outline what changes when they are not the same.</p>
<h4>BIT-- Pseudo Opcodes</h4>
<h4>Base Descriptions</h4>
<ul> <li><a href="#L06E">BIT--</a></li>
 <li><a href="#L06F">RBIT--</a></li>
 <li><a href="#L070">SBIT--</a></li>
 <li><a href="#L071">UBIT--</a></li>
 </ul>
<p>The "bytes" of each base description refer to octet values.</p>
<h4>Description</h4>
<p>The pseudo opcodes <em>-BYTE-</em>, <em>-WORD-</em> and <em>-LONG-</em> are actually aliases:</p>
<ul> <li><em>-BYTE-</em> aliases the smallest Addressable unit</li>
 <li><em>-WORD-</em> aliases two of the smallest Addressable units</li>
 <li><em>-LONG-</em> aliases four of the smallest Addressable units</li>
 </ul>
<p>Which <em>BIT--</em> pseudo opcodes they alias changes, depending on the byte size. For a given smallest Addressable unit, the available aliases are:</p>
<ul> <li>8-bits : <em>-BYTE-, -WORD-, -LONG-</em></li>
 <li>16 bits : <em>-BYTE-, -WORD-</em></li>
 <li>32 bits : <em>-BYTE-</em></li>
 </ul>
<p>Use of an unavailable alias results in an error.</p>
<p><em>-BYTE-</em> and <em>-REVBYTE-</em> are essentially identical in the case of 8-bit bytes. Their results will differ in the case of 16- and 32-bit bytes.</p>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L174">16-Bit BYTE</a></li>
 <li><a href="hxa_test.htm#L175">16-bit String Literals</a></li>
 <li><a href="hxa_test.htm#L178">16-bit FILL and PADTO</a></li>
 <li><a href="hxa_test.htm#L17A">16-bit HEX and INCBIN</a></li>
 <li><a href="hxa_test.htm#L17B">32-bit BYTE</a></li>
 <li><a href="hxa_test.htm#L17C">32-bit String Literals</a></li>
 <li><a href="hxa_test.htm#L17F">32-bit FILL and PADTO</a></li>
 <li><a href="hxa_test.htm#L180">32-bit PADFROM</a></li>
 <li><a href="hxa_test.htm#L181">32-bit HEX and INCBIN</a></li>
 </ul>
<hr>
<a id="L0B0"></a>
<a id="L0B0"></a><h4>Floating Point Output</h4>
<p>HXA converts decimal numbers in source text into an internal floating point form that is assumed to be identical to an IEEE-754 double precision representation. This representation is then formatted for output according to the current <a href="#L09D">float=</a> assumption.</p>
<p>In theory, this assumption could fail, because the Python language itself is agnostic about its underlying floating point representation. In practice, it is almost always safe, because it is difficult to find any existing implementation that is <em>not</em> compatible with the IEEE-754 standard. In particular, the most widely used Python implementation, the CPython reference version, has explicitly required adherence to IEEE-754 since at least version 3.11.</p>
<p>But adherence to the IEEE-754 standard is not actually required by Python itself. Checking the implementation used to execute HXA might be prudent.</p>
<p>For all formats, a floating point value of zero is output with all octets having a value of zero.</p>
<p>For IEEE formats, only normal decimal values are supported. Subnormals, NaNs and infinities are <em>not</em> supported.</p>
<h4>IEEE-Double Precision</h4>
<h4>Description</h4>
<p>8 Octets (64 Bits): 1 Sign Bit, 11 Exponent Bits, 52 Mantissa Bits</p>
<ul> <li>Max Value: (2 - 2&ast;&ast;-52) &ast; 2&ast;&ast;1023</li>
 <li>Min Value: 2&ast;&ast;-1022</li>
 <li>approximate range plus or minus 1.798e+308 to 2.225e-308</li>
 </ul>
<table> <thead> <tr><th>Memory Address</th><th>Ieee-Double-BE</th><th>Ieee-Double-LE</th></tr> </thead><tbody> <tr><td colspan="3">&nbsp;</td></tr> <tr><td>Addr+7</td><td>MMMMMMMM</td><td>SEEEEEEE</td></tr> <tr><td>Addr+6</td><td>MMMMMMMM</td><td>EEEEMMMM</td></tr> <tr><td>Addr+5</td><td>MMMMMMMM</td><td>MMMMMMMM</td></tr> <tr><td>Addr+4</td><td>MMMMMMMM</td><td>MMMMMMMM</td></tr> <tr><td>Addr+3</td><td>MMMMMMMM</td><td>MMMMMMMM</td></tr> <tr><td>Addr+2</td><td>MMMMMMMM</td><td>MMMMMMMM</td></tr> <tr><td>Addr+1</td><td>EEEEMMMM</td><td>MMMMMMMM</td></tr> <tr><td>Addr+0</td><td>SEEEEEEE</td><td>MMMMMMMM</td></tr> <tr><td colspan="3">&nbsp;</td></tr> <tr><td>Sign Bit</td><td>Bit 7, Addr+0</td><td>Bit 7, Addr+7</td></tr> <tr><td>Exponent MSB</td><td>Bit 6, Addr+0</td><td>Bit 6, Addr+7</td></tr> <tr><td>Exponent LSB</td><td>Bit 4, Addr+1</td><td>Bit 4, Addr+6</td></tr> <tr><td>Mantissa MSB</td><td>Bit 3, Addr+1</td><td>Bit 3, Addr+6</td></tr> <tr><td>Mantissa LSB</td><td>Bit 0, Addr+7</td><td>Bit 0, Addr+0</td></tr> </tbody> </table>
<h4>IEEE Single Precsion</h4>
<h4>Description</h4>
<p>4 Octets (32 Bits): 1 Sign Bit, 8 Exponent Bits, 23 Mantissa Bits</p>
<ul> <li>Max Value: (2 - 2&ast;&ast;-23) &ast; 2&ast;&ast;127</li>
 <li>Min Value:  2&ast;&ast;2-126</li>
 <li>approximate range plus or minus 3.403e+38 to 1.175e-38</li>
 </ul>
<table> <thead> <tr><th>Memory Address</th><th>Ieee-Single-BE</th><th>Ieee-Single-LE</th></tr> </thead><tbody> <tr><td colspan="3">&nbsp;</td></tr> <tr><td>Addr+3</td><td>MMMMMMMM</td><td>SEEEEEEE</td></tr> <tr><td>Addr+2</td><td>MMMMMMMM</td><td>EMMMMMMM</td></tr> <tr><td>Addr+1</td><td>EMMMMMMM</td><td>MMMMMMMM</td></tr> <tr><td>Addr+0</td><td>SEEEEEEE</td><td>MMMMMMMM</td></tr> <tr><td colspan="3">&nbsp;</td></tr> <tr><td>Sign Bit</td><td>Bit 7, Addr+0</td><td>Bit 7, Addr+3</td></tr> <tr><td>Exponent MSB</td><td>Bit 6, Addr+0</td><td>Bit 6, Addr+3</td></tr> <tr><td>Exponent LSB</td><td>Bit 7, Addr+1</td><td>Bit 7, Addr+2</td></tr> <tr><td>Mantissa MSB</td><td>Bit 6, Addr+1</td><td>Bit 6, Addr+2</td></tr> <tr><td>Mantissa LSB</td><td>Bit 0, Addr+3</td><td>Bit 0, Addr+0</td></tr> </tbody> </table>
<h4>IEEE Half Precision</h4>
<h4>Description</h4>
<p>2 Octets (16 Bits): 1 Sign Bit, 5 Exponent Bits, 10 Mantissa Bits</p>
<ul> <li>Max Value: (2 - 2&ast;&ast;-10) &ast; 2&ast;&ast;15</li>
 <li>Min Value: 2&ast;&ast;-14</li>
 <li>range plus or minus 65504 to 0.00006103515625</li>
 </ul>
<table> <thead> <tr><th>Memory Address</th><th>Ieee-Half-BE</th><th>Ieee-Half-LE</th></tr> </thead><tbody> <tr><td colspan="3">&nbsp;</td></tr> <tr><td>Addr+1</td><td>MMMMMMMM</td><td>SEEEEEMM</td></tr> <tr><td>Addr+0</td><td>SEEEEEMM</td><td>MMMMMMMM</td></tr> <tr><td colspan="3">&nbsp;</td></tr> <tr><td>Sign Bit</td><td>Bit 7, Addr+0</td><td>Bit 7, Addr+1</td></tr> <tr><td>Exponent MSB</td><td>Bit 6, Addr+0</td><td>Bit 6, Addr+1</td></tr> <tr><td>Exponent LSB</td><td>Bit 2, Addr+0</td><td>Bit 2, Addr+1</td></tr> <tr><td>Mantissa MSB</td><td>Bit 1, Addr+0</td><td>Bit 1, Addr+1</td></tr> <tr><td>Mantissa LSB</td><td>Bit 0, Addr+1</td><td>Bit 0, Addr+0</td></tr> </tbody> </table>
<h4>ESM4</h4>
<h4>Description</h4>
<p>A name that describes a common floating point format prior to the IEEE-754 standard. This format is particularly suited to 8-bit processors.</p>
<p>5 Octets (40 Bits): 8 Exponent Bits, 1 Sign Bit, 31 Mantissa Bits</p>
<ul> <li>Max Value: (2 - 2&ast;&ast;-31) &ast; 2&ast;&ast;126</li>
 <li>Min Value:  2&ast;&ast;-128</li>
 <li>range approximately plus or minus  1.701e+38 to 2.939e-39</li>
 </ul>
<table> <thead> <tr><th>Memory Address</th><th>Esm4-BE</th><th>Esm4-LE</th></tr> </thead><tbody> <tr><td colspan="3">&nbsp;</td></tr> <tr><td>Addr+4</td><td>MMMMMMMM</td><td>EEEEEEEE</td></tr> <tr><td>Addr+3</td><td>MMMMMMMM</td><td>SMMMMMMM</td></tr> <tr><td>Addr+2</td><td>MMMMMMMM</td><td>MMMMMMMM</td></tr> <tr><td>Addr+1</td><td>SMMMMMMM</td><td>MMMMMMMM</td></tr> <tr><td>Addr+0</td><td>EEEEEEEE</td><td>MMMMMMMM</td></tr> <tr><td colspan="3">&nbsp;</td></tr> <tr><td>Sign Bit</td><td>Bit 7, Addr+1</td><td>Bit 7, Addr+3</td></tr> <tr><td>Exponent MSB</td><td>Bit 7, Addr+0</td><td>Bit 7, Addr+4</td></tr> <tr><td>Exponent LSB</td><td>Bit 0, Addr+0</td><td>Bit 0, Addr+4</td></tr> <tr><td>Mantissa MSB</td><td>Bit 6, Addr+1</td><td>Bit 6, Addr+3</td></tr> <tr><td>Mantissa LSB</td><td>Bit 0, Addr+4</td><td>Bit 0, Addr+0</td></tr> </tbody> </table>
<h4>Examples</h4>
<ul> <li><a href="hxa_test.htm#L186">FLOAT</a></li>
 </ul>
</div></section></body></html>
